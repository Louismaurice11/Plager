# Generated from CSharpParser.g4 by ANTLR 4.7.2
# encoding: utf-8
from antlr4 import *
from io import StringIO
from typing.io import TextIO
import sys

from algorithm.Parsers.CSParser.CSharpParserBase import CSharpParserBase


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3\u00c8")
        buf.write("\u0a5b\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\4\30\t\30\4\31")
        buf.write("\t\31\4\32\t\32\4\33\t\33\4\34\t\34\4\35\t\35\4\36\t\36")
        buf.write("\4\37\t\37\4 \t \4!\t!\4\"\t\"\4#\t#\4$\t$\4%\t%\4&\t")
        buf.write("&\4\'\t\'\4(\t(\4)\t)\4*\t*\4+\t+\4,\t,\4-\t-\4.\t.\4")
        buf.write("/\t/\4\60\t\60\4\61\t\61\4\62\t\62\4\63\t\63\4\64\t\64")
        buf.write("\4\65\t\65\4\66\t\66\4\67\t\67\48\t8\49\t9\4:\t:\4;\t")
        buf.write(";\4<\t<\4=\t=\4>\t>\4?\t?\4@\t@\4A\tA\4B\tB\4C\tC\4D\t")
        buf.write("D\4E\tE\4F\tF\4G\tG\4H\tH\4I\tI\4J\tJ\4K\tK\4L\tL\4M\t")
        buf.write("M\4N\tN\4O\tO\4P\tP\4Q\tQ\4R\tR\4S\tS\4T\tT\4U\tU\4V\t")
        buf.write("V\4W\tW\4X\tX\4Y\tY\4Z\tZ\4[\t[\4\\\t\\\4]\t]\4^\t^\4")
        buf.write("_\t_\4`\t`\4a\ta\4b\tb\4c\tc\4d\td\4e\te\4f\tf\4g\tg\4")
        buf.write("h\th\4i\ti\4j\tj\4k\tk\4l\tl\4m\tm\4n\tn\4o\to\4p\tp\4")
        buf.write("q\tq\4r\tr\4s\ts\4t\tt\4u\tu\4v\tv\4w\tw\4x\tx\4y\ty\4")
        buf.write("z\tz\4{\t{\4|\t|\4}\t}\4~\t~\4\177\t\177\4\u0080\t\u0080")
        buf.write("\4\u0081\t\u0081\4\u0082\t\u0082\4\u0083\t\u0083\4\u0084")
        buf.write("\t\u0084\4\u0085\t\u0085\4\u0086\t\u0086\4\u0087\t\u0087")
        buf.write("\4\u0088\t\u0088\4\u0089\t\u0089\4\u008a\t\u008a\4\u008b")
        buf.write("\t\u008b\4\u008c\t\u008c\4\u008d\t\u008d\4\u008e\t\u008e")
        buf.write("\4\u008f\t\u008f\4\u0090\t\u0090\4\u0091\t\u0091\4\u0092")
        buf.write("\t\u0092\4\u0093\t\u0093\4\u0094\t\u0094\4\u0095\t\u0095")
        buf.write("\4\u0096\t\u0096\4\u0097\t\u0097\4\u0098\t\u0098\4\u0099")
        buf.write("\t\u0099\4\u009a\t\u009a\4\u009b\t\u009b\4\u009c\t\u009c")
        buf.write("\4\u009d\t\u009d\4\u009e\t\u009e\4\u009f\t\u009f\4\u00a0")
        buf.write("\t\u00a0\4\u00a1\t\u00a1\4\u00a2\t\u00a2\4\u00a3\t\u00a3")
        buf.write("\4\u00a4\t\u00a4\4\u00a5\t\u00a5\4\u00a6\t\u00a6\4\u00a7")
        buf.write("\t\u00a7\4\u00a8\t\u00a8\4\u00a9\t\u00a9\4\u00aa\t\u00aa")
        buf.write("\4\u00ab\t\u00ab\4\u00ac\t\u00ac\4\u00ad\t\u00ad\4\u00ae")
        buf.write("\t\u00ae\4\u00af\t\u00af\4\u00b0\t\u00b0\4\u00b1\t\u00b1")
        buf.write("\4\u00b2\t\u00b2\4\u00b3\t\u00b3\4\u00b4\t\u00b4\4\u00b5")
        buf.write("\t\u00b5\4\u00b6\t\u00b6\4\u00b7\t\u00b7\4\u00b8\t\u00b8")
        buf.write("\4\u00b9\t\u00b9\4\u00ba\t\u00ba\4\u00bb\t\u00bb\4\u00bc")
        buf.write("\t\u00bc\4\u00bd\t\u00bd\4\u00be\t\u00be\4\u00bf\t\u00bf")
        buf.write("\4\u00c0\t\u00c0\4\u00c1\t\u00c1\4\u00c2\t\u00c2\4\u00c3")
        buf.write("\t\u00c3\4\u00c4\t\u00c4\4\u00c5\t\u00c5\4\u00c6\t\u00c6")
        buf.write("\4\u00c7\t\u00c7\4\u00c8\t\u00c8\4\u00c9\t\u00c9\4\u00ca")
        buf.write("\t\u00ca\4\u00cb\t\u00cb\4\u00cc\t\u00cc\4\u00cd\t\u00cd")
        buf.write("\4\u00ce\t\u00ce\4\u00cf\t\u00cf\4\u00d0\t\u00d0\4\u00d1")
        buf.write("\t\u00d1\4\u00d2\t\u00d2\4\u00d3\t\u00d3\4\u00d4\t\u00d4")
        buf.write("\4\u00d5\t\u00d5\4\u00d6\t\u00d6\4\u00d7\t\u00d7\4\u00d8")
        buf.write("\t\u00d8\4\u00d9\t\u00d9\4\u00da\t\u00da\4\u00db\t\u00db")
        buf.write("\4\u00dc\t\u00dc\3\2\5\2\u01ba\n\2\3\2\5\2\u01bd\n\2\3")
        buf.write("\2\5\2\u01c0\n\2\3\2\7\2\u01c3\n\2\f\2\16\2\u01c6\13\2")
        buf.write("\3\2\5\2\u01c9\n\2\3\2\3\2\3\3\3\3\5\3\u01cf\n\3\3\3\5")
        buf.write("\3\u01d2\n\3\3\3\3\3\3\3\5\3\u01d7\n\3\7\3\u01d9\n\3\f")
        buf.write("\3\16\3\u01dc\13\3\3\4\3\4\3\4\3\4\7\4\u01e2\n\4\f\4\16")
        buf.write("\4\u01e5\13\4\3\5\3\5\3\5\3\5\3\5\5\5\u01ec\n\5\3\6\3")
        buf.write("\6\3\6\3\6\6\6\u01f2\n\6\r\6\16\6\u01f3\3\6\3\6\3\7\3")
        buf.write("\7\5\7\u01fa\n\7\3\b\3\b\5\b\u01fe\n\b\3\t\3\t\3\t\5\t")
        buf.write("\u0203\n\t\3\n\3\n\3\13\3\13\3\f\3\f\3\f\3\f\5\f\u020d")
        buf.write("\n\f\3\r\3\r\3\r\3\r\7\r\u0213\n\r\f\r\16\r\u0216\13\r")
        buf.write("\3\r\3\r\3\16\3\16\3\16\7\16\u021d\n\16\f\16\16\16\u0220")
        buf.write("\13\16\3\17\3\17\3\17\5\17\u0225\n\17\3\17\5\17\u0228")
        buf.write("\n\17\3\17\3\17\3\17\5\17\u022d\n\17\3\17\5\17\u0230\n")
        buf.write("\17\3\20\3\20\3\20\3\20\5\20\u0236\n\20\3\21\3\21\3\21")
        buf.write("\5\21\u023b\n\21\3\22\3\22\3\22\3\22\3\22\3\22\3\22\3")
        buf.write("\22\5\22\u0245\n\22\3\23\3\23\3\23\3\23\3\23\3\23\3\23")
        buf.write("\3\23\3\23\3\23\3\23\5\23\u0252\n\23\3\24\3\24\3\24\3")
        buf.write("\24\3\24\3\24\5\24\u025a\n\24\3\25\3\25\3\25\3\25\5\25")
        buf.write("\u0260\n\25\5\25\u0262\n\25\3\26\3\26\3\26\7\26\u0267")
        buf.write("\n\26\f\26\16\26\u026a\13\26\3\27\3\27\3\27\7\27\u026f")
        buf.write("\n\27\f\27\16\27\u0272\13\27\3\30\3\30\3\30\7\30\u0277")
        buf.write("\n\30\f\30\16\30\u027a\13\30\3\31\3\31\3\31\7\31\u027f")
        buf.write("\n\31\f\31\16\31\u0282\13\31\3\32\3\32\3\32\7\32\u0287")
        buf.write("\n\32\f\32\16\32\u028a\13\32\3\33\3\33\3\33\7\33\u028f")
        buf.write("\n\33\f\33\16\33\u0292\13\33\3\34\3\34\3\34\3\34\3\34")
        buf.write("\3\34\3\34\7\34\u029b\n\34\f\34\16\34\u029e\13\34\3\35")
        buf.write("\3\35\3\35\5\35\u02a3\n\35\3\35\7\35\u02a6\n\35\f\35\16")
        buf.write("\35\u02a9\13\35\3\36\3\36\3\36\7\36\u02ae\n\36\f\36\16")
        buf.write("\36\u02b1\13\36\3\37\3\37\3\37\7\37\u02b6\n\37\f\37\16")
        buf.write("\37\u02b9\13\37\3 \3 \3 \3 \3 \5 \u02c0\n \5 \u02c2\n")
        buf.write(" \3 \5 \u02c5\n \3!\3!\3!\7!\u02ca\n!\f!\16!\u02cd\13")
        buf.write("!\3\"\3\"\5\"\u02d1\n\"\3\"\3\"\3\"\3#\3#\5#\u02d8\n#")
        buf.write("\3#\3#\5#\u02dc\n#\5#\u02de\n#\3$\3$\3$\3$\3$\3$\3$\3")
        buf.write("$\3$\3$\3$\3$\3$\3$\3$\3$\3$\3$\3$\3$\3$\3$\5$\u02f6\n")
        buf.write("$\3%\3%\3%\3%\3%\3&\3&\5&\u02ff\n&\3&\7&\u0302\n&\f&\16")
        buf.write("&\u0305\13&\3&\5&\u0308\n&\3&\3&\3&\3&\3&\3&\5&\u0310")
        buf.write("\n&\3&\5&\u0313\n&\3&\7&\u0316\n&\f&\16&\u0319\13&\3&")
        buf.write("\5&\u031c\n&\7&\u031e\n&\f&\16&\u0321\13&\3\'\3\'\3\'")
        buf.write("\5\'\u0326\n\'\3\'\3\'\3\'\3\'\3\'\3\'\3\'\3\'\3\'\3\'")
        buf.write("\3\'\3\'\5\'\u0334\n\'\3\'\3\'\3\'\3\'\5\'\u033a\n\'\3")
        buf.write("\'\3\'\3\'\3\'\3\'\3\'\3\'\3\'\7\'\u0344\n\'\f\'\16\'")
        buf.write("\u0347\13\'\3\'\5\'\u034a\n\'\3\'\6\'\u034d\n\'\r\'\16")
        buf.write("\'\u034e\3\'\3\'\5\'\u0353\n\'\3\'\3\'\3\'\3\'\5\'\u0359")
        buf.write("\n\'\3\'\3\'\3\'\3\'\6\'\u035f\n\'\r\'\16\'\u0360\3\'")
        buf.write("\3\'\3\'\3\'\3\'\3\'\3\'\5\'\u036a\n\'\3\'\3\'\3\'\3\'")
        buf.write("\3\'\3\'\3\'\3\'\3\'\3\'\3\'\3\'\3\'\3\'\3\'\3\'\5\'\u037c")
        buf.write("\n\'\3\'\5\'\u037f\n\'\3\'\3\'\3\'\5\'\u0384\n\'\3\'\5")
        buf.write("\'\u0387\n\'\3\'\3\'\3\'\3\'\3\'\3\'\3\'\3\'\3\'\3\'\3")
        buf.write("\'\7\'\u0394\n\'\f\'\16\'\u0397\13\'\3\'\3\'\3\'\5\'\u039c")
        buf.write("\n\'\3(\3(\5(\u03a0\n(\3)\3)\3)\3*\5*\u03a6\n*\3*\3*\3")
        buf.write("*\5*\u03ab\n*\3+\5+\u03ae\n+\3+\3+\3+\3+\7+\u03b4\n+\f")
        buf.write("+\16+\u03b7\13+\3+\3+\3,\3,\3,\5,\u03be\n,\3,\3,\3-\3")
        buf.write("-\3.\3.\3.\7.\u03c7\n.\f.\16.\u03ca\13.\3/\3/\5/\u03ce")
        buf.write("\n/\3\60\3\60\3\60\5\60\u03d3\n\60\5\60\u03d5\n\60\3\60")
        buf.write("\3\60\3\61\3\61\3\61\7\61\u03dc\n\61\f\61\16\61\u03df")
        buf.write("\13\61\3\62\3\62\3\62\3\62\3\62\5\62\u03e6\n\62\3\62\3")
        buf.write("\62\3\62\3\63\3\63\5\63\u03ed\n\63\3\64\3\64\3\64\3\64")
        buf.write("\7\64\u03f3\n\64\f\64\16\64\u03f6\13\64\3\64\5\64\u03f9")
        buf.write("\n\64\3\64\3\64\3\65\3\65\3\65\3\65\3\65\5\65\u0402\n")
        buf.write("\65\3\66\3\66\3\66\5\66\u0407\n\66\5\66\u0409\n\66\3\66")
        buf.write("\3\66\3\67\3\67\3\67\7\67\u0410\n\67\f\67\16\67\u0413")
        buf.write("\13\67\38\38\38\38\38\58\u041a\n8\39\39\59\u041e\n9\3")
        buf.write("9\39\39\59\u0423\n9\59\u0425\n9\39\39\39\59\u042a\n9\7")
        buf.write("9\u042c\n9\f9\169\u042f\139\3:\3:\7:\u0433\n:\f:\16:\u0436")
        buf.write("\13:\3:\3:\3;\3;\3;\7;\u043d\n;\f;\16;\u0440\13;\3;\5")
        buf.write(";\u0443\n;\3;\5;\u0446\n;\3;\5;\u0449\n;\3<\3<\3<\3<\7")
        buf.write("<\u044f\n<\f<\16<\u0452\13<\3<\3<\3=\3=\3=\3=\3>\5>\u045b")
        buf.write("\n>\3>\3>\3>\3>\3?\3?\3?\3?\3?\3?\3?\3?\3?\3?\3?\5?\u046c")
        buf.write("\n?\3@\3@\3@\7@\u0471\n@\f@\16@\u0474\13@\3A\5A\u0477")
        buf.write("\nA\3A\3A\3A\3B\3B\3B\7B\u047f\nB\fB\16B\u0482\13B\3C")
        buf.write("\3C\5C\u0486\nC\3D\3D\3D\3E\3E\5E\u048d\nE\3E\3E\3E\3")
        buf.write("E\3F\7F\u0494\nF\fF\16F\u0497\13F\3F\3F\5F\u049b\nF\3")
        buf.write("G\3G\3G\3G\3G\5G\u04a2\nG\3H\3H\3H\3H\3H\3I\3I\3I\3J\3")
        buf.write("J\5J\u04ae\nJ\3J\3J\3J\3J\3J\3J\3J\3J\3J\5J\u04b9\nJ\3")
        buf.write("K\3K\3K\3K\7K\u04bf\nK\fK\16K\u04c2\13K\3L\3L\5L\u04c6")
        buf.write("\nL\3M\3M\3M\3M\3M\3M\3M\5M\u04cf\nM\3N\3N\3N\3N\3O\3")
        buf.write("O\3O\5O\u04d8\nO\3P\3P\3P\3P\3P\3P\3P\5P\u04e1\nP\3Q\3")
        buf.write("Q\3Q\3R\5R\u04e7\nR\3R\3R\3R\5R\u04ec\nR\3R\3R\5R\u04f0")
        buf.write("\nR\3R\3R\5R\u04f4\nR\3S\3S\5S\u04f8\nS\3S\3S\5S\u04fc")
        buf.write("\nS\3T\3T\3T\3T\3T\5T\u0503\nT\3U\3U\3U\3U\3V\3V\5V\u050b")
        buf.write("\nV\3W\3W\3W\3W\3W\3W\3W\3W\3W\3W\3W\5W\u0518\nW\3W\3")
        buf.write("W\3W\3W\3W\3W\7W\u0520\nW\fW\16W\u0523\13W\3W\3W\3W\3")
        buf.write("W\3W\3W\3W\3W\3W\3W\3W\3W\3W\3W\3W\3W\3W\3W\3W\5W\u0538")
        buf.write("\nW\3W\3W\5W\u053c\nW\3W\3W\5W\u0540\nW\3W\3W\3W\5W\u0545")
        buf.write("\nW\3W\3W\3W\3W\3W\3W\3W\3W\3W\3W\3W\3W\3W\3W\3W\3W\3")
        buf.write("W\3W\5W\u0559\nW\3W\3W\3W\5W\u055e\nW\3W\3W\3W\5W\u0563")
        buf.write("\nW\3W\3W\3W\3W\3W\5W\u056a\nW\3W\5W\u056d\nW\3W\3W\3")
        buf.write("W\3W\3W\3W\3W\3W\3W\3W\3W\3W\3W\3W\3W\3W\3W\3W\3W\3W\5")
        buf.write("W\u0583\nW\3W\3W\3W\3W\3W\3W\3W\3W\3W\3W\5W\u058f\nW\3")
        buf.write("X\3X\5X\u0593\nX\3X\3X\3Y\3Y\3Y\3Y\5Y\u059b\nY\3Y\3Y\3")
        buf.write("Y\3Y\3Y\3Y\7Y\u05a3\nY\fY\16Y\u05a6\13Y\3Y\3Y\3Y\3Y\5")
        buf.write("Y\u05ac\nY\3Z\3Z\5Z\u05b0\nZ\3[\3[\3[\5[\u05b5\n[\3[\5")
        buf.write("[\u05b8\n[\3\\\3\\\3\\\5\\\u05bd\n\\\3]\3]\3]\3]\3^\3")
        buf.write("^\5^\u05c5\n^\3_\6_\u05c8\n_\r_\16_\u05c9\3_\3_\3`\3`")
        buf.write("\3`\5`\u05d1\n`\3`\3`\3`\3`\5`\u05d7\n`\3a\3a\3a\3b\6")
        buf.write("b\u05dd\nb\rb\16b\u05de\3c\3c\3c\3c\7c\u05e5\nc\fc\16")
        buf.write("c\u05e8\13c\5c\u05ea\nc\3d\3d\3d\7d\u05ef\nd\fd\16d\u05f2")
        buf.write("\13d\3e\3e\7e\u05f6\ne\fe\16e\u05f9\13e\3e\5e\u05fc\n")
        buf.write("e\3e\5e\u05ff\ne\3f\3f\3f\3f\5f\u0605\nf\3f\3f\5f\u0609")
        buf.write("\nf\3f\3f\3g\3g\5g\u060f\ng\3g\3g\3h\3h\3h\3h\3h\3i\3")
        buf.write("i\3i\3j\3j\5j\u061d\nj\3k\3k\3k\3k\5k\u0623\nk\3l\3l\3")
        buf.write("l\7l\u0628\nl\fl\16l\u062b\13l\3m\3m\5m\u062f\nm\3m\5")
        buf.write("m\u0632\nm\3m\5m\u0635\nm\3m\3m\3n\6n\u063a\nn\rn\16n")
        buf.write("\u063b\3o\3o\3o\3o\3o\3p\6p\u0644\np\rp\16p\u0645\3q\3")
        buf.write("q\3q\3q\3q\3q\3q\3q\3q\3q\3q\3q\3q\3q\3q\5q\u0657\nq\3")
        buf.write("r\6r\u065a\nr\rr\16r\u065b\3s\3s\5s\u0660\ns\3t\5t\u0663")
        buf.write("\nt\3t\5t\u0666\nt\3t\3t\3t\3t\3t\5t\u066d\nt\3u\3u\3")
        buf.write("u\3u\5u\u0673\nu\3v\3v\3v\3v\7v\u0679\nv\fv\16v\u067c")
        buf.write("\13v\3v\3v\3w\5w\u0681\nw\3w\3w\3x\3x\3x\3x\7x\u0689\n")
        buf.write("x\fx\16x\u068c\13x\3y\3y\3y\7y\u0691\ny\fy\16y\u0694\13")
        buf.write("y\3z\6z\u0697\nz\rz\16z\u0698\3{\3{\3{\3{\3{\3|\3|\3|")
        buf.write("\3|\5|\u06a4\n|\3|\3|\5|\u06a8\n|\5|\u06aa\n|\3}\3}\3")
        buf.write("}\5}\u06af\n}\3}\3}\5}\u06b3\n}\3~\3~\3~\7~\u06b8\n~\f")
        buf.write("~\16~\u06bb\13~\3\177\3\177\3\177\3\177\3\u0080\3\u0080")
        buf.write("\5\u0080\u06c3\n\u0080\3\u0080\3\u0080\3\u0081\6\u0081")
        buf.write("\u06c8\n\u0081\r\u0081\16\u0081\u06c9\3\u0082\5\u0082")
        buf.write("\u06cd\n\u0082\3\u0082\5\u0082\u06d0\n\u0082\3\u0082\3")
        buf.write("\u0082\5\u0082\u06d4\n\u0082\3\u0083\6\u0083\u06d7\n\u0083")
        buf.write("\r\u0083\16\u0083\u06d8\3\u0084\3\u0084\3\u0085\3\u0085")
        buf.write("\3\u0085\3\u0085\3\u0085\3\u0085\3\u0085\3\u0085\3\u0085")
        buf.write("\5\u0085\u06e6\n\u0085\3\u0085\3\u0085\3\u0085\3\u0085")
        buf.write("\3\u0085\3\u0085\3\u0085\3\u0085\5\u0085\u06f0\n\u0085")
        buf.write("\3\u0086\3\u0086\3\u0086\3\u0086\3\u0086\5\u0086\u06f7")
        buf.write("\n\u0086\3\u0086\3\u0086\3\u0086\3\u0086\3\u0086\3\u0086")
        buf.write("\3\u0086\3\u0086\3\u0086\3\u0086\5\u0086\u0703\n\u0086")
        buf.write("\3\u0087\3\u0087\3\u0087\7\u0087\u0708\n\u0087\f\u0087")
        buf.write("\16\u0087\u070b\13\u0087\3\u0088\3\u0088\3\u0088\3\u0088")
        buf.write("\3\u0089\3\u0089\3\u0089\7\u0089\u0714\n\u0089\f\u0089")
        buf.write("\16\u0089\u0717\13\u0089\3\u008a\3\u008a\3\u008a\5\u008a")
        buf.write("\u071c\n\u008a\3\u008b\3\u008b\5\u008b\u0720\n\u008b\3")
        buf.write("\u008c\3\u008c\5\u008c\u0724\n\u008c\3\u008d\3\u008d\3")
        buf.write("\u008e\3\u008e\5\u008e\u072a\n\u008e\3\u008f\3\u008f\3")
        buf.write("\u008f\3\u008f\5\u008f\u0730\n\u008f\5\u008f\u0732\n\u008f")
        buf.write("\3\u0090\3\u0090\3\u0090\7\u0090\u0737\n\u0090\f\u0090")
        buf.write("\16\u0090\u073a\13\u0090\3\u0091\5\u0091\u073d\n\u0091")
        buf.write("\3\u0091\5\u0091\u0740\n\u0091\3\u0091\3\u0091\5\u0091")
        buf.write("\u0744\n\u0091\3\u0092\3\u0092\3\u0092\3\u0092\3\u0092")
        buf.write("\3\u0092\3\u0092\3\u0092\5\u0092\u074e\n\u0092\3\u0093")
        buf.write("\5\u0093\u0751\n\u0093\3\u0093\3\u0093\3\u0093\3\u0093")
        buf.write("\3\u0094\5\u0094\u0758\n\u0094\3\u0094\5\u0094\u075b\n")
        buf.write("\u0094\3\u0094\3\u0094\3\u0094\5\u0094\u0760\n\u0094\3")
        buf.write("\u0094\3\u0094\3\u0094\5\u0094\u0765\n\u0094\5\u0094\u0767")
        buf.write("\n\u0094\3\u0095\5\u0095\u076a\n\u0095\3\u0095\5\u0095")
        buf.write("\u076d\n\u0095\3\u0095\3\u0095\3\u0095\3\u0096\5\u0096")
        buf.write("\u0773\n\u0096\3\u0096\5\u0096\u0776\n\u0096\3\u0096\3")
        buf.write("\u0096\3\u0096\3\u0097\3\u0097\3\u0097\3\u0097\3\u0097")
        buf.write("\3\u0097\3\u0097\5\u0097\u0782\n\u0097\3\u0098\3\u0098")
        buf.write("\5\u0098\u0786\n\u0098\3\u0099\5\u0099\u0789\n\u0099\3")
        buf.write("\u0099\3\u0099\3\u0099\3\u0099\3\u0099\3\u0099\3\u0099")
        buf.write("\3\u0099\5\u0099\u0793\n\u0099\3\u009a\5\u009a\u0796\n")
        buf.write("\u009a\3\u009a\3\u009a\3\u009a\3\u009b\5\u009b\u079c\n")
        buf.write("\u009b\3\u009b\3\u009b\3\u009b\3\u009c\3\u009c\3\u009c")
        buf.write("\3\u009c\3\u009c\3\u009c\3\u009c\3\u009c\3\u009c\3\u009c")
        buf.write("\3\u009c\3\u009c\3\u009c\3\u009c\3\u009c\3\u009c\3\u009c")
        buf.write("\3\u009c\3\u009c\3\u009c\3\u009c\3\u009c\5\u009c\u07b7")
        buf.write("\n\u009c\3\u009d\3\u009d\3\u009d\3\u009d\3\u009d\3\u009d")
        buf.write("\3\u009d\3\u009e\3\u009e\3\u009e\3\u009e\5\u009e\u07c4")
        buf.write("\n\u009e\3\u009e\3\u009e\3\u009f\3\u009f\5\u009f\u07ca")
        buf.write("\n\u009f\3\u00a0\3\u00a0\3\u00a0\3\u00a1\3\u00a1\7\u00a1")
        buf.write("\u07d1\n\u00a1\f\u00a1\16\u00a1\u07d4\13\u00a1\3\u00a1")
        buf.write("\3\u00a1\3\u00a2\5\u00a2\u07d9\n\u00a2\3\u00a2\5\u00a2")
        buf.write("\u07dc\n\u00a2\3\u00a2\3\u00a2\3\u00a2\3\u00a2\6\u00a2")
        buf.write("\u07e2\n\u00a2\r\u00a2\16\u00a2\u07e3\3\u00a2\3\u00a2")
        buf.write("\5\u00a2\u07e8\n\u00a2\3\u00a3\3\u00a3\7\u00a3\u07ec\n")
        buf.write("\u00a3\f\u00a3\16\u00a3\u07ef\13\u00a3\3\u00a3\6\u00a3")
        buf.write("\u07f2\n\u00a3\r\u00a3\16\u00a3\u07f3\3\u00a4\3\u00a4")
        buf.write("\7\u00a4\u07f8\n\u00a4\f\u00a4\16\u00a4\u07fb\13\u00a4")
        buf.write("\3\u00a4\3\u00a4\3\u00a5\3\u00a5\3\u00a5\3\u00a5\7\u00a5")
        buf.write("\u0803\n\u00a5\f\u00a5\16\u00a5\u0806\13\u00a5\3\u00a5")
        buf.write("\5\u00a5\u0809\n\u00a5\5\u00a5\u080b\n\u00a5\3\u00a5\3")
        buf.write("\u00a5\3\u00a6\3\u00a6\3\u00a6\3\u00a6\7\u00a6\u0813\n")
        buf.write("\u00a6\f\u00a6\16\u00a6\u0816\13\u00a6\3\u00a6\3\u00a6")
        buf.write("\3\u00a7\5\u00a7\u081b\n\u00a7\3\u00a7\5\u00a7\u081e\n")
        buf.write("\u00a7\3\u00a7\3\u00a7\3\u00a8\3\u00a8\3\u00a9\3\u00a9")
        buf.write("\3\u00a9\3\u00aa\3\u00aa\7\u00aa\u0829\n\u00aa\f\u00aa")
        buf.write("\16\u00aa\u082c\13\u00aa\3\u00aa\3\u00aa\3\u00ab\5\u00ab")
        buf.write("\u0831\n\u00ab\3\u00ab\5\u00ab\u0834\n\u00ab\3\u00ab\5")
        buf.write("\u00ab\u0837\n\u00ab\3\u00ab\3\u00ab\3\u00ab\3\u00ab\3")
        buf.write("\u00ab\5\u00ab\u083e\n\u00ab\3\u00ab\3\u00ab\3\u00ab\5")
        buf.write("\u00ab\u0843\n\u00ab\3\u00ab\3\u00ab\5\u00ab\u0847\n\u00ab")
        buf.write("\3\u00ab\3\u00ab\5\u00ab\u084b\n\u00ab\3\u00ab\3\u00ab")
        buf.write("\3\u00ab\3\u00ab\3\u00ab\3\u00ab\3\u00ab\3\u00ab\3\u00ab")
        buf.write("\3\u00ab\3\u00ab\3\u00ab\3\u00ab\3\u00ab\3\u00ab\5\u00ab")
        buf.write("\u085c\n\u00ab\3\u00ab\5\u00ab\u085f\n\u00ab\3\u00ab\3")
        buf.write("\u00ab\3\u00ab\5\u00ab\u0864\n\u00ab\3\u00ab\3\u00ab\5")
        buf.write("\u00ab\u0868\n\u00ab\3\u00ab\3\u00ab\5\u00ab\u086c\n\u00ab")
        buf.write("\3\u00ab\3\u00ab\3\u00ab\3\u00ab\3\u00ab\3\u00ab\3\u00ab")
        buf.write("\5\u00ab\u0875\n\u00ab\3\u00ac\5\u00ac\u0878\n\u00ac\3")
        buf.write("\u00ac\3\u00ac\3\u00ac\5\u00ac\u087d\n\u00ac\3\u00ac\3")
        buf.write("\u00ac\5\u00ac\u0881\n\u00ac\3\u00ac\3\u00ac\3\u00ac\5")
        buf.write("\u00ac\u0886\n\u00ac\3\u00ac\3\u00ac\5\u00ac\u088a\n\u00ac")
        buf.write("\5\u00ac\u088c\n\u00ac\3\u00ad\3\u00ad\3\u00ad\3\u00ae")
        buf.write("\3\u00ae\3\u00ae\3\u00ae\7\u00ae\u0895\n\u00ae\f\u00ae")
        buf.write("\16\u00ae\u0898\13\u00ae\3\u00ae\5\u00ae\u089b\n\u00ae")
        buf.write("\5\u00ae\u089d\n\u00ae\3\u00ae\3\u00ae\3\u00af\5\u00af")
        buf.write("\u08a2\n\u00af\3\u00af\3\u00af\3\u00af\5\u00af\u08a7\n")
        buf.write("\u00af\3\u00b0\3\u00b0\3\u00b0\3\u00b0\3\u00b0\5\u00b0")
        buf.write("\u08ae\n\u00b0\3\u00b0\3\u00b0\3\u00b1\3\u00b1\5\u00b1")
        buf.write("\u08b4\n\u00b1\3\u00b2\6\u00b2\u08b7\n\u00b2\r\u00b2\16")
        buf.write("\u00b2\u08b8\3\u00b3\3\u00b3\3\u00b3\3\u00b3\5\u00b3\u08bf")
        buf.write("\n\u00b3\3\u00b3\3\u00b3\5\u00b3\u08c3\n\u00b3\3\u00b3")
        buf.write("\3\u00b3\3\u00b4\3\u00b4\5\u00b4\u08c9\n\u00b4\3\u00b5")
        buf.write("\3\u00b5\3\u00b5\7\u00b5\u08ce\n\u00b5\f\u00b5\16\u00b5")
        buf.write("\u08d1\13\u00b5\3\u00b6\3\u00b6\3\u00b6\3\u00b6\3\u00b6")
        buf.write("\7\u00b6\u08d8\n\u00b6\f\u00b6\16\u00b6\u08db\13\u00b6")
        buf.write("\5\u00b6\u08dd\n\u00b6\3\u00b6\5\u00b6\u08e0\n\u00b6\3")
        buf.write("\u00b7\3\u00b7\3\u00b7\5\u00b7\u08e5\n\u00b7\3\u00b7\3")
        buf.write("\u00b7\3\u00b8\3\u00b8\5\u00b8\u08eb\n\u00b8\3\u00b8\3")
        buf.write("\u00b8\7\u00b8\u08ef\n\u00b8\f\u00b8\16\u00b8\u08f2\13")
        buf.write("\u00b8\3\u00b8\3\u00b8\3\u00b8\3\u00b8\5\u00b8\u08f8\n")
        buf.write("\u00b8\3\u00b9\3\u00b9\3\u00b9\7\u00b9\u08fd\n\u00b9\f")
        buf.write("\u00b9\16\u00b9\u0900\13\u00b9\3\u00ba\3\u00ba\3\u00ba")
        buf.write("\3\u00ba\3\u00bb\5\u00bb\u0907\n\u00bb\3\u00bb\3\u00bb")
        buf.write("\5\u00bb\u090b\n\u00bb\3\u00bc\3\u00bc\3\u00bc\3\u00bc")
        buf.write("\3\u00bc\3\u00bd\3\u00bd\3\u00bd\3\u00bd\3\u00bd\3\u00bd")
        buf.write("\3\u00bd\3\u00bd\5\u00bd\u091a\n\u00bd\3\u00bd\3\u00bd")
        buf.write("\5\u00bd\u091e\n\u00bd\3\u00bd\3\u00bd\3\u00bd\3\u00bd")
        buf.write("\3\u00bd\7\u00bd\u0925\n\u00bd\f\u00bd\16\u00bd\u0928")
        buf.write("\13\u00bd\3\u00bd\5\u00bd\u092b\n\u00bd\3\u00bd\3\u00bd")
        buf.write("\5\u00bd\u092f\n\u00bd\3\u00be\3\u00be\3\u00be\3\u00be")
        buf.write("\3\u00bf\3\u00bf\3\u00bf\3\u00bf\3\u00c0\3\u00c0\3\u00c0")
        buf.write("\3\u00c0\3\u00c1\3\u00c1\3\u00c1\3\u00c1\3\u00c1\3\u00c1")
        buf.write("\3\u00c1\3\u00c1\5\u00c1\u0945\n\u00c1\3\u00c2\3\u00c2")
        buf.write("\3\u00c3\3\u00c3\3\u00c3\3\u00c3\5\u00c3\u094d\n\u00c3")
        buf.write("\3\u00c4\3\u00c4\7\u00c4\u0951\n\u00c4\f\u00c4\16\u00c4")
        buf.write("\u0954\13\u00c4\3\u00c4\3\u00c4\3\u00c5\3\u00c5\7\u00c5")
        buf.write("\u095a\n\u00c5\f\u00c5\16\u00c5\u095d\13\u00c5\3\u00c5")
        buf.write("\3\u00c5\3\u00c6\3\u00c6\3\u00c6\3\u00c6\5\u00c6\u0965")
        buf.write("\n\u00c6\3\u00c7\3\u00c7\3\u00c7\3\u00c7\5\u00c7\u096b")
        buf.write("\n\u00c7\3\u00c8\3\u00c8\3\u00c8\7\u00c8\u0970\n\u00c8")
        buf.write("\f\u00c8\16\u00c8\u0973\13\u00c8\3\u00c8\3\u00c8\6\u00c8")
        buf.write("\u0977\n\u00c8\r\u00c8\16\u00c8\u0978\5\u00c8\u097b\n")
        buf.write("\u00c8\3\u00c9\3\u00c9\3\u00ca\3\u00ca\3\u00ca\5\u00ca")
        buf.write("\u0982\n\u00ca\3\u00ca\5\u00ca\u0985\n\u00ca\3\u00ca\5")
        buf.write("\u00ca\u0988\n\u00ca\3\u00ca\3\u00ca\5\u00ca\u098c\n\u00ca")
        buf.write("\3\u00cb\5\u00cb\u098f\n\u00cb\3\u00cb\3\u00cb\3\u00cb")
        buf.write("\5\u00cb\u0994\n\u00cb\3\u00cb\5\u00cb\u0997\n\u00cb\3")
        buf.write("\u00cb\5\u00cb\u099a\n\u00cb\3\u00cb\3\u00cb\5\u00cb\u099e")
        buf.write("\n\u00cb\3\u00cc\3\u00cc\3\u00cc\5\u00cc\u09a3\n\u00cc")
        buf.write("\3\u00cc\5\u00cc\u09a6\n\u00cc\3\u00cc\5\u00cc\u09a9\n")
        buf.write("\u00cc\3\u00cc\3\u00cc\5\u00cc\u09ad\n\u00cc\3\u00cd\3")
        buf.write("\u00cd\3\u00cd\5\u00cd\u09b2\n\u00cd\3\u00cd\3\u00cd\5")
        buf.write("\u00cd\u09b6\n\u00cd\3\u00ce\3\u00ce\3\u00ce\3\u00ce\5")
        buf.write("\u00ce\u09bc\n\u00ce\3\u00ce\3\u00ce\5\u00ce\u09c0\n\u00ce")
        buf.write("\3\u00ce\3\u00ce\5\u00ce\u09c4\n\u00ce\3\u00ce\3\u00ce")
        buf.write("\3\u00cf\3\u00cf\3\u00cf\3\u00cf\3\u00cf\3\u00cf\3\u00cf")
        buf.write("\3\u00cf\3\u00cf\3\u00cf\5\u00cf\u09d2\n\u00cf\3\u00d0")
        buf.write("\3\u00d0\3\u00d0\3\u00d1\3\u00d1\3\u00d1\3\u00d1\3\u00d1")
        buf.write("\3\u00d1\3\u00d1\3\u00d1\5\u00d1\u09df\n\u00d1\3\u00d1")
        buf.write("\3\u00d1\3\u00d1\3\u00d1\5\u00d1\u09e5\n\u00d1\3\u00d2")
        buf.write("\3\u00d2\3\u00d2\3\u00d2\3\u00d2\3\u00d3\3\u00d3\3\u00d3")
        buf.write("\3\u00d3\3\u00d3\3\u00d3\3\u00d3\3\u00d3\3\u00d3\3\u00d3")
        buf.write("\3\u00d3\3\u00d3\5\u00d3\u09f8\n\u00d3\3\u00d4\3\u00d4")
        buf.write("\3\u00d4\3\u00d4\3\u00d4\3\u00d4\3\u00d5\3\u00d5\3\u00d5")
        buf.write("\5\u00d5\u0a03\n\u00d5\3\u00d5\3\u00d5\5\u00d5\u0a07\n")
        buf.write("\u00d5\3\u00d5\3\u00d5\3\u00d6\3\u00d6\5\u00d6\u0a0d\n")
        buf.write("\u00d6\3\u00d6\3\u00d6\5\u00d6\u0a11\n\u00d6\3\u00d6\3")
        buf.write("\u00d6\5\u00d6\u0a15\n\u00d6\3\u00d6\3\u00d6\3\u00d6\3")
        buf.write("\u00d6\3\u00d6\5\u00d6\u0a1c\n\u00d6\3\u00d7\3\u00d7\3")
        buf.write("\u00d7\3\u00d7\3\u00d7\5\u00d7\u0a23\n\u00d7\3\u00d7\5")
        buf.write("\u00d7\u0a26\n\u00d7\3\u00d7\3\u00d7\7\u00d7\u0a2a\n\u00d7")
        buf.write("\f\u00d7\16\u00d7\u0a2d\13\u00d7\3\u00d8\3\u00d8\3\u00d8")
        buf.write("\3\u00d8\5\u00d8\u0a33\n\u00d8\3\u00d8\3\u00d8\3\u00d8")
        buf.write("\5\u00d8\u0a38\n\u00d8\3\u00d8\5\u00d8\u0a3b\n\u00d8\3")
        buf.write("\u00d8\3\u00d8\3\u00d8\3\u00d8\3\u00d8\3\u00d8\5\u00d8")
        buf.write("\u0a43\n\u00d8\3\u00d9\3\u00d9\3\u00d9\3\u00d9\5\u00d9")
        buf.write("\u0a49\n\u00d9\3\u00da\3\u00da\5\u00da\u0a4d\n\u00da\3")
        buf.write("\u00da\3\u00da\3\u00db\3\u00db\5\u00db\u0a53\n\u00db\3")
        buf.write("\u00db\3\u00db\5\u00db\u0a57\n\u00db\3\u00dc\3\u00dc\3")
        buf.write("\u00dc\2\2\u00dd\2\4\6\b\n\f\16\20\22\24\26\30\32\34\36")
        buf.write(" \"$&(*,.\60\62\64\668:<>@BDFHJLNPRTVXZ\\^`bdfhjlnprt")
        buf.write("vxz|~\u0080\u0082\u0084\u0086\u0088\u008a\u008c\u008e")
        buf.write("\u0090\u0092\u0094\u0096\u0098\u009a\u009c\u009e\u00a0")
        buf.write("\u00a2\u00a4\u00a6\u00a8\u00aa\u00ac\u00ae\u00b0\u00b2")
        buf.write("\u00b4\u00b6\u00b8\u00ba\u00bc\u00be\u00c0\u00c2\u00c4")
        buf.write("\u00c6\u00c8\u00ca\u00cc\u00ce\u00d0\u00d2\u00d4\u00d6")
        buf.write("\u00d8\u00da\u00dc\u00de\u00e0\u00e2\u00e4\u00e6\u00e8")
        buf.write("\u00ea\u00ec\u00ee\u00f0\u00f2\u00f4\u00f6\u00f8\u00fa")
        buf.write("\u00fc\u00fe\u0100\u0102\u0104\u0106\u0108\u010a\u010c")
        buf.write("\u010e\u0110\u0112\u0114\u0116\u0118\u011a\u011c\u011e")
        buf.write("\u0120\u0122\u0124\u0126\u0128\u012a\u012c\u012e\u0130")
        buf.write("\u0132\u0134\u0136\u0138\u013a\u013c\u013e\u0140\u0142")
        buf.write("\u0144\u0146\u0148\u014a\u014c\u014e\u0150\u0152\u0154")
        buf.write("\u0156\u0158\u015a\u015c\u015e\u0160\u0162\u0164\u0166")
        buf.write("\u0168\u016a\u016c\u016e\u0170\u0172\u0174\u0176\u0178")
        buf.write("\u017a\u017c\u017e\u0180\u0182\u0184\u0186\u0188\u018a")
        buf.write("\u018c\u018e\u0190\u0192\u0194\u0196\u0198\u019a\u019c")
        buf.write("\u019e\u01a0\u01a2\u01a4\u01a6\u01a8\u01aa\u01ac\u01ae")
        buf.write("\u01b0\u01b2\u01b4\u01b6\2\25\n\2\27\27\32\3299AAUUYY")
        buf.write("efjj\4\2$$//\5\288JJRR\3\2\u009e\u009f\4\2\u0094\u0095")
        buf.write("\u00a0\u00a1\3\2\u0089\u008a\3\2\u008b\u008d\20\2\24\24")
        buf.write("\27\27\32\32\37\37$$//99AAFFUUYY]]efjj\4\2\20\20\"\"\4")
        buf.write("\2\21\21ii\16\2\13\13\21\21++;;DDKKMQVV\\\\iimmoo\4\2")
        buf.write("**\67\67\4\2\23\23``\4\2\u008b\u008b\u0096\u0096\4\28")
        buf.write("8JJ\4\2,,bb\25\2\13\13\17\17\23\25\27!#$&\')\61\64\64")
        buf.write("\66;==@ACFHHJLNRTVYkmorr\3\2QR\26\2\f\16\20\22\26\26\"")
        buf.write("\"%%((\62\63\65\65<<>?BBGGIIMMSSWXhhllpqst\2\u0b68\2\u01b9")
        buf.write("\3\2\2\2\4\u01d1\3\2\2\2\6\u01dd\3\2\2\2\b\u01eb\3\2\2")
        buf.write("\2\n\u01ed\3\2\2\2\f\u01f7\3\2\2\2\16\u01fd\3\2\2\2\20")
        buf.write("\u0202\3\2\2\2\22\u0204\3\2\2\2\24\u0206\3\2\2\2\26\u020c")
        buf.write("\3\2\2\2\30\u020e\3\2\2\2\32\u0219\3\2\2\2\34\u0224\3")
        buf.write("\2\2\2\36\u0235\3\2\2\2 \u023a\3\2\2\2\"\u0244\3\2\2\2")
        buf.write("$\u0251\3\2\2\2&\u0253\3\2\2\2(\u025b\3\2\2\2*\u0263\3")
        buf.write("\2\2\2,\u026b\3\2\2\2.\u0273\3\2\2\2\60\u027b\3\2\2\2")
        buf.write("\62\u0283\3\2\2\2\64\u028b\3\2\2\2\66\u0293\3\2\2\28\u029f")
        buf.write("\3\2\2\2:\u02aa\3\2\2\2<\u02b2\3\2\2\2>\u02ba\3\2\2\2")
        buf.write("@\u02c6\3\2\2\2B\u02ce\3\2\2\2D\u02dd\3\2\2\2F\u02f5\3")
        buf.write("\2\2\2H\u02f7\3\2\2\2J\u02fc\3\2\2\2L\u039b\3\2\2\2N\u039f")
        buf.write("\3\2\2\2P\u03a1\3\2\2\2R\u03a5\3\2\2\2T\u03ad\3\2\2\2")
        buf.write("V\u03bd\3\2\2\2X\u03c1\3\2\2\2Z\u03c3\3\2\2\2\\\u03cd")
        buf.write("\3\2\2\2^\u03cf\3\2\2\2`\u03d8\3\2\2\2b\u03e5\3\2\2\2")
        buf.write("d\u03ec\3\2\2\2f\u03ee\3\2\2\2h\u0401\3\2\2\2j\u0403\3")
        buf.write("\2\2\2l\u040c\3\2\2\2n\u0419\3\2\2\2p\u041b\3\2\2\2r\u0430")
        buf.write("\3\2\2\2t\u0439\3\2\2\2v\u044a\3\2\2\2x\u0455\3\2\2\2")
        buf.write("z\u045a\3\2\2\2|\u046b\3\2\2\2~\u046d\3\2\2\2\u0080\u0476")
        buf.write("\3\2\2\2\u0082\u047b\3\2\2\2\u0084\u0485\3\2\2\2\u0086")
        buf.write("\u0487\3\2\2\2\u0088\u048a\3\2\2\2\u008a\u0495\3\2\2\2")
        buf.write("\u008c\u04a1\3\2\2\2\u008e\u04a3\3\2\2\2\u0090\u04a8\3")
        buf.write("\2\2\2\u0092\u04ab\3\2\2\2\u0094\u04ba\3\2\2\2\u0096\u04c3")
        buf.write("\3\2\2\2\u0098\u04ce\3\2\2\2\u009a\u04d0\3\2\2\2\u009c")
        buf.write("\u04d7\3\2\2\2\u009e\u04e0\3\2\2\2\u00a0\u04e2\3\2\2\2")
        buf.write("\u00a2\u04e6\3\2\2\2\u00a4\u04fb\3\2\2\2\u00a6\u0502\3")
        buf.write("\2\2\2\u00a8\u0504\3\2\2\2\u00aa\u050a\3\2\2\2\u00ac\u058e")
        buf.write("\3\2\2\2\u00ae\u0590\3\2\2\2\u00b0\u05ab\3\2\2\2\u00b2")
        buf.write("\u05af\3\2\2\2\u00b4\u05b1\3\2\2\2\u00b6\u05bc\3\2\2\2")
        buf.write("\u00b8\u05be\3\2\2\2\u00ba\u05c4\3\2\2\2\u00bc\u05c7\3")
        buf.write("\2\2\2\u00be\u05d6\3\2\2\2\u00c0\u05d8\3\2\2\2\u00c2\u05dc")
        buf.write("\3\2\2\2\u00c4\u05e9\3\2\2\2\u00c6\u05eb\3\2\2\2\u00c8")
        buf.write("\u05fe\3\2\2\2\u00ca\u0600\3\2\2\2\u00cc\u060c\3\2\2\2")
        buf.write("\u00ce\u0612\3\2\2\2\u00d0\u0617\3\2\2\2\u00d2\u061c\3")
        buf.write("\2\2\2\u00d4\u061e\3\2\2\2\u00d6\u0624\3\2\2\2\u00d8\u062c")
        buf.write("\3\2\2\2\u00da\u0639\3\2\2\2\u00dc\u063d\3\2\2\2\u00de")
        buf.write("\u0643\3\2\2\2\u00e0\u0656\3\2\2\2\u00e2\u0659\3\2\2\2")
        buf.write("\u00e4\u065f\3\2\2\2\u00e6\u0662\3\2\2\2\u00e8\u066e\3")
        buf.write("\2\2\2\u00ea\u0674\3\2\2\2\u00ec\u0680\3\2\2\2\u00ee\u0684")
        buf.write("\3\2\2\2\u00f0\u068d\3\2\2\2\u00f2\u0696\3\2\2\2\u00f4")
        buf.write("\u069a\3\2\2\2\u00f6\u06a9\3\2\2\2\u00f8\u06b2\3\2\2\2")
        buf.write("\u00fa\u06b4\3\2\2\2\u00fc\u06bc\3\2\2\2\u00fe\u06c0\3")
        buf.write("\2\2\2\u0100\u06c7\3\2\2\2\u0102\u06cc\3\2\2\2\u0104\u06d6")
        buf.write("\3\2\2\2\u0106\u06da\3\2\2\2\u0108\u06ef\3\2\2\2\u010a")
        buf.write("\u06f6\3\2\2\2\u010c\u0704\3\2\2\2\u010e\u070c\3\2\2\2")
        buf.write("\u0110\u0710\3\2\2\2\u0112\u0718\3\2\2\2\u0114\u071f\3")
        buf.write("\2\2\2\u0116\u0723\3\2\2\2\u0118\u0725\3\2\2\2\u011a\u0729")
        buf.write("\3\2\2\2\u011c\u0731\3\2\2\2\u011e\u0733\3\2\2\2\u0120")
        buf.write("\u0743\3\2\2\2\u0122\u074d\3\2\2\2\u0124\u0750\3\2\2\2")
        buf.write("\u0126\u0757\3\2\2\2\u0128\u0769\3\2\2\2\u012a\u0772\3")
        buf.write("\2\2\2\u012c\u0781\3\2\2\2\u012e\u0785\3\2\2\2\u0130\u0788")
        buf.write("\3\2\2\2\u0132\u0795\3\2\2\2\u0134\u079b\3\2\2\2\u0136")
        buf.write("\u07b6\3\2\2\2\u0138\u07b8\3\2\2\2\u013a\u07bf\3\2\2\2")
        buf.write("\u013c\u07c9\3\2\2\2\u013e\u07cb\3\2\2\2\u0140\u07ce\3")
        buf.write("\2\2\2\u0142\u07d8\3\2\2\2\u0144\u07e9\3\2\2\2\u0146\u07f5")
        buf.write("\3\2\2\2\u0148\u07fe\3\2\2\2\u014a\u080e\3\2\2\2\u014c")
        buf.write("\u081a\3\2\2\2\u014e\u0821\3\2\2\2\u0150\u0823\3\2\2\2")
        buf.write("\u0152\u0826\3\2\2\2\u0154\u0830\3\2\2\2\u0156\u0877\3")
        buf.write("\2\2\2\u0158\u088d\3\2\2\2\u015a\u0890\3\2\2\2\u015c\u08a1")
        buf.write("\3\2\2\2\u015e\u08a8\3\2\2\2\u0160\u08b3\3\2\2\2\u0162")
        buf.write("\u08b6\3\2\2\2\u0164\u08ba\3\2\2\2\u0166\u08c8\3\2\2\2")
        buf.write("\u0168\u08ca\3\2\2\2\u016a\u08d2\3\2\2\2\u016c\u08e4\3")
        buf.write("\2\2\2\u016e\u08f7\3\2\2\2\u0170\u08f9\3\2\2\2\u0172\u0901")
        buf.write("\3\2\2\2\u0174\u090a\3\2\2\2\u0176\u090c\3\2\2\2\u0178")
        buf.write("\u092e\3\2\2\2\u017a\u0930\3\2\2\2\u017c\u0934\3\2\2\2")
        buf.write("\u017e\u0938\3\2\2\2\u0180\u0944\3\2\2\2\u0182\u0946\3")
        buf.write("\2\2\2\u0184\u094c\3\2\2\2\u0186\u094e\3\2\2\2\u0188\u0957")
        buf.write("\3\2\2\2\u018a\u0964\3\2\2\2\u018c\u096a\3\2\2\2\u018e")
        buf.write("\u096c\3\2\2\2\u0190\u097c\3\2\2\2\u0192\u097e\3\2\2\2")
        buf.write("\u0194\u098e\3\2\2\2\u0196\u099f\3\2\2\2\u0198\u09ae\3")
        buf.write("\2\2\2\u019a\u09b7\3\2\2\2\u019c\u09c7\3\2\2\2\u019e\u09d3")
        buf.write("\3\2\2\2\u01a0\u09d6\3\2\2\2\u01a2\u09e6\3\2\2\2\u01a4")
        buf.write("\u09eb\3\2\2\2\u01a6\u09f9\3\2\2\2\u01a8\u09ff\3\2\2\2")
        buf.write("\u01aa\u0a0a\3\2\2\2\u01ac\u0a22\3\2\2\2\u01ae\u0a2e\3")
        buf.write("\2\2\2\u01b0\u0a44\3\2\2\2\u01b2\u0a4a\3\2\2\2\u01b4\u0a50")
        buf.write("\3\2\2\2\u01b6\u0a58\3\2\2\2\u01b8\u01ba\7\3\2\2\u01b9")
        buf.write("\u01b8\3\2\2\2\u01b9\u01ba\3\2\2\2\u01ba\u01bc\3\2\2\2")
        buf.write("\u01bb\u01bd\5\u00dan\2\u01bc\u01bb\3\2\2\2\u01bc\u01bd")
        buf.write("\3\2\2\2\u01bd\u01bf\3\2\2\2\u01be\u01c0\5\u00dep\2\u01bf")
        buf.write("\u01be\3\2\2\2\u01bf\u01c0\3\2\2\2\u01c0\u01c4\3\2\2\2")
        buf.write("\u01c1\u01c3\5\u015e\u00b0\2\u01c2\u01c1\3\2\2\2\u01c3")
        buf.write("\u01c6\3\2\2\2\u01c4\u01c2\3\2\2\2\u01c4\u01c5\3\2\2\2")
        buf.write("\u01c5\u01c8\3\2\2\2\u01c6\u01c4\3\2\2\2\u01c7\u01c9\5")
        buf.write("\u00e2r\2\u01c8\u01c7\3\2\2\2\u01c8\u01c9\3\2\2\2\u01c9")
        buf.write("\u01ca\3\2\2\2\u01ca\u01cb\7\2\2\3\u01cb\3\3\2\2\2\u01cc")
        buf.write("\u01ce\5\u01b6\u00dc\2\u01cd\u01cf\5\30\r\2\u01ce\u01cd")
        buf.write("\3\2\2\2\u01ce\u01cf\3\2\2\2\u01cf\u01d2\3\2\2\2\u01d0")
        buf.write("\u01d2\5\u00e8u\2\u01d1\u01cc\3\2\2\2\u01d1\u01d0\3\2")
        buf.write("\2\2\u01d2\u01da\3\2\2\2\u01d3\u01d4\7\u0085\2\2\u01d4")
        buf.write("\u01d6\5\u01b6\u00dc\2\u01d5\u01d7\5\30\r\2\u01d6\u01d5")
        buf.write("\3\2\2\2\u01d6\u01d7\3\2\2\2\u01d7\u01d9\3\2\2\2\u01d8")
        buf.write("\u01d3\3\2\2\2\u01d9\u01dc\3\2\2\2\u01da\u01d8\3\2\2\2")
        buf.write("\u01da\u01db\3\2\2\2\u01db\5\3\2\2\2\u01dc\u01da\3\2\2")
        buf.write("\2\u01dd\u01e3\5\b\5\2\u01de\u01e2\7\u0096\2\2\u01df\u01e2")
        buf.write("\5\u0146\u00a4\2\u01e0\u01e2\7\u008b\2\2\u01e1\u01de\3")
        buf.write("\2\2\2\u01e1\u01df\3\2\2\2\u01e1\u01e0\3\2\2\2\u01e2\u01e5")
        buf.write("\3\2\2\2\u01e3\u01e1\3\2\2\2\u01e3\u01e4\3\2\2\2\u01e4")
        buf.write("\7\3\2\2\2\u01e5\u01e3\3\2\2\2\u01e6\u01ec\5\16\b\2\u01e7")
        buf.write("\u01ec\5\26\f\2\u01e8\u01e9\7n\2\2\u01e9\u01ec\7\u008b")
        buf.write("\2\2\u01ea\u01ec\5\n\6\2\u01eb\u01e6\3\2\2\2\u01eb\u01e7")
        buf.write("\3\2\2\2\u01eb\u01e8\3\2\2\2\u01eb\u01ea\3\2\2\2\u01ec")
        buf.write("\t\3\2\2\2\u01ed\u01ee\7\u0083\2\2\u01ee\u01f1\5\f\7\2")
        buf.write("\u01ef\u01f0\7\u0086\2\2\u01f0\u01f2\5\f\7\2\u01f1\u01ef")
        buf.write("\3\2\2\2\u01f2\u01f3\3\2\2\2\u01f3\u01f1\3\2\2\2\u01f3")
        buf.write("\u01f4\3\2\2\2\u01f4\u01f5\3\2\2\2\u01f5\u01f6\7\u0084")
        buf.write("\2\2\u01f6\13\3\2\2\2\u01f7\u01f9\5\6\4\2\u01f8\u01fa")
        buf.write("\5\u01b6\u00dc\2\u01f9\u01f8\3\2\2\2\u01f9\u01fa\3\2\2")
        buf.write("\2\u01fa\r\3\2\2\2\u01fb\u01fe\5\20\t\2\u01fc\u01fe\7")
        buf.write("\24\2\2\u01fd\u01fb\3\2\2\2\u01fd\u01fc\3\2\2\2\u01fe")
        buf.write("\17\3\2\2\2\u01ff\u0203\5\22\n\2\u0200\u0203\5\24\13\2")
        buf.write("\u0201\u0203\7\37\2\2\u0202\u01ff\3\2\2\2\u0202\u0200")
        buf.write("\3\2\2\2\u0202\u0201\3\2\2\2\u0203\21\3\2\2\2\u0204\u0205")
        buf.write("\t\2\2\2\u0205\23\3\2\2\2\u0206\u0207\t\3\2\2\u0207\25")
        buf.write("\3\2\2\2\u0208\u020d\5\4\3\2\u0209\u020d\7F\2\2\u020a")
        buf.write("\u020d\7%\2\2\u020b\u020d\7]\2\2\u020c\u0208\3\2\2\2\u020c")
        buf.write("\u0209\3\2\2\2\u020c\u020a\3\2\2\2\u020c\u020b\3\2\2\2")
        buf.write("\u020d\27\3\2\2\2\u020e\u020f\7\u0094\2\2\u020f\u0214")
        buf.write("\5\6\4\2\u0210\u0211\7\u0086\2\2\u0211\u0213\5\6\4\2\u0212")
        buf.write("\u0210\3\2\2\2\u0213\u0216\3\2\2\2\u0214\u0212\3\2\2\2")
        buf.write("\u0214\u0215\3\2\2\2\u0215\u0217\3\2\2\2\u0216\u0214\3")
        buf.write("\2\2\2\u0217\u0218\7\u0095\2\2\u0218\31\3\2\2\2\u0219")
        buf.write("\u021e\5\34\17\2\u021a\u021b\7\u0086\2\2\u021b\u021d\5")
        buf.write("\34\17\2\u021c\u021a\3\2\2\2\u021d\u0220\3\2\2\2\u021e")
        buf.write("\u021c\3\2\2\2\u021e\u021f\3\2\2\2\u021f\33\3\2\2\2\u0220")
        buf.write("\u021e\3\2\2\2\u0221\u0222\5\u01b6\u00dc\2\u0222\u0223")
        buf.write("\7\u0087\2\2\u0223\u0225\3\2\2\2\u0224\u0221\3\2\2\2\u0224")
        buf.write("\u0225\3\2\2\2\u0225\u0227\3\2\2\2\u0226\u0228\t\4\2\2")
        buf.write("\u0227\u0226\3\2\2\2\u0227\u0228\3\2\2\2\u0228\u022f\3")
        buf.write("\2\2\2\u0229\u0230\5\36\20\2\u022a\u022d\7l\2\2\u022b")
        buf.write("\u022d\5\6\4\2\u022c\u022a\3\2\2\2\u022c\u022b\3\2\2\2")
        buf.write("\u022d\u022e\3\2\2\2\u022e\u0230\5\36\20\2\u022f\u0229")
        buf.write("\3\2\2\2\u022f\u022c\3\2\2\2\u0230\35\3\2\2\2\u0231\u0236")
        buf.write("\5\"\22\2\u0232\u0236\5 \21\2\u0233\u0234\7R\2\2\u0234")
        buf.write("\u0236\5 \21\2\u0235\u0231\3\2\2\2\u0235\u0232\3\2\2\2")
        buf.write("\u0235\u0233\3\2\2\2\u0236\37\3\2\2\2\u0237\u023b\5z>")
        buf.write("\2\u0238\u023b\5\u0086D\2\u0239\u023b\5&\24\2\u023a\u0237")
        buf.write("\3\2\2\2\u023a\u0238\3\2\2\2\u023a\u0239\3\2\2\2\u023b")
        buf.write("!\3\2\2\2\u023c\u023d\5F$\2\u023d\u023e\5$\23\2\u023e")
        buf.write("\u023f\5\36\20\2\u023f\u0245\3\2\2\2\u0240\u0241\5F$\2")
        buf.write("\u0241\u0242\7\u00ac\2\2\u0242\u0243\5N(\2\u0243\u0245")
        buf.write("\3\2\2\2\u0244\u023c\3\2\2\2\u0244\u0240\3\2\2\2\u0245")
        buf.write("#\3\2\2\2\u0246\u0252\7\u0093\2\2\u0247\u0252\7\u00a2")
        buf.write("\2\2\u0248\u0252\7\u00a3\2\2\u0249\u0252\7\u00a4\2\2\u024a")
        buf.write("\u0252\7\u00a5\2\2\u024b\u0252\7\u00a6\2\2\u024c\u0252")
        buf.write("\7\u00a7\2\2\u024d\u0252\7\u00a8\2\2\u024e\u0252\7\u00a9")
        buf.write("\2\2\u024f\u0252\7\u00ab\2\2\u0250\u0252\5\u017e\u00c0")
        buf.write("\2\u0251\u0246\3\2\2\2\u0251\u0247\3\2\2\2\u0251\u0248")
        buf.write("\3\2\2\2\u0251\u0249\3\2\2\2\u0251\u024a\3\2\2\2\u0251")
        buf.write("\u024b\3\2\2\2\u0251\u024c\3\2\2\2\u0251\u024d\3\2\2\2")
        buf.write("\u0251\u024e\3\2\2\2\u0251\u024f\3\2\2\2\u0251\u0250\3")
        buf.write("\2\2\2\u0252%\3\2\2\2\u0253\u0259\5(\25\2\u0254\u0255")
        buf.write("\7\u0096\2\2\u0255\u0256\5N(\2\u0256\u0257\7\u0087\2\2")
        buf.write("\u0257\u0258\5N(\2\u0258\u025a\3\2\2\2\u0259\u0254\3\2")
        buf.write("\2\2\u0259\u025a\3\2\2\2\u025a\'\3\2\2\2\u025b\u0261\5")
        buf.write("*\26\2\u025c\u025f\7\u0098\2\2\u025d\u0260\5(\25\2\u025e")
        buf.write("\u0260\5P)\2\u025f\u025d\3\2\2\2\u025f\u025e\3\2\2\2\u0260")
        buf.write("\u0262\3\2\2\2\u0261\u025c\3\2\2\2\u0261\u0262\3\2\2\2")
        buf.write("\u0262)\3\2\2\2\u0263\u0268\5,\27\2\u0264\u0265\7\u009c")
        buf.write("\2\2\u0265\u0267\5,\27\2\u0266\u0264\3\2\2\2\u0267\u026a")
        buf.write("\3\2\2\2\u0268\u0266\3\2\2\2\u0268\u0269\3\2\2\2\u0269")
        buf.write("+\3\2\2\2\u026a\u0268\3\2\2\2\u026b\u0270\5.\30\2\u026c")
        buf.write("\u026d\7\u009b\2\2\u026d\u026f\5.\30\2\u026e\u026c\3\2")
        buf.write("\2\2\u026f\u0272\3\2\2\2\u0270\u026e\3\2\2\2\u0270\u0271")
        buf.write("\3\2\2\2\u0271-\3\2\2\2\u0272\u0270\3\2\2\2\u0273\u0278")
        buf.write("\5\60\31\2\u0274\u0275\7\u008f\2\2\u0275\u0277\5\60\31")
        buf.write("\2\u0276\u0274\3\2\2\2\u0277\u027a\3\2\2\2\u0278\u0276")
        buf.write("\3\2\2\2\u0278\u0279\3\2\2\2\u0279/\3\2\2\2\u027a\u0278")
        buf.write("\3\2\2\2\u027b\u0280\5\62\32\2\u027c\u027d\7\u0090\2\2")
        buf.write("\u027d\u027f\5\62\32\2\u027e\u027c\3\2\2\2\u027f\u0282")
        buf.write("\3\2\2\2\u0280\u027e\3\2\2\2\u0280\u0281\3\2\2\2\u0281")
        buf.write("\61\3\2\2\2\u0282\u0280\3\2\2\2\u0283\u0288\5\64\33\2")
        buf.write("\u0284\u0285\7\u008e\2\2\u0285\u0287\5\64\33\2\u0286\u0284")
        buf.write("\3\2\2\2\u0287\u028a\3\2\2\2\u0288\u0286\3\2\2\2\u0288")
        buf.write("\u0289\3\2\2\2\u0289\63\3\2\2\2\u028a\u0288\3\2\2\2\u028b")
        buf.write("\u0290\5\66\34\2\u028c\u028d\t\5\2\2\u028d\u028f\5\66")
        buf.write("\34\2\u028e\u028c\3\2\2\2\u028f\u0292\3\2\2\2\u0290\u028e")
        buf.write("\3\2\2\2\u0290\u0291\3\2\2\2\u0291\65\3\2\2\2\u0292\u0290")
        buf.write("\3\2\2\2\u0293\u029c\58\35\2\u0294\u0295\t\6\2\2\u0295")
        buf.write("\u029b\58\35\2\u0296\u0297\7=\2\2\u0297\u029b\5t;\2\u0298")
        buf.write("\u0299\7\17\2\2\u0299\u029b\5\6\4\2\u029a\u0294\3\2\2")
        buf.write("\2\u029a\u0296\3\2\2\2\u029a\u0298\3\2\2\2\u029b\u029e")
        buf.write("\3\2\2\2\u029c\u029a\3\2\2\2\u029c\u029d\3\2\2\2\u029d")
        buf.write("\67\3\2\2\2\u029e\u029c\3\2\2\2\u029f\u02a7\5:\36\2\u02a0")
        buf.write("\u02a3\7\u00aa\2\2\u02a1\u02a3\5\u017c\u00bf\2\u02a2\u02a0")
        buf.write("\3\2\2\2\u02a2\u02a1\3\2\2\2\u02a3\u02a4\3\2\2\2\u02a4")
        buf.write("\u02a6\5:\36\2\u02a5\u02a2\3\2\2\2\u02a6\u02a9\3\2\2\2")
        buf.write("\u02a7\u02a5\3\2\2\2\u02a7\u02a8\3\2\2\2\u02a89\3\2\2")
        buf.write("\2\u02a9\u02a7\3\2\2\2\u02aa\u02af\5<\37\2\u02ab\u02ac")
        buf.write("\t\7\2\2\u02ac\u02ae\5<\37\2\u02ad\u02ab\3\2\2\2\u02ae")
        buf.write("\u02b1\3\2\2\2\u02af\u02ad\3\2\2\2\u02af\u02b0\3\2\2\2")
        buf.write("\u02b0;\3\2\2\2\u02b1\u02af\3\2\2\2\u02b2\u02b7\5> \2")
        buf.write("\u02b3\u02b4\t\b\2\2\u02b4\u02b6\5> \2\u02b5\u02b3\3\2")
        buf.write("\2\2\u02b6\u02b9\3\2\2\2\u02b7\u02b5\3\2\2\2\u02b7\u02b8")
        buf.write("\3\2\2\2\u02b8=\3\2\2\2\u02b9\u02b7\3\2\2\2\u02ba\u02c4")
        buf.write("\5D#\2\u02bb\u02bc\7_\2\2\u02bc\u02c1\7\177\2\2\u02bd")
        buf.write("\u02bf\5@!\2\u02be\u02c0\7\u0086\2\2\u02bf\u02be\3\2\2")
        buf.write("\2\u02bf\u02c0\3\2\2\2\u02c0\u02c2\3\2\2\2\u02c1\u02bd")
        buf.write("\3\2\2\2\u02c1\u02c2\3\2\2\2\u02c2\u02c3\3\2\2\2\u02c3")
        buf.write("\u02c5\7\u0080\2\2\u02c4\u02bb\3\2\2\2\u02c4\u02c5\3\2")
        buf.write("\2\2\u02c5?\3\2\2\2\u02c6\u02cb\5B\"\2\u02c7\u02c8\7\u0086")
        buf.write("\2\2\u02c8\u02ca\5B\"\2\u02c9\u02c7\3\2\2\2\u02ca\u02cd")
        buf.write("\3\2\2\2\u02cb\u02c9\3\2\2\2\u02cb\u02cc\3\2\2\2\u02cc")
        buf.write("A\3\2\2\2\u02cd\u02cb\3\2\2\2\u02ce\u02d0\5\36\20\2\u02cf")
        buf.write("\u02d1\5\u00c0a\2\u02d0\u02cf\3\2\2\2\u02d0\u02d1\3\2")
        buf.write("\2\2\u02d1\u02d2\3\2\2\2\u02d2\u02d3\5\u017a\u00be\2\u02d3")
        buf.write("\u02d4\5N(\2\u02d4C\3\2\2\2\u02d5\u02de\5F$\2\u02d6\u02d8")
        buf.write("\5F$\2\u02d7\u02d6\3\2\2\2\u02d7\u02d8\3\2\2\2\u02d8\u02d9")
        buf.write("\3\2\2\2\u02d9\u02db\7\u00ad\2\2\u02da\u02dc\5F$\2\u02db")
        buf.write("\u02da\3\2\2\2\u02db\u02dc\3\2\2\2\u02dc\u02de\3\2\2\2")
        buf.write("\u02dd\u02d5\3\2\2\2\u02dd\u02d7\3\2\2\2\u02deE\3\2\2")
        buf.write("\2\u02df\u02f6\5H%\2\u02e0\u02f6\5J&\2\u02e1\u02e2\7\u0089")
        buf.write("\2\2\u02e2\u02f6\5F$\2\u02e3\u02e4\7\u008a\2\2\u02e4\u02f6")
        buf.write("\5F$\2\u02e5\u02e6\7\u0091\2\2\u02e6\u02f6\5F$\2\u02e7")
        buf.write("\u02e8\7\u0092\2\2\u02e8\u02f6\5F$\2\u02e9\u02ea\7\u0099")
        buf.write("\2\2\u02ea\u02f6\5F$\2\u02eb\u02ec\7\u009a\2\2\u02ec\u02f6")
        buf.write("\5F$\2\u02ed\u02ee\7\22\2\2\u02ee\u02f6\5F$\2\u02ef\u02f0")
        buf.write("\7\u008e\2\2\u02f0\u02f6\5F$\2\u02f1\u02f2\7\u008b\2\2")
        buf.write("\u02f2\u02f6\5F$\2\u02f3\u02f4\7\u0090\2\2\u02f4\u02f6")
        buf.write("\5F$\2\u02f5\u02df\3\2\2\2\u02f5\u02e0\3\2\2\2\u02f5\u02e1")
        buf.write("\3\2\2\2\u02f5\u02e3\3\2\2\2\u02f5\u02e5\3\2\2\2\u02f5")
        buf.write("\u02e7\3\2\2\2\u02f5\u02e9\3\2\2\2\u02f5\u02eb\3\2\2\2")
        buf.write("\u02f5\u02ed\3\2\2\2\u02f5\u02ef\3\2\2\2\u02f5\u02f1\3")
        buf.write("\2\2\2\u02f5\u02f3\3\2\2\2\u02f6G\3\2\2\2\u02f7\u02f8")
        buf.write("\7\u0083\2\2\u02f8\u02f9\5\6\4\2\u02f9\u02fa\7\u0084\2")
        buf.write("\2\u02fa\u02fb\5F$\2\u02fbI\3\2\2\2\u02fc\u02fe\5L\'\2")
        buf.write("\u02fd\u02ff\7\u0091\2\2\u02fe\u02fd\3\2\2\2\u02fe\u02ff")
        buf.write("\3\2\2\2\u02ff\u0303\3\2\2\2\u0300\u0302\5T+\2\u0301\u0300")
        buf.write("\3\2\2\2\u0302\u0305\3\2\2\2\u0303\u0301\3\2\2\2\u0303")
        buf.write("\u0304\3\2\2\2\u0304\u0307\3\2\2\2\u0305\u0303\3\2\2\2")
        buf.write("\u0306\u0308\7\u0091\2\2\u0307\u0306\3\2\2\2\u0307\u0308")
        buf.write("\3\2\2\2\u0308\u031f\3\2\2\2\u0309\u0310\5R*\2\u030a\u0310")
        buf.write("\5\u01b2\u00da\2\u030b\u0310\7\u0099\2\2\u030c\u0310\7")
        buf.write("\u009a\2\2\u030d\u030e\7\u009d\2\2\u030e\u0310\5\u01b6")
        buf.write("\u00dc\2\u030f\u0309\3\2\2\2\u030f\u030a\3\2\2\2\u030f")
        buf.write("\u030b\3\2\2\2\u030f\u030c\3\2\2\2\u030f\u030d\3\2\2\2")
        buf.write("\u0310\u0312\3\2\2\2\u0311\u0313\7\u0091\2\2\u0312\u0311")
        buf.write("\3\2\2\2\u0312\u0313\3\2\2\2\u0313\u0317\3\2\2\2\u0314")
        buf.write("\u0316\5T+\2\u0315\u0314\3\2\2\2\u0316\u0319\3\2\2\2\u0317")
        buf.write("\u0315\3\2\2\2\u0317\u0318\3\2\2\2\u0318\u031b\3\2\2\2")
        buf.write("\u0319\u0317\3\2\2\2\u031a\u031c\7\u0091\2\2\u031b\u031a")
        buf.write("\3\2\2\2\u031b\u031c\3\2\2\2\u031c\u031e\3\2\2\2\u031d")
        buf.write("\u030f\3\2\2\2\u031e\u0321\3\2\2\2\u031f\u031d\3\2\2\2")
        buf.write("\u031f\u0320\3\2\2\2\u0320K\3\2\2\2\u0321\u031f\3\2\2")
        buf.write("\2\u0322\u039c\5\u0180\u00c1\2\u0323\u0325\5\u01b6\u00dc")
        buf.write("\2\u0324\u0326\5\30\r\2\u0325\u0324\3\2\2\2\u0325\u0326")
        buf.write("\3\2\2\2\u0326\u039c\3\2\2\2\u0327\u0328\7\u0083\2\2\u0328")
        buf.write("\u0329\5\36\20\2\u0329\u032a\7\u0084\2\2\u032a\u039c\3")
        buf.write("\2\2\2\u032b\u039c\5X-\2\u032c\u039c\5\u00e8u\2\u032d")
        buf.write("\u039c\7u\2\2\u032e\u039c\7`\2\2\u032f\u0339\7\23\2\2")
        buf.write("\u0330\u0331\7\u0085\2\2\u0331\u0333\5\u01b6\u00dc\2\u0332")
        buf.write("\u0334\5\30\r\2\u0333\u0332\3\2\2\2\u0333\u0334\3\2\2")
        buf.write("\2\u0334\u033a\3\2\2\2\u0335\u0336\7\u0081\2\2\u0336\u0337")
        buf.write("\5Z.\2\u0337\u0338\7\u0082\2\2\u0338\u033a\3\2\2\2\u0339")
        buf.write("\u0330\3\2\2\2\u0339\u0335\3\2\2\2\u033a\u039c\3\2\2\2")
        buf.write("\u033b\u0358\7D\2\2\u033c\u0352\5\6\4\2\u033d\u0353\5")
        buf.write("\u01b4\u00db\2\u033e\u0353\5\\/\2\u033f\u0340\7\u0081")
        buf.write("\2\2\u0340\u0341\5Z.\2\u0341\u0345\7\u0082\2\2\u0342\u0344")
        buf.write("\5\u0146\u00a4\2\u0343\u0342\3\2\2\2\u0344\u0347\3\2\2")
        buf.write("\2\u0345\u0343\3\2\2\2\u0345\u0346\3\2\2\2\u0346\u0349")
        buf.write("\3\2\2\2\u0347\u0345\3\2\2\2\u0348\u034a\5\u0148\u00a5")
        buf.write("\2\u0349\u0348\3\2\2\2\u0349\u034a\3\2\2\2\u034a\u0353")
        buf.write("\3\2\2\2\u034b\u034d\5\u0146\u00a4\2\u034c\u034b\3\2\2")
        buf.write("\2\u034d\u034e\3\2\2\2\u034e\u034c\3\2\2\2\u034e\u034f")
        buf.write("\3\2\2\2\u034f\u0350\3\2\2\2\u0350\u0351\5\u0148\u00a5")
        buf.write("\2\u0351\u0353\3\2\2\2\u0352\u033d\3\2\2\2\u0352\u033e")
        buf.write("\3\2\2\2\u0352\u033f\3\2\2\2\u0352\u034c\3\2\2\2\u0353")
        buf.write("\u0359\3\2\2\2\u0354\u0359\5j\66\2\u0355\u0356\5\u0146")
        buf.write("\u00a4\2\u0356\u0357\5\u0148\u00a5\2\u0357\u0359\3\2\2")
        buf.write("\2\u0358\u033c\3\2\2\2\u0358\u0354\3\2\2\2\u0358\u0355")
        buf.write("\3\2\2\2\u0359\u039c\3\2\2\2\u035a\u035b\7\u0083\2\2\u035b")
        buf.write("\u035e\5\34\17\2\u035c\u035d\7\u0086\2\2\u035d\u035f\5")
        buf.write("\34\17\2\u035e\u035c\3\2\2\2\u035f\u0360\3\2\2\2\u0360")
        buf.write("\u035e\3\2\2\2\u0360\u0361\3\2\2\2\u0361\u0362\3\2\2\2")
        buf.write("\u0362\u0363\7\u0084\2\2\u0363\u039c\3\2\2\2\u0364\u0365")
        buf.write("\7d\2\2\u0365\u0369\7\u0083\2\2\u0366\u036a\5p9\2\u0367")
        buf.write("\u036a\5\6\4\2\u0368\u036a\7n\2\2\u0369\u0366\3\2\2\2")
        buf.write("\u0369\u0367\3\2\2\2\u0369\u0368\3\2\2\2\u036a\u036b\3")
        buf.write("\2\2\2\u036b\u039c\7\u0084\2\2\u036c\u036d\7\33\2\2\u036d")
        buf.write("\u036e\7\u0083\2\2\u036e\u036f\5\36\20\2\u036f\u0370\7")
        buf.write("\u0084\2\2\u0370\u039c\3\2\2\2\u0371\u0372\7g\2\2\u0372")
        buf.write("\u0373\7\u0083\2\2\u0373\u0374\5\36\20\2\u0374\u0375\7")
        buf.write("\u0084\2\2\u0375\u039c\3\2\2\2\u0376\u037b\7 \2\2\u0377")
        buf.write("\u0378\7\u0083\2\2\u0378\u0379\5\6\4\2\u0379\u037a\7\u0084")
        buf.write("\2\2\u037a\u037c\3\2\2\2\u037b\u0377\3\2\2\2\u037b\u037c")
        buf.write("\3\2\2\2\u037c\u039c\3\2\2\2\u037d\u037f\7\21\2\2\u037e")
        buf.write("\u037d\3\2\2\2\u037e\u037f\3\2\2\2\u037f\u0380\3\2\2\2")
        buf.write("\u0380\u0386\7!\2\2\u0381\u0383\7\u0083\2\2\u0382\u0384")
        buf.write("\5~@\2\u0383\u0382\3\2\2\2\u0383\u0384\3\2\2\2\u0384\u0385")
        buf.write("\3\2\2\2\u0385\u0387\7\u0084\2\2\u0386\u0381\3\2\2\2\u0386")
        buf.write("\u0387\3\2\2\2\u0387\u0388\3\2\2\2\u0388\u039c\5\u00ae")
        buf.write("X\2\u0389\u038a\7Z\2\2\u038a\u038b\7\u0083\2\2\u038b\u038c")
        buf.write("\5\6\4\2\u038c\u038d\7\u0084\2\2\u038d\u039c\3\2\2\2\u038e")
        buf.write("\u038f\7B\2\2\u038f\u0395\7\u0083\2\2\u0390\u0391\5\u01b6")
        buf.write("\u00dc\2\u0391\u0392\7\u0085\2\2\u0392\u0394\3\2\2\2\u0393")
        buf.write("\u0390\3\2\2\2\u0394\u0397\3\2\2\2\u0395\u0393\3\2\2\2")
        buf.write("\u0395\u0396\3\2\2\2\u0396\u0398\3\2\2\2\u0397\u0395\3")
        buf.write("\2\2\2\u0398\u0399\5\u01b6\u00dc\2\u0399\u039a\7\u0084")
        buf.write("\2\2\u039a\u039c\3\2\2\2\u039b\u0322\3\2\2\2\u039b\u0323")
        buf.write("\3\2\2\2\u039b\u0327\3\2\2\2\u039b\u032b\3\2\2\2\u039b")
        buf.write("\u032c\3\2\2\2\u039b\u032d\3\2\2\2\u039b\u032e\3\2\2\2")
        buf.write("\u039b\u032f\3\2\2\2\u039b\u033b\3\2\2\2\u039b\u035a\3")
        buf.write("\2\2\2\u039b\u0364\3\2\2\2\u039b\u036c\3\2\2\2\u039b\u0371")
        buf.write("\3\2\2\2\u039b\u0376\3\2\2\2\u039b\u037e\3\2\2\2\u039b")
        buf.write("\u0389\3\2\2\2\u039b\u038e\3\2\2\2\u039cM\3\2\2\2\u039d")
        buf.write("\u03a0\5\36\20\2\u039e\u03a0\5P)\2\u039f\u039d\3\2\2\2")
        buf.write("\u039f\u039e\3\2\2\2\u03a0O\3\2\2\2\u03a1\u03a2\7a\2\2")
        buf.write("\u03a2\u03a3\5\36\20\2\u03a3Q\3\2\2\2\u03a4\u03a6\7\u0096")
        buf.write("\2\2\u03a5\u03a4\3\2\2\2\u03a5\u03a6\3\2\2\2\u03a6\u03a7")
        buf.write("\3\2\2\2\u03a7\u03a8\7\u0085\2\2\u03a8\u03aa\5\u01b6\u00dc")
        buf.write("\2\u03a9\u03ab\5\30\r\2\u03aa\u03a9\3\2\2\2\u03aa\u03ab")
        buf.write("\3\2\2\2\u03abS\3\2\2\2\u03ac\u03ae\7\u0096\2\2\u03ad")
        buf.write("\u03ac\3\2\2\2\u03ad\u03ae\3\2\2\2\u03ae\u03af\3\2\2\2")
        buf.write("\u03af\u03b0\7\u0081\2\2\u03b0\u03b5\5V,\2\u03b1\u03b2")
        buf.write("\7\u0086\2\2\u03b2\u03b4\5V,\2\u03b3\u03b1\3\2\2\2\u03b4")
        buf.write("\u03b7\3\2\2\2\u03b5\u03b3\3\2\2\2\u03b5\u03b6\3\2\2\2")
        buf.write("\u03b6\u03b8\3\2\2\2\u03b7\u03b5\3\2\2\2\u03b8\u03b9\7")
        buf.write("\u0082\2\2\u03b9U\3\2\2\2\u03ba\u03bb\5\u01b6\u00dc\2")
        buf.write("\u03bb\u03bc\7\u0087\2\2\u03bc\u03be\3\2\2\2\u03bd\u03ba")
        buf.write("\3\2\2\2\u03bd\u03be\3\2\2\2\u03be\u03bf\3\2\2\2\u03bf")
        buf.write("\u03c0\5\36\20\2\u03c0W\3\2\2\2\u03c1\u03c2\t\t\2\2\u03c2")
        buf.write("Y\3\2\2\2\u03c3\u03c8\5\36\20\2\u03c4\u03c5\7\u0086\2")
        buf.write("\2\u03c5\u03c7\5\36\20\2\u03c6\u03c4\3\2\2\2\u03c7\u03ca")
        buf.write("\3\2\2\2\u03c8\u03c6\3\2\2\2\u03c8\u03c9\3\2\2\2\u03c9")
        buf.write("[\3\2\2\2\u03ca\u03c8\3\2\2\2\u03cb\u03ce\5^\60\2\u03cc")
        buf.write("\u03ce\5f\64\2\u03cd\u03cb\3\2\2\2\u03cd\u03cc\3\2\2\2")
        buf.write("\u03ce]\3\2\2\2\u03cf\u03d4\7\177\2\2\u03d0\u03d2\5`\61")
        buf.write("\2\u03d1\u03d3\7\u0086\2\2\u03d2\u03d1\3\2\2\2\u03d2\u03d3")
        buf.write("\3\2\2\2\u03d3\u03d5\3\2\2\2\u03d4\u03d0\3\2\2\2\u03d4")
        buf.write("\u03d5\3\2\2\2\u03d5\u03d6\3\2\2\2\u03d6\u03d7\7\u0080")
        buf.write("\2\2\u03d7_\3\2\2\2\u03d8\u03dd\5b\62\2\u03d9\u03da\7")
        buf.write("\u0086\2\2\u03da\u03dc\5b\62\2\u03db\u03d9\3\2\2\2\u03dc")
        buf.write("\u03df\3\2\2\2\u03dd\u03db\3\2\2\2\u03dd\u03de\3\2\2\2")
        buf.write("\u03dea\3\2\2\2\u03df\u03dd\3\2\2\2\u03e0\u03e6\5\u01b6")
        buf.write("\u00dc\2\u03e1\u03e2\7\u0081\2\2\u03e2\u03e3\5\36\20\2")
        buf.write("\u03e3\u03e4\7\u0082\2\2\u03e4\u03e6\3\2\2\2\u03e5\u03e0")
        buf.write("\3\2\2\2\u03e5\u03e1\3\2\2\2\u03e6\u03e7\3\2\2\2\u03e7")
        buf.write("\u03e8\7\u0093\2\2\u03e8\u03e9\5d\63\2\u03e9c\3\2\2\2")
        buf.write("\u03ea\u03ed\5\36\20\2\u03eb\u03ed\5\\/\2\u03ec\u03ea")
        buf.write("\3\2\2\2\u03ec\u03eb\3\2\2\2\u03ede\3\2\2\2\u03ee\u03ef")
        buf.write("\7\177\2\2\u03ef\u03f4\5h\65\2\u03f0\u03f1\7\u0086\2\2")
        buf.write("\u03f1\u03f3\5h\65\2\u03f2\u03f0\3\2\2\2\u03f3\u03f6\3")
        buf.write("\2\2\2\u03f4\u03f2\3\2\2\2\u03f4\u03f5\3\2\2\2\u03f5\u03f8")
        buf.write("\3\2\2\2\u03f6\u03f4\3\2\2\2\u03f7\u03f9\7\u0086\2\2\u03f8")
        buf.write("\u03f7\3\2\2\2\u03f8\u03f9\3\2\2\2\u03f9\u03fa\3\2\2\2")
        buf.write("\u03fa\u03fb\7\u0080\2\2\u03fbg\3\2\2\2\u03fc\u0402\5")
        buf.write(" \21\2\u03fd\u03fe\7\177\2\2\u03fe\u03ff\5Z.\2\u03ff\u0400")
        buf.write("\7\u0080\2\2\u0400\u0402\3\2\2\2\u0401\u03fc\3\2\2\2\u0401")
        buf.write("\u03fd\3\2\2\2\u0402i\3\2\2\2\u0403\u0408\7\177\2\2\u0404")
        buf.write("\u0406\5l\67\2\u0405\u0407\7\u0086\2\2\u0406\u0405\3\2")
        buf.write("\2\2\u0406\u0407\3\2\2\2\u0407\u0409\3\2\2\2\u0408\u0404")
        buf.write("\3\2\2\2\u0408\u0409\3\2\2\2\u0409\u040a\3\2\2\2\u040a")
        buf.write("\u040b\7\u0080\2\2\u040bk\3\2\2\2\u040c\u0411\5n8\2\u040d")
        buf.write("\u040e\7\u0086\2\2\u040e\u0410\5n8\2\u040f\u040d\3\2\2")
        buf.write("\2\u0410\u0413\3\2\2\2\u0411\u040f\3\2\2\2\u0411\u0412")
        buf.write("\3\2\2\2\u0412m\3\2\2\2\u0413\u0411\3\2\2\2\u0414\u041a")
        buf.write("\5J&\2\u0415\u0416\5\u01b6\u00dc\2\u0416\u0417\7\u0093")
        buf.write("\2\2\u0417\u0418\5\36\20\2\u0418\u041a\3\2\2\2\u0419\u0414")
        buf.write("\3\2\2\2\u0419\u0415\3\2\2\2\u041ao\3\2\2\2\u041b\u0424")
        buf.write("\5\u01b6\u00dc\2\u041c\u041e\5r:\2\u041d\u041c\3\2\2\2")
        buf.write("\u041d\u041e\3\2\2\2\u041e\u0425\3\2\2\2\u041f\u0420\7")
        buf.write("\u0097\2\2\u0420\u0422\5\u01b6\u00dc\2\u0421\u0423\5r")
        buf.write(":\2\u0422\u0421\3\2\2\2\u0422\u0423\3\2\2\2\u0423\u0425")
        buf.write("\3\2\2\2\u0424\u041d\3\2\2\2\u0424\u041f\3\2\2\2\u0425")
        buf.write("\u042d\3\2\2\2\u0426\u0427\7\u0085\2\2\u0427\u0429\5\u01b6")
        buf.write("\u00dc\2\u0428\u042a\5r:\2\u0429\u0428\3\2\2\2\u0429\u042a")
        buf.write("\3\2\2\2\u042a\u042c\3\2\2\2\u042b\u0426\3\2\2\2\u042c")
        buf.write("\u042f\3\2\2\2\u042d\u042b\3\2\2\2\u042d\u042e\3\2\2\2")
        buf.write("\u042eq\3\2\2\2\u042f\u042d\3\2\2\2\u0430\u0434\7\u0094")
        buf.write("\2\2\u0431\u0433\7\u0086\2\2\u0432\u0431\3\2\2\2\u0433")
        buf.write("\u0436\3\2\2\2\u0434\u0432\3\2\2\2\u0434\u0435\3\2\2\2")
        buf.write("\u0435\u0437\3\2\2\2\u0436\u0434\3\2\2\2\u0437\u0438\7")
        buf.write("\u0095\2\2\u0438s\3\2\2\2\u0439\u043e\5\b\5\2\u043a\u043d")
        buf.write("\5\u0146\u00a4\2\u043b\u043d\7\u008b\2\2\u043c\u043a\3")
        buf.write("\2\2\2\u043c\u043b\3\2\2\2\u043d\u0440\3\2\2\2\u043e\u043c")
        buf.write("\3\2\2\2\u043e\u043f\3\2\2\2\u043f\u0442\3\2\2\2\u0440")
        buf.write("\u043e\3\2\2\2\u0441\u0443\7\u0096\2\2\u0442\u0441\3\2")
        buf.write("\2\2\u0442\u0443\3\2\2\2\u0443\u0445\3\2\2\2\u0444\u0446")
        buf.write("\5v<\2\u0445\u0444\3\2\2\2\u0445\u0446\3\2\2\2\u0446\u0448")
        buf.write("\3\2\2\2\u0447\u0449\5\u01b6\u00dc\2\u0448\u0447\3\2\2")
        buf.write("\2\u0448\u0449\3\2\2\2\u0449u\3\2\2\2\u044a\u044b\7\177")
        buf.write("\2\2\u044b\u0450\5x=\2\u044c\u044d\7\u0086\2\2\u044d\u044f")
        buf.write("\5x=\2\u044e\u044c\3\2\2\2\u044f\u0452\3\2\2\2\u0450\u044e")
        buf.write("\3\2\2\2\u0450\u0451\3\2\2\2\u0451\u0453\3\2\2\2\u0452")
        buf.write("\u0450\3\2\2\2\u0453\u0454\7\u0080\2\2\u0454w\3\2\2\2")
        buf.write("\u0455\u0456\5\u01b6\u00dc\2\u0456\u0457\7\u0087\2\2\u0457")
        buf.write("\u0458\5\36\20\2\u0458y\3\2\2\2\u0459\u045b\7\21\2\2\u045a")
        buf.write("\u0459\3\2\2\2\u045a\u045b\3\2\2\2\u045b\u045c\3\2\2\2")
        buf.write("\u045c\u045d\5|?\2\u045d\u045e\5\u017a\u00be\2\u045e\u045f")
        buf.write("\5\u0084C\2\u045f{\3\2\2\2\u0460\u0461\7\u0083\2\2\u0461")
        buf.write("\u046c\7\u0084\2\2\u0462\u0463\7\u0083\2\2\u0463\u0464")
        buf.write("\5~@\2\u0464\u0465\7\u0084\2\2\u0465\u046c\3\2\2\2\u0466")
        buf.write("\u0467\7\u0083\2\2\u0467\u0468\5\u0082B\2\u0468\u0469")
        buf.write("\7\u0084\2\2\u0469\u046c\3\2\2\2\u046a\u046c\5\u01b6\u00dc")
        buf.write("\2\u046b\u0460\3\2\2\2\u046b\u0462\3\2\2\2\u046b\u0466")
        buf.write("\3\2\2\2\u046b\u046a\3\2\2\2\u046c}\3\2\2\2\u046d\u0472")
        buf.write("\5\u0080A\2\u046e\u046f\7\u0086\2\2\u046f\u0471\5\u0080")
        buf.write("A\2\u0470\u046e\3\2\2\2\u0471\u0474\3\2\2\2\u0472\u0470")
        buf.write("\3\2\2\2\u0472\u0473\3\2\2\2\u0473\177\3\2\2\2\u0474\u0472")
        buf.write("\3\2\2\2\u0475\u0477\t\4\2\2\u0476\u0475\3\2\2\2\u0476")
        buf.write("\u0477\3\2\2\2\u0477\u0478\3\2\2\2\u0478\u0479\5\6\4\2")
        buf.write("\u0479\u047a\5\u01b6\u00dc\2\u047a\u0081\3\2\2\2\u047b")
        buf.write("\u0480\5\u01b6\u00dc\2\u047c\u047d\7\u0086\2\2\u047d\u047f")
        buf.write("\5\u01b6\u00dc\2\u047e\u047c\3\2\2\2\u047f\u0482\3\2\2")
        buf.write("\2\u0480\u047e\3\2\2\2\u0480\u0481\3\2\2\2\u0481\u0083")
        buf.write("\3\2\2\2\u0482\u0480\3\2\2\2\u0483\u0486\5N(\2\u0484\u0486")
        buf.write("\5\u00aeX\2\u0485\u0483\3\2\2\2\u0485\u0484\3\2\2\2\u0486")
        buf.write("\u0085\3\2\2\2\u0487\u0488\5\u0088E\2\u0488\u0489\5\u008a")
        buf.write("F\2\u0489\u0087\3\2\2\2\u048a\u048c\7\62\2\2\u048b\u048d")
        buf.write("\5\6\4\2\u048c\u048b\3\2\2\2\u048c\u048d\3\2\2\2\u048d")
        buf.write("\u048e\3\2\2\2\u048e\u048f\5\u01b6\u00dc\2\u048f\u0490")
        buf.write("\78\2\2\u0490\u0491\5\36\20\2\u0491\u0089\3\2\2\2\u0492")
        buf.write("\u0494\5\u008cG\2\u0493\u0492\3\2\2\2\u0494\u0497\3\2")
        buf.write("\2\2\u0495\u0493\3\2\2\2\u0495\u0496\3\2\2\2\u0496\u0498")
        buf.write("\3\2\2\2\u0497\u0495\3\2\2\2\u0498\u049a\5\u0098M\2\u0499")
        buf.write("\u049b\5\u009aN\2\u049a\u0499\3\2\2\2\u049a\u049b\3\2")
        buf.write("\2\2\u049b\u008b\3\2\2\2\u049c\u04a2\5\u0088E\2\u049d")
        buf.write("\u04a2\5\u008eH\2\u049e\u04a2\5\u0090I\2\u049f\u04a2\5")
        buf.write("\u0092J\2\u04a0\u04a2\5\u0094K\2\u04a1\u049c\3\2\2\2\u04a1")
        buf.write("\u049d\3\2\2\2\u04a1\u049e\3\2\2\2\u04a1\u049f\3\2\2\2")
        buf.write("\u04a1\u04a0\3\2\2\2\u04a2\u008d\3\2\2\2\u04a3\u04a4\7")
        buf.write("?\2\2\u04a4\u04a5\5\u01b6\u00dc\2\u04a5\u04a6\7\u0093")
        buf.write("\2\2\u04a6\u04a7\5\36\20\2\u04a7\u008f\3\2\2\2\u04a8\u04a9")
        buf.write("\7q\2\2\u04a9\u04aa\5\36\20\2\u04aa\u0091\3\2\2\2\u04ab")
        buf.write("\u04ad\7>\2\2\u04ac\u04ae\5\6\4\2\u04ad\u04ac\3\2\2\2")
        buf.write("\u04ad\u04ae\3\2\2\2\u04ae\u04af\3\2\2\2\u04af\u04b0\5")
        buf.write("\u01b6\u00dc\2\u04b0\u04b1\78\2\2\u04b1\u04b2\5\36\20")
        buf.write("\2\u04b2\u04b3\7G\2\2\u04b3\u04b4\5\36\20\2\u04b4\u04b5")
        buf.write("\7(\2\2\u04b5\u04b8\5\36\20\2\u04b6\u04b7\7<\2\2\u04b7")
        buf.write("\u04b9\5\u01b6\u00dc\2\u04b8\u04b6\3\2\2\2\u04b8\u04b9")
        buf.write("\3\2\2\2\u04b9\u0093\3\2\2\2\u04ba\u04bb\7I\2\2\u04bb")
        buf.write("\u04c0\5\u0096L\2\u04bc\u04bd\7\u0086\2\2\u04bd\u04bf")
        buf.write("\5\u0096L\2\u04be\u04bc\3\2\2\2\u04bf\u04c2\3\2\2\2\u04c0")
        buf.write("\u04be\3\2\2\2\u04c0\u04c1\3\2\2\2\u04c1\u0095\3\2\2\2")
        buf.write("\u04c2\u04c0\3\2\2\2\u04c3\u04c5\5\36\20\2\u04c4\u04c6")
        buf.write("\t\n\2\2\u04c5\u04c4\3\2\2\2\u04c5\u04c6\3\2\2\2\u04c6")
        buf.write("\u0097\3\2\2\2\u04c7\u04c8\7W\2\2\u04c8\u04cf\5\36\20")
        buf.write("\2\u04c9\u04ca\7\65\2\2\u04ca\u04cb\5\36\20\2\u04cb\u04cc")
        buf.write("\7\26\2\2\u04cc\u04cd\5\36\20\2\u04cd\u04cf\3\2\2\2\u04ce")
        buf.write("\u04c7\3\2\2\2\u04ce\u04c9\3\2\2\2\u04cf\u0099\3\2\2\2")
        buf.write("\u04d0\u04d1\7<\2\2\u04d1\u04d2\5\u01b6\u00dc\2\u04d2")
        buf.write("\u04d3\5\u008aF\2\u04d3\u009b\3\2\2\2\u04d4\u04d8\5\u00a8")
        buf.write("U\2\u04d5\u04d8\5\u009eP\2\u04d6\u04d8\5\u00aaV\2\u04d7")
        buf.write("\u04d4\3\2\2\2\u04d7\u04d5\3\2\2\2\u04d7\u04d6\3\2\2\2")
        buf.write("\u04d8\u009d\3\2\2\2\u04d9\u04da\5\u00b0Y\2\u04da\u04db")
        buf.write("\7\u0088\2\2\u04db\u04e1\3\2\2\2\u04dc\u04dd\5\u00b8]")
        buf.write("\2\u04dd\u04de\7\u0088\2\2\u04de\u04e1\3\2\2\2\u04df\u04e1")
        buf.write("\5\u00a0Q\2\u04e0\u04d9\3\2\2\2\u04e0\u04dc\3\2\2\2\u04e0")
        buf.write("\u04df\3\2\2\2\u04e1\u009f\3\2\2\2\u04e2\u04e3\5\u00a2")
        buf.write("R\2\u04e3\u04e4\5\u00a6T\2\u04e4\u00a1\3\2\2\2\u04e5\u04e7")
        buf.write("\5\u00a4S\2\u04e6\u04e5\3\2\2\2\u04e6\u04e7\3\2\2\2\u04e7")
        buf.write("\u04e8\3\2\2\2\u04e8\u04e9\5\u0116\u008c\2\u04e9\u04eb")
        buf.write("\5\u01b6\u00dc\2\u04ea\u04ec\5\u00eav\2\u04eb\u04ea\3")
        buf.write("\2\2\2\u04eb\u04ec\3\2\2\2\u04ec\u04ed\3\2\2\2\u04ed\u04ef")
        buf.write("\7\u0083\2\2\u04ee\u04f0\5\u011c\u008f\2\u04ef\u04ee\3")
        buf.write("\2\2\2\u04ef\u04f0\3\2\2\2\u04f0\u04f1\3\2\2\2\u04f1\u04f3")
        buf.write("\7\u0084\2\2\u04f2\u04f4\5\u00f2z\2\u04f3\u04f2\3\2\2")
        buf.write("\2\u04f3\u04f4\3\2\2\2\u04f4\u00a3\3\2\2\2\u04f5\u04f7")
        buf.write("\t\13\2\2\u04f6\u04f8\7\\\2\2\u04f7\u04f6\3\2\2\2\u04f7")
        buf.write("\u04f8\3\2\2\2\u04f8\u04fc\3\2\2\2\u04f9\u04fa\7\\\2\2")
        buf.write("\u04fa\u04fc\t\13\2\2\u04fb\u04f5\3\2\2\2\u04fb\u04f9")
        buf.write("\3\2\2\2\u04fc\u00a5\3\2\2\2\u04fd\u0503\5\u00aeX\2\u04fe")
        buf.write("\u04ff\5\u017a\u00be\2\u04ff\u0500\5N(\2\u0500\u0501\7")
        buf.write("\u0088\2\2\u0501\u0503\3\2\2\2\u0502\u04fd\3\2\2\2\u0502")
        buf.write("\u04fe\3\2\2\2\u0503\u00a7\3\2\2\2\u0504\u0505\5\u01b6")
        buf.write("\u00dc\2\u0505\u0506\7\u0087\2\2\u0506\u0507\5\u009cO")
        buf.write("\2\u0507\u00a9\3\2\2\2\u0508\u050b\5\u00aeX\2\u0509\u050b")
        buf.write("\5\u00acW\2\u050a\u0508\3\2\2\2\u050a\u0509\3\2\2\2\u050b")
        buf.write("\u00ab\3\2\2\2\u050c\u058f\7\u0088\2\2\u050d\u050e\5\36")
        buf.write("\20\2\u050e\u050f\7\u0088\2\2\u050f\u058f\3\2\2\2\u0510")
        buf.write("\u0511\7\66\2\2\u0511\u0512\7\u0083\2\2\u0512\u0513\5")
        buf.write("\36\20\2\u0513\u0514\7\u0084\2\2\u0514\u0517\5\u00ba^")
        buf.write("\2\u0515\u0516\7&\2\2\u0516\u0518\5\u00ba^\2\u0517\u0515")
        buf.write("\3\2\2\2\u0517\u0518\3\2\2\2\u0518\u058f\3\2\2\2\u0519")
        buf.write("\u051a\7_\2\2\u051a\u051b\7\u0083\2\2\u051b\u051c\5\36")
        buf.write("\20\2\u051c\u051d\7\u0084\2\2\u051d\u0521\7\177\2\2\u051e")
        buf.write("\u0520\5\u00bc_\2\u051f\u051e\3\2\2\2\u0520\u0523\3\2")
        buf.write("\2\2\u0521\u051f\3\2\2\2\u0521\u0522\3\2\2\2\u0522\u0524")
        buf.write("\3\2\2\2\u0523\u0521\3\2\2\2\u0524\u0525\7\u0080\2\2\u0525")
        buf.write("\u058f\3\2\2\2\u0526\u0527\7r\2\2\u0527\u0528\7\u0083")
        buf.write("\2\2\u0528\u0529\5\36\20\2\u0529\u052a\7\u0084\2\2\u052a")
        buf.write("\u052b\5\u00aaV\2\u052b\u058f\3\2\2\2\u052c\u052d\7#\2")
        buf.write("\2\u052d\u052e\5\u00aaV\2\u052e\u052f\7r\2\2\u052f\u0530")
        buf.write("\7\u0083\2\2\u0530\u0531\5\36\20\2\u0531\u0532\7\u0084")
        buf.write("\2\2\u0532\u0533\7\u0088\2\2\u0533\u058f\3\2\2\2\u0534")
        buf.write("\u0535\7\60\2\2\u0535\u0537\7\u0083\2\2\u0536\u0538\5")
        buf.write("\u00c4c\2\u0537\u0536\3\2\2\2\u0537\u0538\3\2\2\2\u0538")
        buf.write("\u0539\3\2\2\2\u0539\u053b\7\u0088\2\2\u053a\u053c\5\36")
        buf.write("\20\2\u053b\u053a\3\2\2\2\u053b\u053c\3\2\2\2\u053c\u053d")
        buf.write("\3\2\2\2\u053d\u053f\7\u0088\2\2\u053e\u0540\5\u00c6d")
        buf.write("\2\u053f\u053e\3\2\2\2\u053f\u0540\3\2\2\2\u0540\u0541")
        buf.write("\3\2\2\2\u0541\u0542\7\u0084\2\2\u0542\u058f\5\u00aaV")
        buf.write("\2\u0543\u0545\7\22\2\2\u0544\u0543\3\2\2\2\u0544\u0545")
        buf.write("\3\2\2\2\u0545\u0546\3\2\2\2\u0546\u0547\7\61\2\2\u0547")
        buf.write("\u0548\7\u0083\2\2\u0548\u0549\5\u00b2Z\2\u0549\u054a")
        buf.write("\5\u01b6\u00dc\2\u054a\u054b\78\2\2\u054b\u054c\5\36\20")
        buf.write("\2\u054c\u054d\7\u0084\2\2\u054d\u054e\5\u00aaV\2\u054e")
        buf.write("\u058f\3\2\2\2\u054f\u0550\7\25\2\2\u0550\u058f\7\u0088")
        buf.write("\2\2\u0551\u0552\7\36\2\2\u0552\u058f\7\u0088\2\2\u0553")
        buf.write("\u0558\7\64\2\2\u0554\u0559\5\u01b6\u00dc\2\u0555\u0556")
        buf.write("\7\30\2\2\u0556\u0559\5\36\20\2\u0557\u0559\7 \2\2\u0558")
        buf.write("\u0554\3\2\2\2\u0558\u0555\3\2\2\2\u0558\u0557\3\2\2\2")
        buf.write("\u0559\u055a\3\2\2\2\u055a\u058f\7\u0088\2\2\u055b\u055d")
        buf.write("\7T\2\2\u055c\u055e\5\36\20\2\u055d\u055c\3\2\2\2\u055d")
        buf.write("\u055e\3\2\2\2\u055e\u055f\3\2\2\2\u055f\u058f\7\u0088")
        buf.write("\2\2\u0560\u0562\7a\2\2\u0561\u0563\5\36\20\2\u0562\u0561")
        buf.write("\3\2\2\2\u0562\u0563\3\2\2\2\u0563\u0564\3\2\2\2\u0564")
        buf.write("\u058f\7\u0088\2\2\u0565\u0566\7c\2\2\u0566\u056c\5\u00ae")
        buf.write("X\2\u0567\u0569\5\u00c8e\2\u0568\u056a\5\u00d0i\2\u0569")
        buf.write("\u0568\3\2\2\2\u0569\u056a\3\2\2\2\u056a\u056d\3\2\2\2")
        buf.write("\u056b\u056d\5\u00d0i\2\u056c\u0567\3\2\2\2\u056c\u056b")
        buf.write("\3\2\2\2\u056d\u058f\3\2\2\2\u056e\u056f\7\33\2\2\u056f")
        buf.write("\u058f\5\u00aeX\2\u0570\u0571\7g\2\2\u0571\u058f\5\u00ae")
        buf.write("X\2\u0572\u0573\7@\2\2\u0573\u0574\7\u0083\2\2\u0574\u0575")
        buf.write("\5\36\20\2\u0575\u0576\7\u0084\2\2\u0576\u0577\5\u00aa")
        buf.write("V\2\u0577\u058f\3\2\2\2\u0578\u0579\7k\2\2\u0579\u057a")
        buf.write("\7\u0083\2\2\u057a\u057b\5\u00d2j\2\u057b\u057c\7\u0084")
        buf.write("\2\2\u057c\u057d\5\u00aaV\2\u057d\u058f\3\2\2\2\u057e")
        buf.write("\u0582\7s\2\2\u057f\u0580\7T\2\2\u0580\u0583\5\36\20\2")
        buf.write("\u0581\u0583\7\25\2\2\u0582\u057f\3\2\2\2\u0582\u0581")
        buf.write("\3\2\2\2\u0583\u0584\3\2\2\2\u0584\u058f\7\u0088\2\2\u0585")
        buf.write("\u0586\7i\2\2\u0586\u058f\5\u00aeX\2\u0587\u0588\7.\2")
        buf.write("\2\u0588\u0589\7\u0083\2\2\u0589\u058a\5\u016e\u00b8\2")
        buf.write("\u058a\u058b\5\u0170\u00b9\2\u058b\u058c\7\u0084\2\2\u058c")
        buf.write("\u058d\5\u00aaV\2\u058d\u058f\3\2\2\2\u058e\u050c\3\2")
        buf.write("\2\2\u058e\u050d\3\2\2\2\u058e\u0510\3\2\2\2\u058e\u0519")
        buf.write("\3\2\2\2\u058e\u0526\3\2\2\2\u058e\u052c\3\2\2\2\u058e")
        buf.write("\u0534\3\2\2\2\u058e\u0544\3\2\2\2\u058e\u054f\3\2\2\2")
        buf.write("\u058e\u0551\3\2\2\2\u058e\u0553\3\2\2\2\u058e\u055b\3")
        buf.write("\2\2\2\u058e\u0560\3\2\2\2\u058e\u0565\3\2\2\2\u058e\u056e")
        buf.write("\3\2\2\2\u058e\u0570\3\2\2\2\u058e\u0572\3\2\2\2\u058e")
        buf.write("\u0578\3\2\2\2\u058e\u057e\3\2\2\2\u058e\u0585\3\2\2\2")
        buf.write("\u058e\u0587\3\2\2\2\u058f\u00ad\3\2\2\2\u0590\u0592\7")
        buf.write("\177\2\2\u0591\u0593\5\u00c2b\2\u0592\u0591\3\2\2\2\u0592")
        buf.write("\u0593\3\2\2\2\u0593\u0594\3\2\2\2\u0594\u0595\7\u0080")
        buf.write("\2\2\u0595\u00af\3\2\2\2\u0596\u059b\7k\2\2\u0597\u059b")
        buf.write("\7R\2\2\u0598\u0599\7R\2\2\u0599\u059b\7Q\2\2\u059a\u0596")
        buf.write("\3\2\2\2\u059a\u0597\3\2\2\2\u059a\u0598\3\2\2\2\u059a")
        buf.write("\u059b\3\2\2\2\u059b\u059c\3\2\2\2\u059c\u059d\5\u00b2")
        buf.write("Z\2\u059d\u05a4\5\u00b4[\2\u059e\u059f\7\u0086\2\2\u059f")
        buf.write("\u05a0\5\u00b4[\2\u05a0\u05a1\6Y\2\2\u05a1\u05a3\3\2\2")
        buf.write("\2\u05a2\u059e\3\2\2\2\u05a3\u05a6\3\2\2\2\u05a4\u05a2")
        buf.write("\3\2\2\2\u05a4\u05a5\3\2\2\2\u05a5\u05ac\3\2\2\2\u05a6")
        buf.write("\u05a4\3\2\2\2\u05a7\u05a8\7.\2\2\u05a8\u05a9\5\u016e")
        buf.write("\u00b8\2\u05a9\u05aa\5\u0170\u00b9\2\u05aa\u05ac\3\2\2")
        buf.write("\2\u05ab\u059a\3\2\2\2\u05ab\u05a7\3\2\2\2\u05ac\u00b1")
        buf.write("\3\2\2\2\u05ad\u05b0\7l\2\2\u05ae\u05b0\5\6\4\2\u05af")
        buf.write("\u05ad\3\2\2\2\u05af\u05ae\3\2\2\2\u05b0\u00b3\3\2\2\2")
        buf.write("\u05b1\u05b7\5\u01b6\u00dc\2\u05b2\u05b4\7\u0093\2\2\u05b3")
        buf.write("\u05b5\7R\2\2\u05b4\u05b3\3\2\2\2\u05b4\u05b5\3\2\2\2")
        buf.write("\u05b5\u05b6\3\2\2\2\u05b6\u05b8\5\u00b6\\\2\u05b7\u05b2")
        buf.write("\3\2\2\2\u05b7\u05b8\3\2\2\2\u05b8\u00b5\3\2\2\2\u05b9")
        buf.write("\u05bd\5\36\20\2\u05ba\u05bd\5\u0148\u00a5\2\u05bb\u05bd")
        buf.write("\5\u0178\u00bd\2\u05bc\u05b9\3\2\2\2\u05bc\u05ba\3\2\2")
        buf.write("\2\u05bc\u05bb\3\2\2\2\u05bd\u00b7\3\2\2\2\u05be\u05bf")
        buf.write("\7\35\2\2\u05bf\u05c0\5\6\4\2\u05c0\u05c1\5\u010c\u0087")
        buf.write("\2\u05c1\u00b9\3\2\2\2\u05c2\u05c5\5\u00aeX\2\u05c3\u05c5")
        buf.write("\5\u00acW\2\u05c4\u05c2\3\2\2\2\u05c4\u05c3\3\2\2\2\u05c5")
        buf.write("\u00bb\3\2\2\2\u05c6\u05c8\5\u00be`\2\u05c7\u05c6\3\2")
        buf.write("\2\2\u05c8\u05c9\3\2\2\2\u05c9\u05c7\3\2\2\2\u05c9\u05ca")
        buf.write("\3\2\2\2\u05ca\u05cb\3\2\2\2\u05cb\u05cc\5\u00c2b\2\u05cc")
        buf.write("\u00bd\3\2\2\2\u05cd\u05ce\7\30\2\2\u05ce\u05d0\5\36\20")
        buf.write("\2\u05cf\u05d1\5\u00c0a\2\u05d0\u05cf\3\2\2\2\u05d0\u05d1")
        buf.write("\3\2\2\2\u05d1\u05d2\3\2\2\2\u05d2\u05d3\7\u0087\2\2\u05d3")
        buf.write("\u05d7\3\2\2\2\u05d4\u05d5\7 \2\2\u05d5\u05d7\7\u0087")
        buf.write("\2\2\u05d6\u05cd\3\2\2\2\u05d6\u05d4\3\2\2\2\u05d7\u00bf")
        buf.write("\3\2\2\2\u05d8\u05d9\7p\2\2\u05d9\u05da\5\36\20\2\u05da")
        buf.write("\u00c1\3\2\2\2\u05db\u05dd\5\u009cO\2\u05dc\u05db\3\2")
        buf.write("\2\2\u05dd\u05de\3\2\2\2\u05de\u05dc\3\2\2\2\u05de\u05df")
        buf.write("\3\2\2\2\u05df\u00c3\3\2\2\2\u05e0\u05ea\5\u00b0Y\2\u05e1")
        buf.write("\u05e6\5\36\20\2\u05e2\u05e3\7\u0086\2\2\u05e3\u05e5\5")
        buf.write("\36\20\2\u05e4\u05e2\3\2\2\2\u05e5\u05e8\3\2\2\2\u05e6")
        buf.write("\u05e4\3\2\2\2\u05e6\u05e7\3\2\2\2\u05e7\u05ea\3\2\2\2")
        buf.write("\u05e8\u05e6\3\2\2\2\u05e9\u05e0\3\2\2\2\u05e9\u05e1\3")
        buf.write("\2\2\2\u05ea\u00c5\3\2\2\2\u05eb\u05f0\5\36\20\2\u05ec")
        buf.write("\u05ed\7\u0086\2\2\u05ed\u05ef\5\36\20\2\u05ee\u05ec\3")
        buf.write("\2\2\2\u05ef\u05f2\3\2\2\2\u05f0\u05ee\3\2\2\2\u05f0\u05f1")
        buf.write("\3\2\2\2\u05f1\u00c7\3\2\2\2\u05f2\u05f0\3\2\2\2\u05f3")
        buf.write("\u05f7\5\u00caf\2\u05f4\u05f6\5\u00caf\2\u05f5\u05f4\3")
        buf.write("\2\2\2\u05f6\u05f9\3\2\2\2\u05f7\u05f5\3\2\2\2\u05f7\u05f8")
        buf.write("\3\2\2\2\u05f8\u05fb\3\2\2\2\u05f9\u05f7\3\2\2\2\u05fa")
        buf.write("\u05fc\5\u00ccg\2\u05fb\u05fa\3\2\2\2\u05fb\u05fc\3\2")
        buf.write("\2\2\u05fc\u05ff\3\2\2\2\u05fd\u05ff\5\u00ccg\2\u05fe")
        buf.write("\u05f3\3\2\2\2\u05fe\u05fd\3\2\2\2\u05ff\u00c9\3\2\2\2")
        buf.write("\u0600\u0601\7\31\2\2\u0601\u0602\7\u0083\2\2\u0602\u0604")
        buf.write("\5\26\f\2\u0603\u0605\5\u01b6\u00dc\2\u0604\u0603\3\2")
        buf.write("\2\2\u0604\u0605\3\2\2\2\u0605\u0606\3\2\2\2\u0606\u0608")
        buf.write("\7\u0084\2\2\u0607\u0609\5\u00ceh\2\u0608\u0607\3\2\2")
        buf.write("\2\u0608\u0609\3\2\2\2\u0609\u060a\3\2\2\2\u060a\u060b")
        buf.write("\5\u00aeX\2\u060b\u00cb\3\2\2\2\u060c\u060e\7\31\2\2\u060d")
        buf.write("\u060f\5\u00ceh\2\u060e\u060d\3\2\2\2\u060e\u060f\3\2")
        buf.write("\2\2\u060f\u0610\3\2\2\2\u0610\u0611\5\u00aeX\2\u0611")
        buf.write("\u00cd\3\2\2\2\u0612\u0613\7p\2\2\u0613\u0614\7\u0083")
        buf.write("\2\2\u0614\u0615\5\36\20\2\u0615\u0616\7\u0084\2\2\u0616")
        buf.write("\u00cf\3\2\2\2\u0617\u0618\7-\2\2\u0618\u0619\5\u00ae")
        buf.write("X\2\u0619\u00d1\3\2\2\2\u061a\u061d\5\u00b0Y\2\u061b\u061d")
        buf.write("\5\36\20\2\u061c\u061a\3\2\2\2\u061c\u061b\3\2\2\2\u061d")
        buf.write("\u00d3\3\2\2\2\u061e\u061f\7C\2\2\u061f\u0620\5\u00d6")
        buf.write("l\2\u0620\u0622\5\u00d8m\2\u0621\u0623\7\u0088\2\2\u0622")
        buf.write("\u0621\3\2\2\2\u0622\u0623\3\2\2\2\u0623\u00d5\3\2\2\2")
        buf.write("\u0624\u0629\5\u01b6\u00dc\2\u0625\u0626\7\u0085\2\2\u0626")
        buf.write("\u0628\5\u01b6\u00dc\2\u0627\u0625\3\2\2\2\u0628\u062b")
        buf.write("\3\2\2\2\u0629\u0627\3\2\2\2\u0629\u062a\3\2\2\2\u062a")
        buf.write("\u00d7\3\2\2\2\u062b\u0629\3\2\2\2\u062c\u062e\7\177\2")
        buf.write("\2\u062d\u062f\5\u00dan\2\u062e\u062d\3\2\2\2\u062e\u062f")
        buf.write("\3\2\2\2\u062f\u0631\3\2\2\2\u0630\u0632\5\u00dep\2\u0631")
        buf.write("\u0630\3\2\2\2\u0631\u0632\3\2\2\2\u0632\u0634\3\2\2\2")
        buf.write("\u0633\u0635\5\u00e2r\2\u0634\u0633\3\2\2\2\u0634\u0635")
        buf.write("\3\2\2\2\u0635\u0636\3\2\2\2\u0636\u0637\7\u0080\2\2\u0637")
        buf.write("\u00d9\3\2\2\2\u0638\u063a\5\u00dco\2\u0639\u0638\3\2")
        buf.write("\2\2\u063a\u063b\3\2\2\2\u063b\u0639\3\2\2\2\u063b\u063c")
        buf.write("\3\2\2\2\u063c\u00db\3\2\2\2\u063d\u063e\7+\2\2\u063e")
        buf.write("\u063f\7\r\2\2\u063f\u0640\5\u01b6\u00dc\2\u0640\u0641")
        buf.write("\7\u0088\2\2\u0641\u00dd\3\2\2\2\u0642\u0644\5\u00e0q")
        buf.write("\2\u0643\u0642\3\2\2\2\u0644\u0645\3\2\2\2\u0645\u0643")
        buf.write("\3\2\2\2\u0645\u0646\3\2\2\2\u0646\u00df\3\2\2\2\u0647")
        buf.write("\u0648\7k\2\2\u0648\u0649\5\u01b6\u00dc\2\u0649\u064a")
        buf.write("\7\u0093\2\2\u064a\u064b\5\4\3\2\u064b\u064c\7\u0088\2")
        buf.write("\2\u064c\u0657\3\2\2\2\u064d\u064e\7k\2\2\u064e\u064f")
        buf.write("\5\4\3\2\u064f\u0650\7\u0088\2\2\u0650\u0657\3\2\2\2\u0651")
        buf.write("\u0652\7k\2\2\u0652\u0653\7\\\2\2\u0653\u0654\5\4\3\2")
        buf.write("\u0654\u0655\7\u0088\2\2\u0655\u0657\3\2\2\2\u0656\u0647")
        buf.write("\3\2\2\2\u0656\u064d\3\2\2\2\u0656\u0651\3\2\2\2\u0657")
        buf.write("\u00e1\3\2\2\2\u0658\u065a\5\u00e4s\2\u0659\u0658\3\2")
        buf.write("\2\2\u065a\u065b\3\2\2\2\u065b\u0659\3\2\2\2\u065b\u065c")
        buf.write("\3\2\2\2\u065c\u00e3\3\2\2\2\u065d\u0660\5\u00d4k\2\u065e")
        buf.write("\u0660\5\u00e6t\2\u065f\u065d\3\2\2\2\u065f\u065e\3\2")
        buf.write("\2\2\u0660\u00e5\3\2\2\2\u0661\u0663\5\u0162\u00b2\2\u0662")
        buf.write("\u0661\3\2\2\2\u0662\u0663\3\2\2\2\u0663\u0665\3\2\2\2")
        buf.write("\u0664\u0666\5\u0104\u0083\2\u0665\u0664\3\2\2\2\u0665")
        buf.write("\u0666\3\2\2\2\u0666\u066c\3\2\2\2\u0667\u066d\5\u0192")
        buf.write("\u00ca\2\u0668\u066d\5\u0194\u00cb\2\u0669\u066d\5\u0196")
        buf.write("\u00cc\2\u066a\u066d\5\u0198\u00cd\2\u066b\u066d\5\u019a")
        buf.write("\u00ce\2\u066c\u0667\3\2\2\2\u066c\u0668\3\2\2\2\u066c")
        buf.write("\u0669\3\2\2\2\u066c\u066a\3\2\2\2\u066c\u066b\3\2\2\2")
        buf.write("\u066d\u00e7\3\2\2\2\u066e\u066f\5\u01b6\u00dc\2\u066f")
        buf.write("\u0670\7\u0097\2\2\u0670\u0672\5\u01b6\u00dc\2\u0671\u0673")
        buf.write("\5\30\r\2\u0672\u0671\3\2\2\2\u0672\u0673\3\2\2\2\u0673")
        buf.write("\u00e9\3\2\2\2\u0674\u0675\7\u0094\2\2\u0675\u067a\5\u00ec")
        buf.write("w\2\u0676\u0677\7\u0086\2\2\u0677\u0679\5\u00ecw\2\u0678")
        buf.write("\u0676\3\2\2\2\u0679\u067c\3\2\2\2\u067a\u0678\3\2\2\2")
        buf.write("\u067a\u067b\3\2\2\2\u067b\u067d\3\2\2\2\u067c\u067a\3")
        buf.write("\2\2\2\u067d\u067e\7\u0095\2\2\u067e\u00eb\3\2\2\2\u067f")
        buf.write("\u0681\5\u0162\u00b2\2\u0680\u067f\3\2\2\2\u0680\u0681")
        buf.write("\3\2\2\2\u0681\u0682\3\2\2\2\u0682\u0683\5\u01b6\u00dc")
        buf.write("\2\u0683\u00ed\3\2\2\2\u0684\u0685\7\u0087\2\2\u0685\u068a")
        buf.write("\5\26\f\2\u0686\u0687\7\u0086\2\2\u0687\u0689\5\4\3\2")
        buf.write("\u0688\u0686\3\2\2\2\u0689\u068c\3\2\2\2\u068a\u0688\3")
        buf.write("\2\2\2\u068a\u068b\3\2\2\2\u068b\u00ef\3\2\2\2\u068c\u068a")
        buf.write("\3\2\2\2\u068d\u0692\5\4\3\2\u068e\u068f\7\u0086\2\2\u068f")
        buf.write("\u0691\5\4\3\2\u0690\u068e\3\2\2\2\u0691\u0694\3\2\2\2")
        buf.write("\u0692\u0690\3\2\2\2\u0692\u0693\3\2\2\2\u0693\u00f1\3")
        buf.write("\2\2\2\u0694\u0692\3\2\2\2\u0695\u0697\5\u00f4{\2\u0696")
        buf.write("\u0695\3\2\2\2\u0697\u0698\3\2\2\2\u0698\u0696\3\2\2\2")
        buf.write("\u0698\u0699\3\2\2\2\u0699\u00f3\3\2\2\2\u069a\u069b\7")
        buf.write("q\2\2\u069b\u069c\5\u01b6\u00dc\2\u069c\u069d\7\u0087")
        buf.write("\2\2\u069d\u069e\5\u00f6|\2\u069e\u00f5\3\2\2\2\u069f")
        buf.write("\u06aa\5\u00fc\177\2\u06a0\u06a3\5\u00f8}\2\u06a1\u06a2")
        buf.write("\7\u0086\2\2\u06a2\u06a4\5\u00fa~\2\u06a3\u06a1\3\2\2")
        buf.write("\2\u06a3\u06a4\3\2\2\2\u06a4\u06a7\3\2\2\2\u06a5\u06a6")
        buf.write("\7\u0086\2\2\u06a6\u06a8\5\u00fc\177\2\u06a7\u06a5\3\2")
        buf.write("\2\2\u06a7\u06a8\3\2\2\2\u06a8\u06aa\3\2\2\2\u06a9\u069f")
        buf.write("\3\2\2\2\u06a9\u06a0\3\2\2\2\u06aa\u00f7\3\2\2\2\u06ab")
        buf.write("\u06b3\5\26\f\2\u06ac\u06ae\7\34\2\2\u06ad\u06af\7\u0096")
        buf.write("\2\2\u06ae\u06ad\3\2\2\2\u06ae\u06af\3\2\2\2\u06af\u06b3")
        buf.write("\3\2\2\2\u06b0\u06b3\7^\2\2\u06b1\u06b3\7h\2\2\u06b2\u06ab")
        buf.write("\3\2\2\2\u06b2\u06ac\3\2\2\2\u06b2\u06b0\3\2\2\2\u06b2")
        buf.write("\u06b1\3\2\2\2\u06b3\u00f9\3\2\2\2\u06b4\u06b9\5\4\3\2")
        buf.write("\u06b5\u06b6\7\u0086\2\2\u06b6\u06b8\5\4\3\2\u06b7\u06b5")
        buf.write("\3\2\2\2\u06b8\u06bb\3\2\2\2\u06b9\u06b7\3\2\2\2\u06b9")
        buf.write("\u06ba\3\2\2\2\u06ba\u00fb\3\2\2\2\u06bb\u06b9\3\2\2\2")
        buf.write("\u06bc\u06bd\7D\2\2\u06bd\u06be\7\u0083\2\2\u06be\u06bf")
        buf.write("\7\u0084\2\2\u06bf\u00fd\3\2\2\2\u06c0\u06c2\7\177\2\2")
        buf.write("\u06c1\u06c3\5\u0100\u0081\2\u06c2\u06c1\3\2\2\2\u06c2")
        buf.write("\u06c3\3\2\2\2\u06c3\u06c4\3\2\2\2\u06c4\u06c5\7\u0080")
        buf.write("\2\2\u06c5\u00ff\3\2\2\2\u06c6\u06c8\5\u0102\u0082\2\u06c7")
        buf.write("\u06c6\3\2\2\2\u06c8\u06c9\3\2\2\2\u06c9\u06c7\3\2\2\2")
        buf.write("\u06c9\u06ca\3\2\2\2\u06ca\u0101\3\2\2\2\u06cb\u06cd\5")
        buf.write("\u0162\u00b2\2\u06cc\u06cb\3\2\2\2\u06cc\u06cd\3\2\2\2")
        buf.write("\u06cd\u06cf\3\2\2\2\u06ce\u06d0\5\u0104\u0083\2\u06cf")
        buf.write("\u06ce\3\2\2\2\u06cf\u06d0\3\2\2\2\u06d0\u06d3\3\2\2\2")
        buf.write("\u06d1\u06d4\5\u0108\u0085\2\u06d2\u06d4\5\u01a6\u00d4")
        buf.write("\2\u06d3\u06d1\3\2\2\2\u06d3\u06d2\3\2\2\2\u06d4\u0103")
        buf.write("\3\2\2\2\u06d5\u06d7\5\u0106\u0084\2\u06d6\u06d5\3\2\2")
        buf.write("\2\u06d7\u06d8\3\2\2\2\u06d8\u06d6\3\2\2\2\u06d8\u06d9")
        buf.write("\3\2\2\2\u06d9\u0105\3\2\2\2\u06da\u06db\t\f\2\2\u06db")
        buf.write("\u0107\3\2\2\2\u06dc\u06f0\5\u01a2\u00d2\2\u06dd\u06f0")
        buf.write("\5\u010a\u0086\2\u06de\u06f0\5\u019c\u00cf\2\u06df\u06e5")
        buf.write("\5\u0138\u009d\2\u06e0\u06e6\5\u013c\u009f\2\u06e1\u06e2")
        buf.write("\5\u017a\u00be\2\u06e2\u06e3\5N(\2\u06e3\u06e4\7\u0088")
        buf.write("\2\2\u06e4\u06e6\3\2\2\2\u06e5\u06e0\3\2\2\2\u06e5\u06e1")
        buf.write("\3\2\2\2\u06e6\u06f0\3\2\2\2\u06e7\u06f0\5\u01a8\u00d5")
        buf.write("\2\u06e8\u06e9\7n\2\2\u06e9\u06f0\5\u01aa\u00d6\2\u06ea")
        buf.write("\u06f0\5\u0192\u00ca\2\u06eb\u06f0\5\u0194\u00cb\2\u06ec")
        buf.write("\u06f0\5\u0196\u00cc\2\u06ed\u06f0\5\u0198\u00cd\2\u06ee")
        buf.write("\u06f0\5\u019a\u00ce\2\u06ef\u06dc\3\2\2\2\u06ef\u06dd")
        buf.write("\3\2\2\2\u06ef\u06de\3\2\2\2\u06ef\u06df\3\2\2\2\u06ef")
        buf.write("\u06e7\3\2\2\2\u06ef\u06e8\3\2\2\2\u06ef\u06ea\3\2\2\2")
        buf.write("\u06ef\u06eb\3\2\2\2\u06ef\u06ec\3\2\2\2\u06ef\u06ed\3")
        buf.write("\2\2\2\u06ef\u06ee\3\2\2\2\u06f0\u0109\3\2\2\2\u06f1\u06f7")
        buf.write("\7R\2\2\u06f2\u06f3\7Q\2\2\u06f3\u06f7\7R\2\2\u06f4\u06f5")
        buf.write("\7R\2\2\u06f5\u06f7\7Q\2\2\u06f6\u06f1\3\2\2\2\u06f6\u06f2")
        buf.write("\3\2\2\2\u06f6\u06f4\3\2\2\2\u06f6\u06f7\3\2\2\2\u06f7")
        buf.write("\u06f8\3\2\2\2\u06f8\u0702\5\6\4\2\u06f9\u06fa\5\4\3\2")
        buf.write("\u06fa\u06fb\7\u0085\2\2\u06fb\u06fc\5\u01a4\u00d3\2\u06fc")
        buf.write("\u0703\3\2\2\2\u06fd\u0703\5\u01aa\u00d6\2\u06fe\u0703")
        buf.write("\5\u01a0\u00d1\2\u06ff\u0703\5\u01a4\u00d3\2\u0700\u0703")
        buf.write("\5\u01ae\u00d8\2\u0701\u0703\5\u019e\u00d0\2\u0702\u06f9")
        buf.write("\3\2\2\2\u0702\u06fd\3\2\2\2\u0702\u06fe\3\2\2\2\u0702")
        buf.write("\u06ff\3\2\2\2\u0702\u0700\3\2\2\2\u0702\u0701\3\2\2\2")
        buf.write("\u0703\u010b\3\2\2\2\u0704\u0709\5\u010e\u0088\2\u0705")
        buf.write("\u0706\7\u0086\2\2\u0706\u0708\5\u010e\u0088\2\u0707\u0705")
        buf.write("\3\2\2\2\u0708\u070b\3\2\2\2\u0709\u0707\3\2\2\2\u0709")
        buf.write("\u070a\3\2\2\2\u070a\u010d\3\2\2\2\u070b\u0709\3\2\2\2")
        buf.write("\u070c\u070d\5\u01b6\u00dc\2\u070d\u070e\7\u0093\2\2\u070e")
        buf.write("\u070f\5\36\20\2\u070f\u010f\3\2\2\2\u0710\u0715\5\u0112")
        buf.write("\u008a\2\u0711\u0712\7\u0086\2\2\u0712\u0714\5\u0112\u008a")
        buf.write("\2\u0713\u0711\3\2\2\2\u0714\u0717\3\2\2\2\u0715\u0713")
        buf.write("\3\2\2\2\u0715\u0716\3\2\2\2\u0716\u0111\3\2\2\2\u0717")
        buf.write("\u0715\3\2\2\2\u0718\u071b\5\u01b6\u00dc\2\u0719\u071a")
        buf.write("\7\u0093\2\2\u071a\u071c\5\u0114\u008b\2\u071b\u0719\3")
        buf.write("\2\2\2\u071b\u071c\3\2\2\2\u071c\u0113\3\2\2\2\u071d\u0720")
        buf.write("\5\36\20\2\u071e\u0720\5\u0148\u00a5\2\u071f\u071d\3\2")
        buf.write("\2\2\u071f\u071e\3\2\2\2\u0720\u0115\3\2\2\2\u0721\u0724")
        buf.write("\5\6\4\2\u0722\u0724\7n\2\2\u0723\u0721\3\2\2\2\u0723")
        buf.write("\u0722\3\2\2\2\u0724\u0117\3\2\2\2\u0725\u0726\5\4\3\2")
        buf.write("\u0726\u0119\3\2\2\2\u0727\u072a\5\u00aeX\2\u0728\u072a")
        buf.write("\7\u0088\2\2\u0729\u0727\3\2\2\2\u0729\u0728\3\2\2\2\u072a")
        buf.write("\u011b\3\2\2\2\u072b\u0732\5\u0124\u0093\2\u072c\u072f")
        buf.write("\5\u011e\u0090\2\u072d\u072e\7\u0086\2\2\u072e\u0730\5")
        buf.write("\u0124\u0093\2\u072f\u072d\3\2\2\2\u072f\u0730\3\2\2\2")
        buf.write("\u0730\u0732\3\2\2\2\u0731\u072b\3\2\2\2\u0731\u072c\3")
        buf.write("\2\2\2\u0732\u011d\3\2\2\2\u0733\u0738\5\u0120\u0091\2")
        buf.write("\u0734\u0735\7\u0086\2\2\u0735\u0737\5\u0120\u0091\2\u0736")
        buf.write("\u0734\3\2\2\2\u0737\u073a\3\2\2\2\u0738\u0736\3\2\2\2")
        buf.write("\u0738\u0739\3\2\2\2\u0739\u011f\3\2\2\2\u073a\u0738\3")
        buf.write("\2\2\2\u073b\u073d\5\u0162\u00b2\2\u073c\u073b\3\2\2\2")
        buf.write("\u073c\u073d\3\2\2\2\u073d\u073f\3\2\2\2\u073e\u0740\5")
        buf.write("\u0122\u0092\2\u073f\u073e\3\2\2\2\u073f\u0740\3\2\2\2")
        buf.write("\u0740\u0741\3\2\2\2\u0741\u0744\5\u01b0\u00d9\2\u0742")
        buf.write("\u0744\7\16\2\2\u0743\u073c\3\2\2\2\u0743\u0742\3\2\2")
        buf.write("\2\u0744\u0121\3\2\2\2\u0745\u074e\7R\2\2\u0746\u074e")
        buf.write("\7J\2\2\u0747\u074e\78\2\2\u0748\u0749\7R\2\2\u0749\u074e")
        buf.write("\7`\2\2\u074a\u074b\78\2\2\u074b\u074e\7`\2\2\u074c\u074e")
        buf.write("\7`\2\2\u074d\u0745\3\2\2\2\u074d\u0746\3\2\2\2\u074d")
        buf.write("\u0747\3\2\2\2\u074d\u0748\3\2\2\2\u074d\u074a\3\2\2\2")
        buf.write("\u074d\u074c\3\2\2\2\u074e\u0123\3\2\2\2\u074f\u0751\5")
        buf.write("\u0162\u00b2\2\u0750\u074f\3\2\2\2\u0750\u0751\3\2\2\2")
        buf.write("\u0751\u0752\3\2\2\2\u0752\u0753\7L\2\2\u0753\u0754\5")
        buf.write("\u0144\u00a3\2\u0754\u0755\5\u01b6\u00dc\2\u0755\u0125")
        buf.write("\3\2\2\2\u0756\u0758\5\u0162\u00b2\2\u0757\u0756\3\2\2")
        buf.write("\2\u0757\u0758\3\2\2\2\u0758\u075a\3\2\2\2\u0759\u075b")
        buf.write("\5\u012c\u0097\2\u075a\u0759\3\2\2\2\u075a\u075b\3\2\2")
        buf.write("\2\u075b\u0766\3\2\2\2\u075c\u075d\7\63\2\2\u075d\u075f")
        buf.write("\5\u012e\u0098\2\u075e\u0760\5\u012a\u0096\2\u075f\u075e")
        buf.write("\3\2\2\2\u075f\u0760\3\2\2\2\u0760\u0767\3\2\2\2\u0761")
        buf.write("\u0762\7X\2\2\u0762\u0764\5\u012e\u0098\2\u0763\u0765")
        buf.write("\5\u0128\u0095\2\u0764\u0763\3\2\2\2\u0764\u0765\3\2\2")
        buf.write("\2\u0765\u0767\3\2\2\2\u0766\u075c\3\2\2\2\u0766\u0761")
        buf.write("\3\2\2\2\u0767\u0127\3\2\2\2\u0768\u076a\5\u0162\u00b2")
        buf.write("\2\u0769\u0768\3\2\2\2\u0769\u076a\3\2\2\2\u076a\u076c")
        buf.write("\3\2\2\2\u076b\u076d\5\u012c\u0097\2\u076c\u076b\3\2\2")
        buf.write("\2\u076c\u076d\3\2\2\2\u076d\u076e\3\2\2\2\u076e\u076f")
        buf.write("\7\63\2\2\u076f\u0770\5\u012e\u0098\2\u0770\u0129\3\2")
        buf.write("\2\2\u0771\u0773\5\u0162\u00b2\2\u0772\u0771\3\2\2\2\u0772")
        buf.write("\u0773\3\2\2\2\u0773\u0775\3\2\2\2\u0774\u0776\5\u012c")
        buf.write("\u0097\2\u0775\u0774\3\2\2\2\u0775\u0776\3\2\2\2\u0776")
        buf.write("\u0777\3\2\2\2\u0777\u0778\7X\2\2\u0778\u0779\5\u012e")
        buf.write("\u0098\2\u0779\u012b\3\2\2\2\u077a\u0782\7O\2\2\u077b")
        buf.write("\u0782\7;\2\2\u077c\u0782\7N\2\2\u077d\u077e\7O\2\2\u077e")
        buf.write("\u0782\7;\2\2\u077f\u0780\7;\2\2\u0780\u0782\7O\2\2\u0781")
        buf.write("\u077a\3\2\2\2\u0781\u077b\3\2\2\2\u0781\u077c\3\2\2\2")
        buf.write("\u0781\u077d\3\2\2\2\u0781\u077f\3\2\2\2\u0782\u012d\3")
        buf.write("\2\2\2\u0783\u0786\5\u00aeX\2\u0784\u0786\7\u0088\2\2")
        buf.write("\u0785\u0783\3\2\2\2\u0785\u0784\3\2\2\2\u0786\u012f\3")
        buf.write("\2\2\2\u0787\u0789\5\u0162\u00b2\2\u0788\u0787\3\2\2\2")
        buf.write("\u0788\u0789\3\2\2\2\u0789\u0792\3\2\2\2\u078a\u078b\7")
        buf.write("\f\2\2\u078b\u078c\5\u00aeX\2\u078c\u078d\5\u0134\u009b")
        buf.write("\2\u078d\u0793\3\2\2\2\u078e\u078f\7S\2\2\u078f\u0790")
        buf.write("\5\u00aeX\2\u0790\u0791\5\u0132\u009a\2\u0791\u0793\3")
        buf.write("\2\2\2\u0792\u078a\3\2\2\2\u0792\u078e\3\2\2\2\u0793\u0131")
        buf.write("\3\2\2\2\u0794\u0796\5\u0162\u00b2\2\u0795\u0794\3\2\2")
        buf.write("\2\u0795\u0796\3\2\2\2\u0796\u0797\3\2\2\2\u0797\u0798")
        buf.write("\7\f\2\2\u0798\u0799\5\u00aeX\2\u0799\u0133\3\2\2\2\u079a")
        buf.write("\u079c\5\u0162\u00b2\2\u079b\u079a\3\2\2\2\u079b\u079c")
        buf.write("\3\2\2\2\u079c\u079d\3\2\2\2\u079d\u079e\7S\2\2\u079e")
        buf.write("\u079f\5\u00aeX\2\u079f\u0135\3\2\2\2\u07a0\u07b7\7\u0089")
        buf.write("\2\2\u07a1\u07b7\7\u008a\2\2\u07a2\u07b7\7\u0091\2\2\u07a3")
        buf.write("\u07b7\7\u0092\2\2\u07a4\u07b7\7\u0099\2\2\u07a5\u07b7")
        buf.write("\7\u009a\2\2\u07a6\u07b7\7b\2\2\u07a7\u07b7\7,\2\2\u07a8")
        buf.write("\u07b7\7\u008b\2\2\u07a9\u07b7\7\u008c\2\2\u07aa\u07b7")
        buf.write("\7\u008d\2\2\u07ab\u07b7\7\u008e\2\2\u07ac\u07b7\7\u008f")
        buf.write("\2\2\u07ad\u07b7\7\u0090\2\2\u07ae\u07b7\7\u00aa\2\2\u07af")
        buf.write("\u07b7\5\u017c\u00bf\2\u07b0\u07b7\7\u009e\2\2\u07b1\u07b7")
        buf.write("\7\u009f\2\2\u07b2\u07b7\7\u0095\2\2\u07b3\u07b7\7\u0094")
        buf.write("\2\2\u07b4\u07b7\7\u00a1\2\2\u07b5\u07b7\7\u00a0\2\2\u07b6")
        buf.write("\u07a0\3\2\2\2\u07b6\u07a1\3\2\2\2\u07b6\u07a2\3\2\2\2")
        buf.write("\u07b6\u07a3\3\2\2\2\u07b6\u07a4\3\2\2\2\u07b6\u07a5\3")
        buf.write("\2\2\2\u07b6\u07a6\3\2\2\2\u07b6\u07a7\3\2\2\2\u07b6\u07a8")
        buf.write("\3\2\2\2\u07b6\u07a9\3\2\2\2\u07b6\u07aa\3\2\2\2\u07b6")
        buf.write("\u07ab\3\2\2\2\u07b6\u07ac\3\2\2\2\u07b6\u07ad\3\2\2\2")
        buf.write("\u07b6\u07ae\3\2\2\2\u07b6\u07af\3\2\2\2\u07b6\u07b0\3")
        buf.write("\2\2\2\u07b6\u07b1\3\2\2\2\u07b6\u07b2\3\2\2\2\u07b6\u07b3")
        buf.write("\3\2\2\2\u07b6\u07b4\3\2\2\2\u07b6\u07b5\3\2\2\2\u07b7")
        buf.write("\u0137\3\2\2\2\u07b8\u07b9\t\r\2\2\u07b9\u07ba\7H\2\2")
        buf.write("\u07ba\u07bb\5\6\4\2\u07bb\u07bc\7\u0083\2\2\u07bc\u07bd")
        buf.write("\5\u01b0\u00d9\2\u07bd\u07be\7\u0084\2\2\u07be\u0139\3")
        buf.write("\2\2\2\u07bf\u07c0\7\u0087\2\2\u07c0\u07c1\t\16\2\2\u07c1")
        buf.write("\u07c3\7\u0083\2\2\u07c2\u07c4\5\32\16\2\u07c3\u07c2\3")
        buf.write("\2\2\2\u07c3\u07c4\3\2\2\2\u07c4\u07c5\3\2\2\2\u07c5\u07c6")
        buf.write("\7\u0084\2\2\u07c6\u013b\3\2\2\2\u07c7\u07ca\5\u00aeX")
        buf.write("\2\u07c8\u07ca\7\u0088\2\2\u07c9\u07c7\3\2\2\2\u07c9\u07c8")
        buf.write("\3\2\2\2\u07ca\u013d\3\2\2\2\u07cb\u07cc\7\u0087\2\2\u07cc")
        buf.write("\u07cd\5\u00f0y\2\u07cd\u013f\3\2\2\2\u07ce\u07d2\7\177")
        buf.write("\2\2\u07cf\u07d1\5\u0142\u00a2\2\u07d0\u07cf\3\2\2\2\u07d1")
        buf.write("\u07d4\3\2\2\2\u07d2\u07d0\3\2\2\2\u07d2\u07d3\3\2\2\2")
        buf.write("\u07d3\u07d5\3\2\2\2\u07d4\u07d2\3\2\2\2\u07d5\u07d6\7")
        buf.write("\u0080\2\2\u07d6\u0141\3\2\2\2\u07d7\u07d9\5\u0162\u00b2")
        buf.write("\2\u07d8\u07d7\3\2\2\2\u07d8\u07d9\3\2\2\2\u07d9\u07db")
        buf.write("\3\2\2\2\u07da\u07dc\5\u0104\u0083\2\u07db\u07da\3\2\2")
        buf.write("\2\u07db\u07dc\3\2\2\2\u07dc\u07e7\3\2\2\2\u07dd\u07e8")
        buf.write("\5\u0108\u0085\2\u07de\u07df\7.\2\2\u07df\u07e1\5\6\4")
        buf.write("\2\u07e0\u07e2\5\u0176\u00bc\2\u07e1\u07e0\3\2\2\2\u07e2")
        buf.write("\u07e3\3\2\2\2\u07e3\u07e1\3\2\2\2\u07e3\u07e4\3\2\2\2")
        buf.write("\u07e4\u07e5\3\2\2\2\u07e5\u07e6\7\u0088\2\2\u07e6\u07e8")
        buf.write("\3\2\2\2\u07e7\u07dd\3\2\2\2\u07e7\u07de\3\2\2\2\u07e8")
        buf.write("\u0143\3\2\2\2\u07e9\u07f1\5\b\5\2\u07ea\u07ec\t\17\2")
        buf.write("\2\u07eb\u07ea\3\2\2\2\u07ec\u07ef\3\2\2\2\u07ed\u07eb")
        buf.write("\3\2\2\2\u07ed\u07ee\3\2\2\2\u07ee\u07f0\3\2\2\2\u07ef")
        buf.write("\u07ed\3\2\2\2\u07f0\u07f2\5\u0146\u00a4\2\u07f1\u07ed")
        buf.write("\3\2\2\2\u07f2\u07f3\3\2\2\2\u07f3\u07f1\3\2\2\2\u07f3")
        buf.write("\u07f4\3\2\2\2\u07f4\u0145\3\2\2\2\u07f5\u07f9\7\u0081")
        buf.write("\2\2\u07f6\u07f8\7\u0086\2\2\u07f7\u07f6\3\2\2\2\u07f8")
        buf.write("\u07fb\3\2\2\2\u07f9\u07f7\3\2\2\2\u07f9\u07fa\3\2\2\2")
        buf.write("\u07fa\u07fc\3\2\2\2\u07fb\u07f9\3\2\2\2\u07fc\u07fd\7")
        buf.write("\u0082\2\2\u07fd\u0147\3\2\2\2\u07fe\u080a\7\177\2\2\u07ff")
        buf.write("\u0804\5\u0114\u008b\2\u0800\u0801\7\u0086\2\2\u0801\u0803")
        buf.write("\5\u0114\u008b\2\u0802\u0800\3\2\2\2\u0803\u0806\3\2\2")
        buf.write("\2\u0804\u0802\3\2\2\2\u0804\u0805\3\2\2\2\u0805\u0808")
        buf.write("\3\2\2\2\u0806\u0804\3\2\2\2\u0807\u0809\7\u0086\2\2\u0808")
        buf.write("\u0807\3\2\2\2\u0808\u0809\3\2\2\2\u0809\u080b\3\2\2\2")
        buf.write("\u080a\u07ff\3\2\2\2\u080a\u080b\3\2\2\2\u080b\u080c\3")
        buf.write("\2\2\2\u080c\u080d\7\u0080\2\2\u080d\u0149\3\2\2\2\u080e")
        buf.write("\u080f\7\u0094\2\2\u080f\u0814\5\u014c\u00a7\2\u0810\u0811")
        buf.write("\7\u0086\2\2\u0811\u0813\5\u014c\u00a7\2\u0812\u0810\3")
        buf.write("\2\2\2\u0813\u0816\3\2\2\2\u0814\u0812\3\2\2\2\u0814\u0815")
        buf.write("\3\2\2\2\u0815\u0817\3\2\2\2\u0816\u0814\3\2\2\2\u0817")
        buf.write("\u0818\7\u0095\2\2\u0818\u014b\3\2\2\2\u0819\u081b\5\u0162")
        buf.write("\u00b2\2\u081a\u0819\3\2\2\2\u081a\u081b\3\2\2\2\u081b")
        buf.write("\u081d\3\2\2\2\u081c\u081e\5\u014e\u00a8\2\u081d\u081c")
        buf.write("\3\2\2\2\u081d\u081e\3\2\2\2\u081e\u081f\3\2\2\2\u081f")
        buf.write("\u0820\5\u01b6\u00dc\2\u0820\u014d\3\2\2\2\u0821\u0822")
        buf.write("\t\20\2\2\u0822\u014f\3\2\2\2\u0823\u0824\7\u0087\2\2")
        buf.write("\u0824\u0825\5\u00f0y\2\u0825\u0151\3\2\2\2\u0826\u082a")
        buf.write("\7\177\2\2\u0827\u0829\5\u0154\u00ab\2\u0828\u0827\3\2")
        buf.write("\2\2\u0829\u082c\3\2\2\2\u082a\u0828\3\2\2\2\u082a\u082b")
        buf.write("\3\2\2\2\u082b\u082d\3\2\2\2\u082c\u082a\3\2\2\2\u082d")
        buf.write("\u082e\7\u0080\2\2\u082e\u0153\3\2\2\2\u082f\u0831\5\u0162")
        buf.write("\u00b2\2\u0830\u082f\3\2\2\2\u0830\u0831\3\2\2\2\u0831")
        buf.write("\u0833\3\2\2\2\u0832\u0834\7D\2\2\u0833\u0832\3\2\2\2")
        buf.write("\u0833\u0834\3\2\2\2\u0834\u0874\3\2\2\2\u0835\u0837\7")
        buf.write("i\2\2\u0836\u0835\3\2\2\2\u0836\u0837\3\2\2\2\u0837\u083d")
        buf.write("\3\2\2\2\u0838\u083e\7R\2\2\u0839\u083a\7R\2\2\u083a\u083e")
        buf.write("\7Q\2\2\u083b\u083c\7Q\2\2\u083c\u083e\7R\2\2\u083d\u0838")
        buf.write("\3\2\2\2\u083d\u0839\3\2\2\2\u083d\u083b\3\2\2\2\u083d")
        buf.write("\u083e\3\2\2\2\u083e\u083f\3\2\2\2\u083f\u085b\5\6\4\2")
        buf.write("\u0840\u0842\5\u01b6\u00dc\2\u0841\u0843\5\u00eav\2\u0842")
        buf.write("\u0841\3\2\2\2\u0842\u0843\3\2\2\2\u0843\u0844\3\2\2\2")
        buf.write("\u0844\u0846\7\u0083\2\2\u0845\u0847\5\u011c\u008f\2\u0846")
        buf.write("\u0845\3\2\2\2\u0846\u0847\3\2\2\2\u0847\u0848\3\2\2\2")
        buf.write("\u0848\u084a\7\u0084\2\2\u0849\u084b\5\u00f2z\2\u084a")
        buf.write("\u0849\3\2\2\2\u084a\u084b\3\2\2\2\u084b\u084c\3\2\2\2")
        buf.write("\u084c\u084d\7\u0088\2\2\u084d\u085c\3\2\2\2\u084e\u084f")
        buf.write("\5\u01b6\u00dc\2\u084f\u0850\7\177\2\2\u0850\u0851\5\u0156")
        buf.write("\u00ac\2\u0851\u0852\7\u0080\2\2\u0852\u085c\3\2\2\2\u0853")
        buf.write("\u0854\7`\2\2\u0854\u0855\7\u0081\2\2\u0855\u0856\5\u011c")
        buf.write("\u008f\2\u0856\u0857\7\u0082\2\2\u0857\u0858\7\177\2\2")
        buf.write("\u0858\u0859\5\u0156\u00ac\2\u0859\u085a\7\u0080\2\2\u085a")
        buf.write("\u085c\3\2\2\2\u085b\u0840\3\2\2\2\u085b\u084e\3\2\2\2")
        buf.write("\u085b\u0853\3\2\2\2\u085c\u0875\3\2\2\2\u085d\u085f\7")
        buf.write("i\2\2\u085e\u085d\3\2\2\2\u085e\u085f\3\2\2\2\u085f\u0860")
        buf.write("\3\2\2\2\u0860\u0861\7n\2\2\u0861\u0863\5\u01b6\u00dc")
        buf.write("\2\u0862\u0864\5\u00eav\2\u0863\u0862\3\2\2\2\u0863\u0864")
        buf.write("\3\2\2\2\u0864\u0865\3\2\2\2\u0865\u0867\7\u0083\2\2\u0866")
        buf.write("\u0868\5\u011c\u008f\2\u0867\u0866\3\2\2\2\u0867\u0868")
        buf.write("\3\2\2\2\u0868\u0869\3\2\2\2\u0869\u086b\7\u0084\2\2\u086a")
        buf.write("\u086c\5\u00f2z\2\u086b\u086a\3\2\2\2\u086b\u086c\3\2")
        buf.write("\2\2\u086c\u086d\3\2\2\2\u086d\u086e\7\u0088\2\2\u086e")
        buf.write("\u0875\3\2\2\2\u086f\u0870\7)\2\2\u0870\u0871\5\6\4\2")
        buf.write("\u0871\u0872\5\u01b6\u00dc\2\u0872\u0873\7\u0088\2\2\u0873")
        buf.write("\u0875\3\2\2\2\u0874\u0836\3\2\2\2\u0874\u085e\3\2\2\2")
        buf.write("\u0874\u086f\3\2\2\2\u0875\u0155\3\2\2\2\u0876\u0878\5")
        buf.write("\u0162\u00b2\2\u0877\u0876\3\2\2\2\u0877\u0878\3\2\2\2")
        buf.write("\u0878\u088b\3\2\2\2\u0879\u087a\7\63\2\2\u087a\u0880")
        buf.write("\7\u0088\2\2\u087b\u087d\5\u0162\u00b2\2\u087c\u087b\3")
        buf.write("\2\2\2\u087c\u087d\3\2\2\2\u087d\u087e\3\2\2\2\u087e\u087f")
        buf.write("\7X\2\2\u087f\u0881\7\u0088\2\2\u0880\u087c\3\2\2\2\u0880")
        buf.write("\u0881\3\2\2\2\u0881\u088c\3\2\2\2\u0882\u0883\7X\2\2")
        buf.write("\u0883\u0889\7\u0088\2\2\u0884\u0886\5\u0162\u00b2\2\u0885")
        buf.write("\u0884\3\2\2\2\u0885\u0886\3\2\2\2\u0886\u0887\3\2\2\2")
        buf.write("\u0887\u0888\7\63\2\2\u0888\u088a\7\u0088\2\2\u0889\u0885")
        buf.write("\3\2\2\2\u0889\u088a\3\2\2\2\u088a\u088c\3\2\2\2\u088b")
        buf.write("\u0879\3\2\2\2\u088b\u0882\3\2\2\2\u088c\u0157\3\2\2\2")
        buf.write("\u088d\u088e\7\u0087\2\2\u088e\u088f\5\6\4\2\u088f\u0159")
        buf.write("\3\2\2\2\u0890\u089c\7\177\2\2\u0891\u0896\5\u015c\u00af")
        buf.write("\2\u0892\u0893\7\u0086\2\2\u0893\u0895\5\u015c\u00af\2")
        buf.write("\u0894\u0892\3\2\2\2\u0895\u0898\3\2\2\2\u0896\u0894\3")
        buf.write("\2\2\2\u0896\u0897\3\2\2\2\u0897\u089a\3\2\2\2\u0898\u0896")
        buf.write("\3\2\2\2\u0899\u089b\7\u0086\2\2\u089a\u0899\3\2\2\2\u089a")
        buf.write("\u089b\3\2\2\2\u089b\u089d\3\2\2\2\u089c\u0891\3\2\2\2")
        buf.write("\u089c\u089d\3\2\2\2\u089d\u089e\3\2\2\2\u089e\u089f\7")
        buf.write("\u0080\2\2\u089f\u015b\3\2\2\2\u08a0\u08a2\5\u0162\u00b2")
        buf.write("\2\u08a1\u08a0\3\2\2\2\u08a1\u08a2\3\2\2\2\u08a2\u08a3")
        buf.write("\3\2\2\2\u08a3\u08a6\5\u01b6\u00dc\2\u08a4\u08a5\7\u0093")
        buf.write("\2\2\u08a5\u08a7\5\36\20\2\u08a6\u08a4\3\2\2\2\u08a6\u08a7")
        buf.write("\3\2\2\2\u08a7\u015d\3\2\2\2\u08a8\u08a9\7\u0081\2\2\u08a9")
        buf.write("\u08aa\5\u0160\u00b1\2\u08aa\u08ab\7\u0087\2\2\u08ab\u08ad")
        buf.write("\5\u0168\u00b5\2\u08ac\u08ae\7\u0086\2\2\u08ad\u08ac\3")
        buf.write("\2\2\2\u08ad\u08ae\3\2\2\2\u08ae\u08af\3\2\2\2\u08af\u08b0")
        buf.write("\7\u0082\2\2\u08b0\u015f\3\2\2\2\u08b1\u08b4\5\u0190\u00c9")
        buf.write("\2\u08b2\u08b4\5\u01b6\u00dc\2\u08b3\u08b1\3\2\2\2\u08b3")
        buf.write("\u08b2\3\2\2\2\u08b4\u0161\3\2\2\2\u08b5\u08b7\5\u0164")
        buf.write("\u00b3\2\u08b6\u08b5\3\2\2\2\u08b7\u08b8\3\2\2\2\u08b8")
        buf.write("\u08b6\3\2\2\2\u08b8\u08b9\3\2\2\2\u08b9\u0163\3\2\2\2")
        buf.write("\u08ba\u08be\7\u0081\2\2\u08bb\u08bc\5\u0166\u00b4\2\u08bc")
        buf.write("\u08bd\7\u0087\2\2\u08bd\u08bf\3\2\2\2\u08be\u08bb\3\2")
        buf.write("\2\2\u08be\u08bf\3\2\2\2\u08bf\u08c0\3\2\2\2\u08c0\u08c2")
        buf.write("\5\u0168\u00b5\2\u08c1\u08c3\7\u0086\2\2\u08c2\u08c1\3")
        buf.write("\2\2\2\u08c2\u08c3\3\2\2\2\u08c3\u08c4\3\2\2\2\u08c4\u08c5")
        buf.write("\7\u0082\2\2\u08c5\u0165\3\2\2\2\u08c6\u08c9\5\u0190\u00c9")
        buf.write("\2\u08c7\u08c9\5\u01b6\u00dc\2\u08c8\u08c6\3\2\2\2\u08c8")
        buf.write("\u08c7\3\2\2\2\u08c9\u0167\3\2\2\2\u08ca\u08cf\5\u016a")
        buf.write("\u00b6\2\u08cb\u08cc\7\u0086\2\2\u08cc\u08ce\5\u016a\u00b6")
        buf.write("\2\u08cd\u08cb\3\2\2\2\u08ce\u08d1\3\2\2\2\u08cf\u08cd")
        buf.write("\3\2\2\2\u08cf\u08d0\3\2\2\2\u08d0\u0169\3\2\2\2\u08d1")
        buf.write("\u08cf\3\2\2\2\u08d2\u08df\5\4\3\2\u08d3\u08dc\7\u0083")
        buf.write("\2\2\u08d4\u08d9\5\u016c\u00b7\2\u08d5\u08d6\7\u0086\2")
        buf.write("\2\u08d6\u08d8\5\u016c\u00b7\2\u08d7\u08d5\3\2\2\2\u08d8")
        buf.write("\u08db\3\2\2\2\u08d9\u08d7\3\2\2\2\u08d9\u08da\3\2\2\2")
        buf.write("\u08da\u08dd\3\2\2\2\u08db\u08d9\3\2\2\2\u08dc\u08d4\3")
        buf.write("\2\2\2\u08dc\u08dd\3\2\2\2\u08dd\u08de\3\2\2\2\u08de\u08e0")
        buf.write("\7\u0084\2\2\u08df\u08d3\3\2\2\2\u08df\u08e0\3\2\2\2\u08e0")
        buf.write("\u016b\3\2\2\2\u08e1\u08e2\5\u01b6\u00dc\2\u08e2\u08e3")
        buf.write("\7\u0087\2\2\u08e3\u08e5\3\2\2\2\u08e4\u08e1\3\2\2\2\u08e4")
        buf.write("\u08e5\3\2\2\2\u08e5\u08e6\3\2\2\2\u08e6\u08e7\5\36\20")
        buf.write("\2\u08e7\u016d\3\2\2\2\u08e8\u08eb\5\16\b\2\u08e9\u08eb")
        buf.write("\5\26\f\2\u08ea\u08e8\3\2\2\2\u08ea\u08e9\3\2\2\2\u08eb")
        buf.write("\u08f0\3\2\2\2\u08ec\u08ef\5\u0146\u00a4\2\u08ed\u08ef")
        buf.write("\7\u0096\2\2\u08ee\u08ec\3\2\2\2\u08ee\u08ed\3\2\2\2\u08ef")
        buf.write("\u08f2\3\2\2\2\u08f0\u08ee\3\2\2\2\u08f0\u08f1\3\2\2\2")
        buf.write("\u08f1\u08f3\3\2\2\2\u08f2\u08f0\3\2\2\2\u08f3\u08f4\7")
        buf.write("\u008b\2\2\u08f4\u08f8\3\2\2\2\u08f5\u08f6\7n\2\2\u08f6")
        buf.write("\u08f8\7\u008b\2\2\u08f7\u08ea\3\2\2\2\u08f7\u08f5\3\2")
        buf.write("\2\2\u08f8\u016f\3\2\2\2\u08f9\u08fe\5\u0172\u00ba\2\u08fa")
        buf.write("\u08fb\7\u0086\2\2\u08fb\u08fd\5\u0172\u00ba\2\u08fc\u08fa")
        buf.write("\3\2\2\2\u08fd\u0900\3\2\2\2\u08fe\u08fc\3\2\2\2\u08fe")
        buf.write("\u08ff\3\2\2\2\u08ff\u0171\3\2\2\2\u0900\u08fe\3\2\2\2")
        buf.write("\u0901\u0902\5\u01b6\u00dc\2\u0902\u0903\7\u0093\2\2\u0903")
        buf.write("\u0904\5\u0174\u00bb\2\u0904\u0173\3\2\2\2\u0905\u0907")
        buf.write("\7\u008e\2\2\u0906\u0905\3\2\2\2\u0906\u0907\3\2\2\2\u0907")
        buf.write("\u0908\3\2\2\2\u0908\u090b\5\36\20\2\u0909\u090b\5\u0178")
        buf.write("\u00bd\2\u090a\u0906\3\2\2\2\u090a\u0909\3\2\2\2\u090b")
        buf.write("\u0175\3\2\2\2\u090c\u090d\5\u01b6\u00dc\2\u090d\u090e")
        buf.write("\7\u0081\2\2\u090e\u090f\5\36\20\2\u090f\u0910\7\u0082")
        buf.write("\2\2\u0910\u0177\3\2\2\2\u0911\u0912\7[\2\2\u0912\u0913")
        buf.write("\5\6\4\2\u0913\u0914\7\u0081\2\2\u0914\u0915\5\36\20\2")
        buf.write("\u0915\u0916\7\u0082\2\2\u0916\u092f\3\2\2\2\u0917\u0919")
        buf.write("\7[\2\2\u0918\u091a\5\6\4\2\u0919\u0918\3\2\2\2\u0919")
        buf.write("\u091a\3\2\2\2\u091a\u091b\3\2\2\2\u091b\u091d\7\u0081")
        buf.write("\2\2\u091c\u091e\5\36\20\2\u091d\u091c\3\2\2\2\u091d\u091e")
        buf.write("\3\2\2\2\u091e\u091f\3\2\2\2\u091f\u0920\7\u0082\2\2\u0920")
        buf.write("\u0921\7\177\2\2\u0921\u0926\5\36\20\2\u0922\u0923\7\u0086")
        buf.write("\2\2\u0923\u0925\5\36\20\2\u0924\u0922\3\2\2\2\u0925\u0928")
        buf.write("\3\2\2\2\u0926\u0924\3\2\2\2\u0926\u0927\3\2\2\2\u0927")
        buf.write("\u092a\3\2\2\2\u0928\u0926\3\2\2\2\u0929\u092b\7\u0086")
        buf.write("\2\2\u092a\u0929\3\2\2\2\u092a\u092b\3\2\2\2\u092b\u092c")
        buf.write("\3\2\2\2\u092c\u092d\7\u0080\2\2\u092d\u092f\3\2\2\2\u092e")
        buf.write("\u0911\3\2\2\2\u092e\u0917\3\2\2\2\u092f\u0179\3\2\2\2")
        buf.write("\u0930\u0931\7\u0093\2\2\u0931\u0932\7\u0095\2\2\u0932")
        buf.write("\u0933\6\u00be\3\3\u0933\u017b\3\2\2\2\u0934\u0935\7\u0095")
        buf.write("\2\2\u0935\u0936\7\u0095\2\2\u0936\u0937\6\u00bf\4\3\u0937")
        buf.write("\u017d\3\2\2\2\u0938\u0939\7\u0095\2\2\u0939\u093a\7\u00a1")
        buf.write("\2\2\u093a\u093b\6\u00c0\5\3\u093b\u017f\3\2\2\2\u093c")
        buf.write("\u0945\5\u0182\u00c2\2\u093d\u0945\5\u0184\u00c3\2\u093e")
        buf.write("\u0945\7v\2\2\u093f\u0945\7w\2\2\u0940\u0945\7x\2\2\u0941")
        buf.write("\u0945\7y\2\2\u0942\u0945\7z\2\2\u0943\u0945\7E\2\2\u0944")
        buf.write("\u093c\3\2\2\2\u0944\u093d\3\2\2\2\u0944\u093e\3\2\2\2")
        buf.write("\u0944\u093f\3\2\2\2\u0944\u0940\3\2\2\2\u0944\u0941\3")
        buf.write("\2\2\2\u0944\u0942\3\2\2\2\u0944\u0943\3\2\2\2\u0945\u0181")
        buf.write("\3\2\2\2\u0946\u0947\t\21\2\2\u0947\u0183\3\2\2\2\u0948")
        buf.write("\u094d\5\u0186\u00c4\2\u0949\u094d\5\u0188\u00c5\2\u094a")
        buf.write("\u094d\7{\2\2\u094b\u094d\7|\2\2\u094c\u0948\3\2\2\2\u094c")
        buf.write("\u0949\3\2\2\2\u094c\u094a\3\2\2\2\u094c\u094b\3\2\2\2")
        buf.write("\u094d\u0185\3\2\2\2\u094e\u0952\7}\2\2\u094f\u0951\5")
        buf.write("\u018a\u00c6\2\u0950\u094f\3\2\2\2\u0951\u0954\3\2\2\2")
        buf.write("\u0952\u0950\3\2\2\2\u0952\u0953\3\2\2\2\u0953\u0955\3")
        buf.write("\2\2\2\u0954\u0952\3\2\2\2\u0955\u0956\7\u00b2\2\2\u0956")
        buf.write("\u0187\3\2\2\2\u0957\u095b\7~\2\2\u0958\u095a\5\u018c")
        buf.write("\u00c7\2\u0959\u0958\3\2\2\2\u095a\u095d\3\2\2\2\u095b")
        buf.write("\u0959\3\2\2\2\u095b\u095c\3\2\2\2\u095c\u095e\3\2\2\2")
        buf.write("\u095d\u095b\3\2\2\2\u095e\u095f\7\u00b2\2\2\u095f\u0189")
        buf.write("\3\2\2\2\u0960\u0965\5\u018e\u00c8\2\u0961\u0965\7\u00ae")
        buf.write("\2\2\u0962\u0965\7\u00b0\2\2\u0963\u0965\7\u00b3\2\2\u0964")
        buf.write("\u0960\3\2\2\2\u0964\u0961\3\2\2\2\u0964\u0962\3\2\2\2")
        buf.write("\u0964\u0963\3\2\2\2\u0965\u018b\3\2\2\2\u0966\u096b\5")
        buf.write("\u018e\u00c8\2\u0967\u096b\7\u00ae\2\2\u0968\u096b\7\u00b1")
        buf.write("\2\2\u0969\u096b\7\u00b4\2\2\u096a\u0966\3\2\2\2\u096a")
        buf.write("\u0967\3\2\2\2\u096a\u0968\3\2\2\2\u096a\u0969\3\2\2\2")
        buf.write("\u096b\u018d\3\2\2\2\u096c\u0971\5\36\20\2\u096d\u096e")
        buf.write("\7\u0086\2\2\u096e\u0970\5\36\20\2\u096f\u096d\3\2\2\2")
        buf.write("\u0970\u0973\3\2\2\2\u0971\u096f\3\2\2\2\u0971\u0972\3")
        buf.write("\2\2\2\u0972\u097a\3\2\2\2\u0973\u0971\3\2\2\2\u0974\u0976")
        buf.write("\7\u0087\2\2\u0975\u0977\7\u00b6\2\2\u0976\u0975\3\2\2")
        buf.write("\2\u0977\u0978\3\2\2\2\u0978\u0976\3\2\2\2\u0978\u0979")
        buf.write("\3\2\2\2\u0979\u097b\3\2\2\2\u097a\u0974\3\2\2\2\u097a")
        buf.write("\u097b\3\2\2\2\u097b\u018f\3\2\2\2\u097c\u097d\t\22\2")
        buf.write("\2\u097d\u0191\3\2\2\2\u097e\u097f\7\34\2\2\u097f\u0981")
        buf.write("\5\u01b6\u00dc\2\u0980\u0982\5\u00eav\2\u0981\u0980\3")
        buf.write("\2\2\2\u0981\u0982\3\2\2\2\u0982\u0984\3\2\2\2\u0983\u0985")
        buf.write("\5\u00eex\2\u0984\u0983\3\2\2\2\u0984\u0985\3\2\2\2\u0985")
        buf.write("\u0987\3\2\2\2\u0986\u0988\5\u00f2z\2\u0987\u0986\3\2")
        buf.write("\2\2\u0987\u0988\3\2\2\2\u0988\u0989\3\2\2\2\u0989\u098b")
        buf.write("\5\u00fe\u0080\2\u098a\u098c\7\u0088\2\2\u098b\u098a\3")
        buf.write("\2\2\2\u098b\u098c\3\2\2\2\u098c\u0193\3\2\2\2\u098d\u098f")
        buf.write("\t\23\2\2\u098e\u098d\3\2\2\2\u098e\u098f\3\2\2\2\u098f")
        buf.write("\u0990\3\2\2\2\u0990\u0991\7^\2\2\u0991\u0993\5\u01b6")
        buf.write("\u00dc\2\u0992\u0994\5\u00eav\2\u0993\u0992\3\2\2\2\u0993")
        buf.write("\u0994\3\2\2\2\u0994\u0996\3\2\2\2\u0995\u0997\5\u013e")
        buf.write("\u00a0\2\u0996\u0995\3\2\2\2\u0996\u0997\3\2\2\2\u0997")
        buf.write("\u0999\3\2\2\2\u0998\u099a\5\u00f2z\2\u0999\u0998\3\2")
        buf.write("\2\2\u0999\u099a\3\2\2\2\u099a\u099b\3\2\2\2\u099b\u099d")
        buf.write("\5\u0140\u00a1\2\u099c\u099e\7\u0088\2\2\u099d\u099c\3")
        buf.write("\2\2\2\u099d\u099e\3\2\2\2\u099e\u0195\3\2\2\2\u099f\u09a0")
        buf.write("\7:\2\2\u09a0\u09a2\5\u01b6\u00dc\2\u09a1\u09a3\5\u014a")
        buf.write("\u00a6\2\u09a2\u09a1\3\2\2\2\u09a2\u09a3\3\2\2\2\u09a3")
        buf.write("\u09a5\3\2\2\2\u09a4\u09a6\5\u0150\u00a9\2\u09a5\u09a4")
        buf.write("\3\2\2\2\u09a5\u09a6\3\2\2\2\u09a6\u09a8\3\2\2\2\u09a7")
        buf.write("\u09a9\5\u00f2z\2\u09a8\u09a7\3\2\2\2\u09a8\u09a9\3\2")
        buf.write("\2\2\u09a9\u09aa\3\2\2\2\u09aa\u09ac\5\u00fe\u0080\2\u09ab")
        buf.write("\u09ad\7\u0088\2\2\u09ac\u09ab\3\2\2\2\u09ac\u09ad\3\2")
        buf.write("\2\2\u09ad\u0197\3\2\2\2\u09ae\u09af\7\'\2\2\u09af\u09b1")
        buf.write("\5\u01b6\u00dc\2\u09b0\u09b2\5\u0158\u00ad\2\u09b1\u09b0")
        buf.write("\3\2\2\2\u09b1\u09b2\3\2\2\2\u09b2\u09b3\3\2\2\2\u09b3")
        buf.write("\u09b5\5\u015a\u00ae\2\u09b4\u09b6\7\u0088\2\2\u09b5\u09b4")
        buf.write("\3\2\2\2\u09b5\u09b6\3\2\2\2\u09b6\u0199\3\2\2\2\u09b7")
        buf.write("\u09b8\7!\2\2\u09b8\u09b9\5\u0116\u008c\2\u09b9\u09bb")
        buf.write("\5\u01b6\u00dc\2\u09ba\u09bc\5\u014a\u00a6\2\u09bb\u09ba")
        buf.write("\3\2\2\2\u09bb\u09bc\3\2\2\2\u09bc\u09bd\3\2\2\2\u09bd")
        buf.write("\u09bf\7\u0083\2\2\u09be\u09c0\5\u011c\u008f\2\u09bf\u09be")
        buf.write("\3\2\2\2\u09bf\u09c0\3\2\2\2\u09c0\u09c1\3\2\2\2\u09c1")
        buf.write("\u09c3\7\u0084\2\2\u09c2\u09c4\5\u00f2z\2\u09c3\u09c2")
        buf.write("\3\2\2\2\u09c3\u09c4\3\2\2\2\u09c4\u09c5\3\2\2\2\u09c5")
        buf.write("\u09c6\7\u0088\2\2\u09c6\u019b\3\2\2\2\u09c7\u09c8\7)")
        buf.write("\2\2\u09c8\u09d1\5\6\4\2\u09c9\u09ca\5\u0110\u0089\2\u09ca")
        buf.write("\u09cb\7\u0088\2\2\u09cb\u09d2\3\2\2\2\u09cc\u09cd\5\u0118")
        buf.write("\u008d\2\u09cd\u09ce\7\177\2\2\u09ce\u09cf\5\u0130\u0099")
        buf.write("\2\u09cf\u09d0\7\u0080\2\2\u09d0\u09d2\3\2\2\2\u09d1\u09c9")
        buf.write("\3\2\2\2\u09d1\u09cc\3\2\2\2\u09d2\u019d\3\2\2\2\u09d3")
        buf.write("\u09d4\5\u0110\u0089\2\u09d4\u09d5\7\u0088\2\2\u09d5\u019f")
        buf.write("\3\2\2\2\u09d6\u09e4\5\u0118\u008d\2\u09d7\u09d8\7\177")
        buf.write("\2\2\u09d8\u09d9\5\u0126\u0094\2\u09d9\u09de\7\u0080\2")
        buf.write("\2\u09da\u09db\7\u0093\2\2\u09db\u09dc\5\u0114\u008b\2")
        buf.write("\u09dc\u09dd\7\u0088\2\2\u09dd\u09df\3\2\2\2\u09de\u09da")
        buf.write("\3\2\2\2\u09de\u09df\3\2\2\2\u09df\u09e5\3\2\2\2\u09e0")
        buf.write("\u09e1\5\u017a\u00be\2\u09e1\u09e2\5N(\2\u09e2\u09e3\7")
        buf.write("\u0088\2\2\u09e3\u09e5\3\2\2\2\u09e4\u09d7\3\2\2\2\u09e4")
        buf.write("\u09e0\3\2\2\2\u09e5\u01a1\3\2\2\2\u09e6\u09e7\7\35\2")
        buf.write("\2\u09e7\u09e8\5\6\4\2\u09e8\u09e9\5\u010c\u0087\2\u09e9")
        buf.write("\u09ea\7\u0088\2\2\u09ea\u01a3\3\2\2\2\u09eb\u09ec\7`")
        buf.write("\2\2\u09ec\u09ed\7\u0081\2\2\u09ed\u09ee\5\u011c\u008f")
        buf.write("\2\u09ee\u09f7\7\u0082\2\2\u09ef\u09f0\7\177\2\2\u09f0")
        buf.write("\u09f1\5\u0126\u0094\2\u09f1\u09f2\7\u0080\2\2\u09f2\u09f8")
        buf.write("\3\2\2\2\u09f3\u09f4\5\u017a\u00be\2\u09f4\u09f5\5N(\2")
        buf.write("\u09f5\u09f6\7\u0088\2\2\u09f6\u09f8\3\2\2\2\u09f7\u09ef")
        buf.write("\3\2\2\2\u09f7\u09f3\3\2\2\2\u09f8\u01a5\3\2\2\2\u09f9")
        buf.write("\u09fa\7\u0092\2\2\u09fa\u09fb\5\u01b6\u00dc\2\u09fb\u09fc")
        buf.write("\7\u0083\2\2\u09fc\u09fd\7\u0084\2\2\u09fd\u09fe\5\u013c")
        buf.write("\u009f\2\u09fe\u01a7\3\2\2\2\u09ff\u0a00\5\u01b6\u00dc")
        buf.write("\2\u0a00\u0a02\7\u0083\2\2\u0a01\u0a03\5\u011c\u008f\2")
        buf.write("\u0a02\u0a01\3\2\2\2\u0a02\u0a03\3\2\2\2\u0a03\u0a04\3")
        buf.write("\2\2\2\u0a04\u0a06\7\u0084\2\2\u0a05\u0a07\5\u013a\u009e")
        buf.write("\2\u0a06\u0a05\3\2\2\2\u0a06\u0a07\3\2\2\2\u0a07\u0a08")
        buf.write("\3\2\2\2\u0a08\u0a09\5\u013c\u009f\2\u0a09\u01a9\3\2\2")
        buf.write("\2\u0a0a\u0a0c\5\u01ac\u00d7\2\u0a0b\u0a0d\5\u00eav\2")
        buf.write("\u0a0c\u0a0b\3\2\2\2\u0a0c\u0a0d\3\2\2\2\u0a0d\u0a0e\3")
        buf.write("\2\2\2\u0a0e\u0a10\7\u0083\2\2\u0a0f\u0a11\5\u011c\u008f")
        buf.write("\2\u0a10\u0a0f\3\2\2\2\u0a10\u0a11\3\2\2\2\u0a11\u0a12")
        buf.write("\3\2\2\2\u0a12\u0a14\7\u0084\2\2\u0a13\u0a15\5\u00f2z")
        buf.write("\2\u0a14\u0a13\3\2\2\2\u0a14\u0a15\3\2\2\2\u0a15\u0a1b")
        buf.write("\3\2\2\2\u0a16\u0a1c\5\u011a\u008e\2\u0a17\u0a18\5\u017a")
        buf.write("\u00be\2\u0a18\u0a19\5N(\2\u0a19\u0a1a\7\u0088\2\2\u0a1a")
        buf.write("\u0a1c\3\2\2\2\u0a1b\u0a16\3\2\2\2\u0a1b\u0a17\3\2\2\2")
        buf.write("\u0a1c\u01ab\3\2\2\2\u0a1d\u0a23\5\u01b6\u00dc\2\u0a1e")
        buf.write("\u0a1f\5\u01b6\u00dc\2\u0a1f\u0a20\7\u0097\2\2\u0a20\u0a21")
        buf.write("\5\u01b6\u00dc\2\u0a21\u0a23\3\2\2\2\u0a22\u0a1d\3\2\2")
        buf.write("\2\u0a22\u0a1e\3\2\2\2\u0a23\u0a2b\3\2\2\2\u0a24\u0a26")
        buf.write("\5\30\r\2\u0a25\u0a24\3\2\2\2\u0a25\u0a26\3\2\2\2\u0a26")
        buf.write("\u0a27\3\2\2\2\u0a27\u0a28\7\u0085\2\2\u0a28\u0a2a\5\u01b6")
        buf.write("\u00dc\2\u0a29\u0a25\3\2\2\2\u0a2a\u0a2d\3\2\2\2\u0a2b")
        buf.write("\u0a29\3\2\2\2\u0a2b\u0a2c\3\2\2\2\u0a2c\u01ad\3\2\2\2")
        buf.write("\u0a2d\u0a2b\3\2\2\2\u0a2e\u0a2f\7H\2\2\u0a2f\u0a30\5")
        buf.write("\u0136\u009c\2\u0a30\u0a32\7\u0083\2\2\u0a31\u0a33\78")
        buf.write("\2\2\u0a32\u0a31\3\2\2\2\u0a32\u0a33\3\2\2\2\u0a33\u0a34")
        buf.write("\3\2\2\2\u0a34\u0a3a\5\u01b0\u00d9\2\u0a35\u0a37\7\u0086")
        buf.write("\2\2\u0a36\u0a38\78\2\2\u0a37\u0a36\3\2\2\2\u0a37\u0a38")
        buf.write("\3\2\2\2\u0a38\u0a39\3\2\2\2\u0a39\u0a3b\5\u01b0\u00d9")
        buf.write("\2\u0a3a\u0a35\3\2\2\2\u0a3a\u0a3b\3\2\2\2\u0a3b\u0a3c")
        buf.write("\3\2\2\2\u0a3c\u0a42\7\u0084\2\2\u0a3d\u0a43\5\u013c\u009f")
        buf.write("\2\u0a3e\u0a3f\5\u017a\u00be\2\u0a3f\u0a40\5N(\2\u0a40")
        buf.write("\u0a41\7\u0088\2\2\u0a41\u0a43\3\2\2\2\u0a42\u0a3d\3\2")
        buf.write("\2\2\u0a42\u0a3e\3\2\2\2\u0a43\u01af\3\2\2\2\u0a44\u0a45")
        buf.write("\5\6\4\2\u0a45\u0a48\5\u01b6\u00dc\2\u0a46\u0a47\7\u0093")
        buf.write("\2\2\u0a47\u0a49\5\36\20\2\u0a48\u0a46\3\2\2\2\u0a48\u0a49")
        buf.write("\3\2\2\2\u0a49\u01b1\3\2\2\2\u0a4a\u0a4c\7\u0083\2\2\u0a4b")
        buf.write("\u0a4d\5\32\16\2\u0a4c\u0a4b\3\2\2\2\u0a4c\u0a4d\3\2\2")
        buf.write("\2\u0a4d\u0a4e\3\2\2\2\u0a4e\u0a4f\7\u0084\2\2\u0a4f\u01b3")
        buf.write("\3\2\2\2\u0a50\u0a52\7\u0083\2\2\u0a51\u0a53\5\32\16\2")
        buf.write("\u0a52\u0a51\3\2\2\2\u0a52\u0a53\3\2\2\2\u0a53\u0a54\3")
        buf.write("\2\2\2\u0a54\u0a56\7\u0084\2\2\u0a55\u0a57\5\\/\2\u0a56")
        buf.write("\u0a55\3\2\2\2\u0a56\u0a57\3\2\2\2\u0a57\u01b5\3\2\2\2")
        buf.write("\u0a58\u0a59\t\24\2\2\u0a59\u01b7\3\2\2\2\u015b\u01b9")
        buf.write("\u01bc\u01bf\u01c4\u01c8\u01ce\u01d1\u01d6\u01da\u01e1")
        buf.write("\u01e3\u01eb\u01f3\u01f9\u01fd\u0202\u020c\u0214\u021e")
        buf.write("\u0224\u0227\u022c\u022f\u0235\u023a\u0244\u0251\u0259")
        buf.write("\u025f\u0261\u0268\u0270\u0278\u0280\u0288\u0290\u029a")
        buf.write("\u029c\u02a2\u02a7\u02af\u02b7\u02bf\u02c1\u02c4\u02cb")
        buf.write("\u02d0\u02d7\u02db\u02dd\u02f5\u02fe\u0303\u0307\u030f")
        buf.write("\u0312\u0317\u031b\u031f\u0325\u0333\u0339\u0345\u0349")
        buf.write("\u034e\u0352\u0358\u0360\u0369\u037b\u037e\u0383\u0386")
        buf.write("\u0395\u039b\u039f\u03a5\u03aa\u03ad\u03b5\u03bd\u03c8")
        buf.write("\u03cd\u03d2\u03d4\u03dd\u03e5\u03ec\u03f4\u03f8\u0401")
        buf.write("\u0406\u0408\u0411\u0419\u041d\u0422\u0424\u0429\u042d")
        buf.write("\u0434\u043c\u043e\u0442\u0445\u0448\u0450\u045a\u046b")
        buf.write("\u0472\u0476\u0480\u0485\u048c\u0495\u049a\u04a1\u04ad")
        buf.write("\u04b8\u04c0\u04c5\u04ce\u04d7\u04e0\u04e6\u04eb\u04ef")
        buf.write("\u04f3\u04f7\u04fb\u0502\u050a\u0517\u0521\u0537\u053b")
        buf.write("\u053f\u0544\u0558\u055d\u0562\u0569\u056c\u0582\u058e")
        buf.write("\u0592\u059a\u05a4\u05ab\u05af\u05b4\u05b7\u05bc\u05c4")
        buf.write("\u05c9\u05d0\u05d6\u05de\u05e6\u05e9\u05f0\u05f7\u05fb")
        buf.write("\u05fe\u0604\u0608\u060e\u061c\u0622\u0629\u062e\u0631")
        buf.write("\u0634\u063b\u0645\u0656\u065b\u065f\u0662\u0665\u066c")
        buf.write("\u0672\u067a\u0680\u068a\u0692\u0698\u06a3\u06a7\u06a9")
        buf.write("\u06ae\u06b2\u06b9\u06c2\u06c9\u06cc\u06cf\u06d3\u06d8")
        buf.write("\u06e5\u06ef\u06f6\u0702\u0709\u0715\u071b\u071f\u0723")
        buf.write("\u0729\u072f\u0731\u0738\u073c\u073f\u0743\u074d\u0750")
        buf.write("\u0757\u075a\u075f\u0764\u0766\u0769\u076c\u0772\u0775")
        buf.write("\u0781\u0785\u0788\u0792\u0795\u079b\u07b6\u07c3\u07c9")
        buf.write("\u07d2\u07d8\u07db\u07e3\u07e7\u07ed\u07f3\u07f9\u0804")
        buf.write("\u0808\u080a\u0814\u081a\u081d\u082a\u0830\u0833\u0836")
        buf.write("\u083d\u0842\u0846\u084a\u085b\u085e\u0863\u0867\u086b")
        buf.write("\u0874\u0877\u087c\u0880\u0885\u0889\u088b\u0896\u089a")
        buf.write("\u089c\u08a1\u08a6\u08ad\u08b3\u08b8\u08be\u08c2\u08c8")
        buf.write("\u08cf\u08d9\u08dc\u08df\u08e4\u08ea\u08ee\u08f0\u08f7")
        buf.write("\u08fe\u0906\u090a\u0919\u091d\u0926\u092a\u092e\u0944")
        buf.write("\u094c\u0952\u095b\u0964\u096a\u0971\u0978\u097a\u0981")
        buf.write("\u0984\u0987\u098b\u098e\u0993\u0996\u0999\u099d\u09a2")
        buf.write("\u09a5\u09a8\u09ac\u09b1\u09b5\u09bb\u09bf\u09c3\u09d1")
        buf.write("\u09de\u09e4\u09f7\u0a02\u0a06\u0a0c\u0a10\u0a14\u0a1b")
        buf.write("\u0a22\u0a25\u0a2b\u0a32\u0a37\u0a3a\u0a42\u0a48\u0a4c")
        buf.write("\u0a52\u0a56")
        return buf.getvalue()


class CSharpParser(CSharpParserBase):
    grammarFileName = "CSharpParser.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [DFA(ds, i) for i, ds in enumerate(atn.decisionToState)]

    sharedContextCache = PredictionContextCache()

    literalNames = ["<INVALID>", "'\u00EF\u00BB\u00BF'", "<INVALID>", "'/***/'",
                    "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>",
                    "'#'", "'abstract'", "'add'", "'alias'", "'__arglist'",
                    "'as'", "'ascending'", "'async'", "'await'", "'base'",
                    "'bool'", "'break'", "'by'", "'byte'", "'case'", "'catch'",
                    "'char'", "'checked'", "'class'", "'const'", "'continue'",
                    "'decimal'", "'default'", "'delegate'", "'descending'",
                    "'do'", "'double'", "'dynamic'", "'else'", "'enum'",
                    "'equals'", "'event'", "'explicit'", "'extern'", "'false'",
                    "'finally'", "'fixed'", "'float'", "'for'", "'foreach'",
                    "'from'", "'get'", "'goto'", "'group'", "'if'", "'implicit'",
                    "'in'", "'int'", "'interface'", "'internal'", "'into'",
                    "'is'", "'join'", "'let'", "'lock'", "'long'", "'nameof'",
                    "'namespace'", "'new'", "'null'", "'object'", "'on'",
                    "'operator'", "'orderby'", "'out'", "'override'", "'params'",
                    "'partial'", "'private'", "'protected'", "'public'",
                    "'readonly'", "'ref'", "'remove'", "'return'", "'sbyte'",
                    "'sealed'", "'select'", "'set'", "'short'", "'sizeof'",
                    "'stackalloc'", "'static'", "'string'", "'struct'",
                    "'switch'", "'this'", "'throw'", "'true'", "'try'",
                    "'typeof'", "'uint'", "'ulong'", "'unchecked'", "'unmanaged'",
                    "'unsafe'", "'ushort'", "'using'", "'var'", "'virtual'",
                    "'void'", "'volatile'", "'when'", "'where'", "'while'",
                    "'yield'", "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>",
                    "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>",
                    "<INVALID>", "<INVALID>", "<INVALID>", "'{'", "'}'",
                    "'['", "']'", "'('", "')'", "'.'", "','", "':'", "';'",
                    "'+'", "'-'", "'*'", "'/'", "'%'", "'&'", "'|'", "'^'",
                    "'!'", "'~'", "'='", "'<'", "'>'", "'?'", "'::'", "'??'",
                    "'++'", "'--'", "'&&'", "'||'", "'->'", "'=='", "'!='",
                    "'<='", "'>='", "'+='", "'-='", "'*='", "'/='", "'%='",
                    "'&='", "'|='", "'^='", "'<<'", "'<<='", "'??='", "'..'",
                    "'{{'", "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>",
                    "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>",
                    "<INVALID>", "<INVALID>", "'define'", "'undef'", "'elif'",
                    "'endif'", "'line'", "<INVALID>", "<INVALID>", "<INVALID>",
                    "<INVALID>", "<INVALID>", "<INVALID>", "'hidden'",
                    "<INVALID>", "<INVALID>", "<INVALID>", "'}}'"]

    symbolicNames = ["<INVALID>", "BYTE_ORDER_MARK", "SINGLE_LINE_DOC_COMMENT",
                     "EMPTY_DELIMITED_DOC_COMMENT", "DELIMITED_DOC_COMMENT",
                     "SINGLE_LINE_COMMENT", "DELIMITED_COMMENT", "WHITESPACES",
                     "SHARP", "ABSTRACT", "ADD", "ALIAS", "ARGLIST", "AS",
                     "ASCENDING", "ASYNC", "AWAIT", "BASE", "BOOL", "BREAK",
                     "BY", "BYTE", "CASE", "CATCH", "CHAR", "CHECKED",
                     "CLASS", "CONST", "CONTINUE", "DECIMAL", "DEFAULT",
                     "DELEGATE", "DESCENDING", "DO", "DOUBLE", "DYNAMIC",
                     "ELSE", "ENUM", "EQUALS", "EVENT", "EXPLICIT", "EXTERN",
                     "FALSE", "FINALLY", "FIXED", "FLOAT", "FOR", "FOREACH",
                     "FROM", "GET", "GOTO", "GROUP", "IF", "IMPLICIT",
                     "IN", "INT", "INTERFACE", "INTERNAL", "INTO", "IS",
                     "JOIN", "LET", "LOCK", "LONG", "NAMEOF", "NAMESPACE",
                     "NEW", "NULL_", "OBJECT", "ON", "OPERATOR", "ORDERBY",
                     "OUT", "OVERRIDE", "PARAMS", "PARTIAL", "PRIVATE",
                     "PROTECTED", "PUBLIC", "READONLY", "REF", "REMOVE",
                     "RETURN", "SBYTE", "SEALED", "SELECT", "SET", "SHORT",
                     "SIZEOF", "STACKALLOC", "STATIC", "STRING", "STRUCT",
                     "SWITCH", "THIS", "THROW", "TRUE", "TRY", "TYPEOF",
                     "UINT", "ULONG", "UNCHECKED", "UNMANAGED", "UNSAFE",
                     "USHORT", "USING", "VAR", "VIRTUAL", "VOID", "VOLATILE",
                     "WHEN", "WHERE", "WHILE", "YIELD", "IDENTIFIER", "LITERAL_ACCESS",
                     "INTEGER_LITERAL", "HEX_INTEGER_LITERAL", "BIN_INTEGER_LITERAL",
                     "REAL_LITERAL", "CHARACTER_LITERAL", "REGULAR_STRING",
                     "VERBATIUM_STRING", "INTERPOLATED_REGULAR_STRING_START",
                     "INTERPOLATED_VERBATIUM_STRING_START", "OPEN_BRACE",
                     "CLOSE_BRACE", "OPEN_BRACKET", "CLOSE_BRACKET", "OPEN_PARENS",
                     "CLOSE_PARENS", "DOT", "COMMA", "COLON", "SEMICOLON",
                     "PLUS", "MINUS", "STAR", "DIV", "PERCENT", "AMP",
                     "BITWISE_OR", "CARET", "BANG", "TILDE", "ASSIGNMENT",
                     "LT", "GT", "INTERR", "DOUBLE_COLON", "OP_COALESCING",
                     "OP_INC", "OP_DEC", "OP_AND", "OP_OR", "OP_PTR", "OP_EQ",
                     "OP_NE", "OP_LE", "OP_GE", "OP_ADD_ASSIGNMENT", "OP_SUB_ASSIGNMENT",
                     "OP_MULT_ASSIGNMENT", "OP_DIV_ASSIGNMENT", "OP_MOD_ASSIGNMENT",
                     "OP_AND_ASSIGNMENT", "OP_OR_ASSIGNMENT", "OP_XOR_ASSIGNMENT",
                     "OP_LEFT_SHIFT", "OP_LEFT_SHIFT_ASSIGNMENT", "OP_COALESCING_ASSIGNMENT",
                     "OP_RANGE", "DOUBLE_CURLY_INSIDE", "OPEN_BRACE_INSIDE",
                     "REGULAR_CHAR_INSIDE", "VERBATIUM_DOUBLE_QUOTE_INSIDE",
                     "DOUBLE_QUOTE_INSIDE", "REGULAR_STRING_INSIDE", "VERBATIUM_INSIDE_STRING",
                     "CLOSE_BRACE_INSIDE", "FORMAT_STRING", "DIRECTIVE_WHITESPACES",
                     "DIGITS", "DEFINE", "UNDEF", "ELIF", "ENDIF", "LINE",
                     "ERROR", "WARNING", "REGION", "ENDREGION", "PRAGMA",
                     "NULLABLE", "DIRECTIVE_HIDDEN", "CONDITIONAL_SYMBOL",
                     "DIRECTIVE_NEW_LINE", "TEXT", "DOUBLE_CURLY_CLOSE_INSIDE"]

    RULE_compilation_unit = 0
    RULE_namespace_or_type_name = 1
    RULE_type_ = 2
    RULE_base_type = 3
    RULE_tuple_type = 4
    RULE_tuple_element = 5
    RULE_simple_type = 6
    RULE_numeric_type = 7
    RULE_integral_type = 8
    RULE_floating_point_type = 9
    RULE_class_type = 10
    RULE_type_argument_list = 11
    RULE_argument_list = 12
    RULE_argument = 13
    RULE_expression = 14
    RULE_non_assignment_expression = 15
    RULE_assignment = 16
    RULE_assignment_operator = 17
    RULE_conditional_expression = 18
    RULE_null_coalescing_expression = 19
    RULE_conditional_or_expression = 20
    RULE_conditional_and_expression = 21
    RULE_inclusive_or_expression = 22
    RULE_exclusive_or_expression = 23
    RULE_and_expression = 24
    RULE_equality_expression = 25
    RULE_relational_expression = 26
    RULE_shift_expression = 27
    RULE_additive_expression = 28
    RULE_multiplicative_expression = 29
    RULE_switch_expression = 30
    RULE_switch_expression_arms = 31
    RULE_switch_expression_arm = 32
    RULE_range_expression = 33
    RULE_unary_expression = 34
    RULE_cast_expression = 35
    RULE_primary_expression = 36
    RULE_primary_expression_start = 37
    RULE_throwable_expression = 38
    RULE_throw_expression = 39
    RULE_member_access = 40
    RULE_bracket_expression = 41
    RULE_indexer_argument = 42
    RULE_predefined_type = 43
    RULE_expression_list = 44
    RULE_object_or_collection_initializer = 45
    RULE_object_initializer = 46
    RULE_member_initializer_list = 47
    RULE_member_initializer = 48
    RULE_initializer_value = 49
    RULE_collection_initializer = 50
    RULE_element_initializer = 51
    RULE_anonymous_object_initializer = 52
    RULE_member_declarator_list = 53
    RULE_member_declarator = 54
    RULE_unbound_type_name = 55
    RULE_generic_dimension_specifier = 56
    RULE_isType = 57
    RULE_isTypePatternArms = 58
    RULE_isTypePatternArm = 59
    RULE_lambda_expression = 60
    RULE_anonymous_function_signature = 61
    RULE_explicit_anonymous_function_parameter_list = 62
    RULE_explicit_anonymous_function_parameter = 63
    RULE_implicit_anonymous_function_parameter_list = 64
    RULE_anonymous_function_body = 65
    RULE_query_expression = 66
    RULE_from_clause = 67
    RULE_query_body = 68
    RULE_query_body_clause = 69
    RULE_let_clause = 70
    RULE_where_clause = 71
    RULE_combined_join_clause = 72
    RULE_orderby_clause = 73
    RULE_ordering = 74
    RULE_select_or_group_clause = 75
    RULE_query_continuation = 76
    RULE_statement = 77
    RULE_declarationStatement = 78
    RULE_local_function_declaration = 79
    RULE_local_function_header = 80
    RULE_local_function_modifiers = 81
    RULE_local_function_body = 82
    RULE_labeled_Statement = 83
    RULE_embedded_statement = 84
    RULE_simple_embedded_statement = 85
    RULE_block = 86
    RULE_local_variable_declaration = 87
    RULE_local_variable_type = 88
    RULE_local_variable_declarator = 89
    RULE_local_variable_initializer = 90
    RULE_local_constant_declaration = 91
    RULE_if_body = 92
    RULE_switch_section = 93
    RULE_switch_label = 94
    RULE_case_guard = 95
    RULE_statement_list = 96
    RULE_for_initializer = 97
    RULE_for_iterator = 98
    RULE_catch_clauses = 99
    RULE_specific_catch_clause = 100
    RULE_general_catch_clause = 101
    RULE_exception_filter = 102
    RULE_finally_clause = 103
    RULE_resource_acquisition = 104
    RULE_namespace_declaration = 105
    RULE_qualified_identifier = 106
    RULE_namespace_body = 107
    RULE_extern_alias_directives = 108
    RULE_extern_alias_directive = 109
    RULE_using_directives = 110
    RULE_using_directive = 111
    RULE_namespace_member_declarations = 112
    RULE_namespace_member_declaration = 113
    RULE_type_declaration = 114
    RULE_qualified_alias_member = 115
    RULE_type_parameter_list = 116
    RULE_type_parameter = 117
    RULE_class_base = 118
    RULE_interface_type_list = 119
    RULE_type_parameter_constraints_clauses = 120
    RULE_type_parameter_constraints_clause = 121
    RULE_type_parameter_constraints = 122
    RULE_primary_constraint = 123
    RULE_secondary_constraints = 124
    RULE_constructor_constraint = 125
    RULE_class_body = 126
    RULE_class_member_declarations = 127
    RULE_class_member_declaration = 128
    RULE_all_member_modifiers = 129
    RULE_all_member_modifier = 130
    RULE_common_member_declaration = 131
    RULE_typed_member_declaration = 132
    RULE_constant_declarators = 133
    RULE_constant_declarator = 134
    RULE_variable_declarators = 135
    RULE_variable_declarator = 136
    RULE_variable_initializer = 137
    RULE_return_type = 138
    RULE_member_name = 139
    RULE_method_body = 140
    RULE_formal_parameter_list = 141
    RULE_fixed_parameters = 142
    RULE_fixed_parameter = 143
    RULE_parameter_modifier = 144
    RULE_parameter_array = 145
    RULE_accessor_declarations = 146
    RULE_get_accessor_declaration = 147
    RULE_set_accessor_declaration = 148
    RULE_accessor_modifier = 149
    RULE_accessor_body = 150
    RULE_event_accessor_declarations = 151
    RULE_add_accessor_declaration = 152
    RULE_remove_accessor_declaration = 153
    RULE_overloadable_operator = 154
    RULE_conversion_operator_declarator = 155
    RULE_constructor_initializer = 156
    RULE_body = 157
    RULE_struct_interfaces = 158
    RULE_struct_body = 159
    RULE_struct_member_declaration = 160
    RULE_array_type = 161
    RULE_rank_specifier = 162
    RULE_array_initializer = 163
    RULE_variant_type_parameter_list = 164
    RULE_variant_type_parameter = 165
    RULE_variance_annotation = 166
    RULE_interface_base = 167
    RULE_interface_body = 168
    RULE_interface_member_declaration = 169
    RULE_interface_accessors = 170
    RULE_enum_base = 171
    RULE_enum_body = 172
    RULE_enum_member_declaration = 173
    RULE_global_attribute_section = 174
    RULE_global_attribute_target = 175
    RULE_attributes = 176
    RULE_attribute_section = 177
    RULE_attribute_target = 178
    RULE_attribute_list = 179
    RULE_attribute = 180
    RULE_attribute_argument = 181
    RULE_pointer_type = 182
    RULE_fixed_pointer_declarators = 183
    RULE_fixed_pointer_declarator = 184
    RULE_fixed_pointer_initializer = 185
    RULE_fixed_size_buffer_declarator = 186
    RULE_stackalloc_initializer = 187
    RULE_right_arrow = 188
    RULE_right_shift = 189
    RULE_right_shift_assignment = 190
    RULE_literal = 191
    RULE_boolean_literal = 192
    RULE_string_literal = 193
    RULE_interpolated_regular_string = 194
    RULE_interpolated_verbatium_string = 195
    RULE_interpolated_regular_string_part = 196
    RULE_interpolated_verbatium_string_part = 197
    RULE_interpolated_string_expression = 198
    RULE_keyword = 199
    RULE_class_definition = 200
    RULE_struct_definition = 201
    RULE_interface_definition = 202
    RULE_enum_definition = 203
    RULE_delegate_definition = 204
    RULE_event_declaration = 205
    RULE_field_declaration = 206
    RULE_property_declaration = 207
    RULE_constant_declaration = 208
    RULE_indexer_declaration = 209
    RULE_destructor_definition = 210
    RULE_constructor_declaration = 211
    RULE_method_declaration = 212
    RULE_method_member_name = 213
    RULE_operator_declaration = 214
    RULE_arg_declaration = 215
    RULE_method_invocation = 216
    RULE_object_creation_expression = 217
    RULE_identifier = 218

    ruleNames = ["compilation_unit", "namespace_or_type_name", "type_",
                 "base_type", "tuple_type", "tuple_element", "simple_type",
                 "numeric_type", "integral_type", "floating_point_type",
                 "class_type", "type_argument_list", "argument_list",
                 "argument", "expression", "non_assignment_expression",
                 "assignment", "assignment_operator", "conditional_expression",
                 "null_coalescing_expression", "conditional_or_expression",
                 "conditional_and_expression", "inclusive_or_expression",
                 "exclusive_or_expression", "and_expression", "equality_expression",
                 "relational_expression", "shift_expression", "additive_expression",
                 "multiplicative_expression", "switch_expression", "switch_expression_arms",
                 "switch_expression_arm", "range_expression", "unary_expression",
                 "cast_expression", "primary_expression", "primary_expression_start",
                 "throwable_expression", "throw_expression", "member_access",
                 "bracket_expression", "indexer_argument", "predefined_type",
                 "expression_list", "object_or_collection_initializer",
                 "object_initializer", "member_initializer_list", "member_initializer",
                 "initializer_value", "collection_initializer", "element_initializer",
                 "anonymous_object_initializer", "member_declarator_list",
                 "member_declarator", "unbound_type_name", "generic_dimension_specifier",
                 "isType", "isTypePatternArms", "isTypePatternArm", "lambda_expression",
                 "anonymous_function_signature", "explicit_anonymous_function_parameter_list",
                 "explicit_anonymous_function_parameter", "implicit_anonymous_function_parameter_list",
                 "anonymous_function_body", "query_expression", "from_clause",
                 "query_body", "query_body_clause", "let_clause", "where_clause",
                 "combined_join_clause", "orderby_clause", "ordering",
                 "select_or_group_clause", "query_continuation", "statement",
                 "declarationStatement", "local_function_declaration",
                 "local_function_header", "local_function_modifiers",
                 "local_function_body", "labeled_Statement", "embedded_statement",
                 "simple_embedded_statement", "block", "local_variable_declaration",
                 "local_variable_type", "local_variable_declarator", "local_variable_initializer",
                 "local_constant_declaration", "if_body", "switch_section",
                 "switch_label", "case_guard", "statement_list", "for_initializer",
                 "for_iterator", "catch_clauses", "specific_catch_clause",
                 "general_catch_clause", "exception_filter", "finally_clause",
                 "resource_acquisition", "namespace_declaration", "qualified_identifier",
                 "namespace_body", "extern_alias_directives", "extern_alias_directive",
                 "using_directives", "using_directive", "namespace_member_declarations",
                 "namespace_member_declaration", "type_declaration", "qualified_alias_member",
                 "type_parameter_list", "type_parameter", "class_base",
                 "interface_type_list", "type_parameter_constraints_clauses",
                 "type_parameter_constraints_clause", "type_parameter_constraints",
                 "primary_constraint", "secondary_constraints", "constructor_constraint",
                 "class_body", "class_member_declarations", "class_member_declaration",
                 "all_member_modifiers", "all_member_modifier", "common_member_declaration",
                 "typed_member_declaration", "constant_declarators", "constant_declarator",
                 "variable_declarators", "variable_declarator", "variable_initializer",
                 "return_type", "member_name", "method_body", "formal_parameter_list",
                 "fixed_parameters", "fixed_parameter", "parameter_modifier",
                 "parameter_array", "accessor_declarations", "get_accessor_declaration",
                 "set_accessor_declaration", "accessor_modifier", "accessor_body",
                 "event_accessor_declarations", "add_accessor_declaration",
                 "remove_accessor_declaration", "overloadable_operator",
                 "conversion_operator_declarator", "constructor_initializer",
                 "body", "struct_interfaces", "struct_body", "struct_member_declaration",
                 "array_type", "rank_specifier", "array_initializer",
                 "variant_type_parameter_list", "variant_type_parameter",
                 "variance_annotation", "interface_base", "interface_body",
                 "interface_member_declaration", "interface_accessors",
                 "enum_base", "enum_body", "enum_member_declaration",
                 "global_attribute_section", "global_attribute_target",
                 "attributes", "attribute_section", "attribute_target",
                 "attribute_list", "attribute", "attribute_argument",
                 "pointer_type", "fixed_pointer_declarators", "fixed_pointer_declarator",
                 "fixed_pointer_initializer", "fixed_size_buffer_declarator",
                 "stackalloc_initializer", "right_arrow", "right_shift",
                 "right_shift_assignment", "literal", "boolean_literal",
                 "string_literal", "interpolated_regular_string", "interpolated_verbatium_string",
                 "interpolated_regular_string_part", "interpolated_verbatium_string_part",
                 "interpolated_string_expression", "keyword", "class_definition",
                 "struct_definition", "interface_definition", "enum_definition",
                 "delegate_definition", "event_declaration", "field_declaration",
                 "property_declaration", "constant_declaration", "indexer_declaration",
                 "destructor_definition", "constructor_declaration", "method_declaration",
                 "method_member_name", "operator_declaration", "arg_declaration",
                 "method_invocation", "object_creation_expression", "identifier"]

    EOF = Token.EOF
    BYTE_ORDER_MARK = 1
    SINGLE_LINE_DOC_COMMENT = 2
    EMPTY_DELIMITED_DOC_COMMENT = 3
    DELIMITED_DOC_COMMENT = 4
    SINGLE_LINE_COMMENT = 5
    DELIMITED_COMMENT = 6
    WHITESPACES = 7
    SHARP = 8
    ABSTRACT = 9
    ADD = 10
    ALIAS = 11
    ARGLIST = 12
    AS = 13
    ASCENDING = 14
    ASYNC = 15
    AWAIT = 16
    BASE = 17
    BOOL = 18
    BREAK = 19
    BY = 20
    BYTE = 21
    CASE = 22
    CATCH = 23
    CHAR = 24
    CHECKED = 25
    CLASS = 26
    CONST = 27
    CONTINUE = 28
    DECIMAL = 29
    DEFAULT = 30
    DELEGATE = 31
    DESCENDING = 32
    DO = 33
    DOUBLE = 34
    DYNAMIC = 35
    ELSE = 36
    ENUM = 37
    EQUALS = 38
    EVENT = 39
    EXPLICIT = 40
    EXTERN = 41
    FALSE = 42
    FINALLY = 43
    FIXED = 44
    FLOAT = 45
    FOR = 46
    FOREACH = 47
    FROM = 48
    GET = 49
    GOTO = 50
    GROUP = 51
    IF = 52
    IMPLICIT = 53
    IN = 54
    INT = 55
    INTERFACE = 56
    INTERNAL = 57
    INTO = 58
    IS = 59
    JOIN = 60
    LET = 61
    LOCK = 62
    LONG = 63
    NAMEOF = 64
    NAMESPACE = 65
    NEW = 66
    NULL_ = 67
    OBJECT = 68
    ON = 69
    OPERATOR = 70
    ORDERBY = 71
    OUT = 72
    OVERRIDE = 73
    PARAMS = 74
    PARTIAL = 75
    PRIVATE = 76
    PROTECTED = 77
    PUBLIC = 78
    READONLY = 79
    REF = 80
    REMOVE = 81
    RETURN = 82
    SBYTE = 83
    SEALED = 84
    SELECT = 85
    SET = 86
    SHORT = 87
    SIZEOF = 88
    STACKALLOC = 89
    STATIC = 90
    STRING = 91
    STRUCT = 92
    SWITCH = 93
    THIS = 94
    THROW = 95
    TRUE = 96
    TRY = 97
    TYPEOF = 98
    UINT = 99
    ULONG = 100
    UNCHECKED = 101
    UNMANAGED = 102
    UNSAFE = 103
    USHORT = 104
    USING = 105
    VAR = 106
    VIRTUAL = 107
    VOID = 108
    VOLATILE = 109
    WHEN = 110
    WHERE = 111
    WHILE = 112
    YIELD = 113
    IDENTIFIER = 114
    LITERAL_ACCESS = 115
    INTEGER_LITERAL = 116
    HEX_INTEGER_LITERAL = 117
    BIN_INTEGER_LITERAL = 118
    REAL_LITERAL = 119
    CHARACTER_LITERAL = 120
    REGULAR_STRING = 121
    VERBATIUM_STRING = 122
    INTERPOLATED_REGULAR_STRING_START = 123
    INTERPOLATED_VERBATIUM_STRING_START = 124
    OPEN_BRACE = 125
    CLOSE_BRACE = 126
    OPEN_BRACKET = 127
    CLOSE_BRACKET = 128
    OPEN_PARENS = 129
    CLOSE_PARENS = 130
    DOT = 131
    COMMA = 132
    COLON = 133
    SEMICOLON = 134
    PLUS = 135
    MINUS = 136
    STAR = 137
    DIV = 138
    PERCENT = 139
    AMP = 140
    BITWISE_OR = 141
    CARET = 142
    BANG = 143
    TILDE = 144
    ASSIGNMENT = 145
    LT = 146
    GT = 147
    INTERR = 148
    DOUBLE_COLON = 149
    OP_COALESCING = 150
    OP_INC = 151
    OP_DEC = 152
    OP_AND = 153
    OP_OR = 154
    OP_PTR = 155
    OP_EQ = 156
    OP_NE = 157
    OP_LE = 158
    OP_GE = 159
    OP_ADD_ASSIGNMENT = 160
    OP_SUB_ASSIGNMENT = 161
    OP_MULT_ASSIGNMENT = 162
    OP_DIV_ASSIGNMENT = 163
    OP_MOD_ASSIGNMENT = 164
    OP_AND_ASSIGNMENT = 165
    OP_OR_ASSIGNMENT = 166
    OP_XOR_ASSIGNMENT = 167
    OP_LEFT_SHIFT = 168
    OP_LEFT_SHIFT_ASSIGNMENT = 169
    OP_COALESCING_ASSIGNMENT = 170
    OP_RANGE = 171
    DOUBLE_CURLY_INSIDE = 172
    OPEN_BRACE_INSIDE = 173
    REGULAR_CHAR_INSIDE = 174
    VERBATIUM_DOUBLE_QUOTE_INSIDE = 175
    DOUBLE_QUOTE_INSIDE = 176
    REGULAR_STRING_INSIDE = 177
    VERBATIUM_INSIDE_STRING = 178
    CLOSE_BRACE_INSIDE = 179
    FORMAT_STRING = 180
    DIRECTIVE_WHITESPACES = 181
    DIGITS = 182
    DEFINE = 183
    UNDEF = 184
    ELIF = 185
    ENDIF = 186
    LINE = 187
    ERROR = 188
    WARNING = 189
    REGION = 190
    ENDREGION = 191
    PRAGMA = 192
    NULLABLE = 193
    DIRECTIVE_HIDDEN = 194
    CONDITIONAL_SYMBOL = 195
    DIRECTIVE_NEW_LINE = 196
    TEXT = 197
    DOUBLE_CURLY_CLOSE_INSIDE = 198

    def __init__(self, input: TokenStream, output: TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.7.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None

    class Compilation_unitContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(CSharpParser.EOF, 0)

        def BYTE_ORDER_MARK(self):
            return self.getToken(CSharpParser.BYTE_ORDER_MARK, 0)

        def extern_alias_directives(self):
            return self.getTypedRuleContext(CSharpParser.Extern_alias_directivesContext, 0)

        def using_directives(self):
            return self.getTypedRuleContext(CSharpParser.Using_directivesContext, 0)

        def global_attribute_section(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(CSharpParser.Global_attribute_sectionContext)
            else:
                return self.getTypedRuleContext(CSharpParser.Global_attribute_sectionContext, i)

        def namespace_member_declarations(self):
            return self.getTypedRuleContext(CSharpParser.Namespace_member_declarationsContext, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_compilation_unit

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterCompilation_unit"):
                listener.enterCompilation_unit(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitCompilation_unit"):
                listener.exitCompilation_unit(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitCompilation_unit"):
                return visitor.visitCompilation_unit(self)
            else:
                return visitor.visitChildren(self)

    def compilation_unit(self):

        localctx = CSharpParser.Compilation_unitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_compilation_unit)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 439
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == CSharpParser.BYTE_ORDER_MARK:
                self.state = 438
                self.match(CSharpParser.BYTE_ORDER_MARK)

            self.state = 442
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 1, self._ctx)
            if la_ == 1:
                self.state = 441
                self.extern_alias_directives()

            self.state = 445
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == CSharpParser.USING:
                self.state = 444
                self.using_directives()

            self.state = 450
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input, 3, self._ctx)
            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 447
                    self.global_attribute_section()
                self.state = 452
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 3, self._ctx)

            self.state = 454
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & (
                    (1 << CSharpParser.ABSTRACT) | (1 << CSharpParser.ASYNC) | (1 << CSharpParser.CLASS) | (
                    1 << CSharpParser.DELEGATE) | (1 << CSharpParser.ENUM) | (1 << CSharpParser.EXTERN) | (
                            1 << CSharpParser.INTERFACE) | (1 << CSharpParser.INTERNAL))) != 0) or (
                    (((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & (
                    (1 << (CSharpParser.NAMESPACE - 65)) | (1 << (CSharpParser.NEW - 65)) | (
                    1 << (CSharpParser.OVERRIDE - 65)) | (1 << (CSharpParser.PARTIAL - 65)) | (
                            1 << (CSharpParser.PRIVATE - 65)) | (1 << (CSharpParser.PROTECTED - 65)) | (
                            1 << (CSharpParser.PUBLIC - 65)) | (1 << (CSharpParser.READONLY - 65)) | (
                            1 << (CSharpParser.REF - 65)) | (1 << (CSharpParser.SEALED - 65)) | (
                            1 << (CSharpParser.STATIC - 65)) | (1 << (CSharpParser.STRUCT - 65)) | (
                            1 << (CSharpParser.UNSAFE - 65)) | (1 << (CSharpParser.VIRTUAL - 65)) | (
                            1 << (CSharpParser.VOLATILE - 65)) | (1 << (CSharpParser.OPEN_BRACKET - 65)))) != 0):
                self.state = 453
                self.namespace_member_declarations()

            self.state = 456
            self.match(CSharpParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Namespace_or_type_nameContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(CSharpParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(CSharpParser.IdentifierContext, i)

        def qualified_alias_member(self):
            return self.getTypedRuleContext(CSharpParser.Qualified_alias_memberContext, 0)

        def DOT(self, i: int = None):
            if i is None:
                return self.getTokens(CSharpParser.DOT)
            else:
                return self.getToken(CSharpParser.DOT, i)

        def type_argument_list(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(CSharpParser.Type_argument_listContext)
            else:
                return self.getTypedRuleContext(CSharpParser.Type_argument_listContext, i)

        def getRuleIndex(self):
            return CSharpParser.RULE_namespace_or_type_name

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterNamespace_or_type_name"):
                listener.enterNamespace_or_type_name(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitNamespace_or_type_name"):
                listener.exitNamespace_or_type_name(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitNamespace_or_type_name"):
                return visitor.visitNamespace_or_type_name(self)
            else:
                return visitor.visitChildren(self)

    def namespace_or_type_name(self):

        localctx = CSharpParser.Namespace_or_type_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_namespace_or_type_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 463
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 6, self._ctx)
            if la_ == 1:
                self.state = 458
                self.identifier()
                self.state = 460
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input, 5, self._ctx)
                if la_ == 1:
                    self.state = 459
                    self.type_argument_list()

                pass

            elif la_ == 2:
                self.state = 462
                self.qualified_alias_member()
                pass

            self.state = 472
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input, 8, self._ctx)
            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 465
                    self.match(CSharpParser.DOT)
                    self.state = 466
                    self.identifier()
                    self.state = 468
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input, 7, self._ctx)
                    if la_ == 1:
                        self.state = 467
                        self.type_argument_list()

                self.state = 474
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 8, self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Type_Context(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def base_type(self):
            return self.getTypedRuleContext(CSharpParser.Base_typeContext, 0)

        def INTERR(self, i: int = None):
            if i is None:
                return self.getTokens(CSharpParser.INTERR)
            else:
                return self.getToken(CSharpParser.INTERR, i)

        def rank_specifier(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(CSharpParser.Rank_specifierContext)
            else:
                return self.getTypedRuleContext(CSharpParser.Rank_specifierContext, i)

        def STAR(self, i: int = None):
            if i is None:
                return self.getTokens(CSharpParser.STAR)
            else:
                return self.getToken(CSharpParser.STAR, i)

        def getRuleIndex(self):
            return CSharpParser.RULE_type_

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterType_"):
                listener.enterType_(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitType_"):
                listener.exitType_(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitType_"):
                return visitor.visitType_(self)
            else:
                return visitor.visitChildren(self)

    def type_(self):

        localctx = CSharpParser.Type_Context(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_type_)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 475
            self.base_type()
            self.state = 481
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input, 10, self._ctx)
            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 479
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [CSharpParser.INTERR]:
                        self.state = 476
                        self.match(CSharpParser.INTERR)
                        pass
                    elif token in [CSharpParser.OPEN_BRACKET]:
                        self.state = 477
                        self.rank_specifier()
                        pass
                    elif token in [CSharpParser.STAR]:
                        self.state = 478
                        self.match(CSharpParser.STAR)
                        pass
                    else:
                        raise NoViableAltException(self)

                self.state = 483
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 10, self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Base_typeContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def simple_type(self):
            return self.getTypedRuleContext(CSharpParser.Simple_typeContext, 0)

        def class_type(self):
            return self.getTypedRuleContext(CSharpParser.Class_typeContext, 0)

        def VOID(self):
            return self.getToken(CSharpParser.VOID, 0)

        def STAR(self):
            return self.getToken(CSharpParser.STAR, 0)

        def tuple_type(self):
            return self.getTypedRuleContext(CSharpParser.Tuple_typeContext, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_base_type

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterBase_type"):
                listener.enterBase_type(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitBase_type"):
                listener.exitBase_type(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitBase_type"):
                return visitor.visitBase_type(self)
            else:
                return visitor.visitChildren(self)

    def base_type(self):

        localctx = CSharpParser.Base_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_base_type)
        try:
            self.state = 489
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [CSharpParser.BOOL, CSharpParser.BYTE, CSharpParser.CHAR, CSharpParser.DECIMAL,
                         CSharpParser.DOUBLE, CSharpParser.FLOAT, CSharpParser.INT, CSharpParser.LONG,
                         CSharpParser.SBYTE, CSharpParser.SHORT, CSharpParser.UINT, CSharpParser.ULONG,
                         CSharpParser.USHORT]:
                self.enterOuterAlt(localctx, 1)
                self.state = 484
                self.simple_type()
                pass
            elif token in [CSharpParser.ADD, CSharpParser.ALIAS, CSharpParser.ARGLIST, CSharpParser.ASCENDING,
                           CSharpParser.ASYNC, CSharpParser.AWAIT, CSharpParser.BY, CSharpParser.DESCENDING,
                           CSharpParser.DYNAMIC, CSharpParser.EQUALS, CSharpParser.FROM, CSharpParser.GET,
                           CSharpParser.GROUP, CSharpParser.INTO, CSharpParser.JOIN, CSharpParser.LET,
                           CSharpParser.NAMEOF, CSharpParser.OBJECT, CSharpParser.ON, CSharpParser.ORDERBY,
                           CSharpParser.PARTIAL, CSharpParser.REMOVE, CSharpParser.SELECT, CSharpParser.SET,
                           CSharpParser.STRING, CSharpParser.UNMANAGED, CSharpParser.VAR, CSharpParser.WHEN,
                           CSharpParser.WHERE, CSharpParser.YIELD, CSharpParser.IDENTIFIER]:
                self.enterOuterAlt(localctx, 2)
                self.state = 485
                self.class_type()
                pass
            elif token in [CSharpParser.VOID]:
                self.enterOuterAlt(localctx, 3)
                self.state = 486
                self.match(CSharpParser.VOID)
                self.state = 487
                self.match(CSharpParser.STAR)
                pass
            elif token in [CSharpParser.OPEN_PARENS]:
                self.enterOuterAlt(localctx, 4)
                self.state = 488
                self.tuple_type()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Tuple_typeContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPEN_PARENS(self):
            return self.getToken(CSharpParser.OPEN_PARENS, 0)

        def tuple_element(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(CSharpParser.Tuple_elementContext)
            else:
                return self.getTypedRuleContext(CSharpParser.Tuple_elementContext, i)

        def CLOSE_PARENS(self):
            return self.getToken(CSharpParser.CLOSE_PARENS, 0)

        def COMMA(self, i: int = None):
            if i is None:
                return self.getTokens(CSharpParser.COMMA)
            else:
                return self.getToken(CSharpParser.COMMA, i)

        def getRuleIndex(self):
            return CSharpParser.RULE_tuple_type

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterTuple_type"):
                listener.enterTuple_type(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitTuple_type"):
                listener.exitTuple_type(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitTuple_type"):
                return visitor.visitTuple_type(self)
            else:
                return visitor.visitChildren(self)

    def tuple_type(self):

        localctx = CSharpParser.Tuple_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_tuple_type)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 491
            self.match(CSharpParser.OPEN_PARENS)
            self.state = 492
            self.tuple_element()
            self.state = 495
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 493
                self.match(CSharpParser.COMMA)
                self.state = 494
                self.tuple_element()
                self.state = 497
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la == CSharpParser.COMMA):
                    break

            self.state = 499
            self.match(CSharpParser.CLOSE_PARENS)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Tuple_elementContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def type_(self):
            return self.getTypedRuleContext(CSharpParser.Type_Context, 0)

        def identifier(self):
            return self.getTypedRuleContext(CSharpParser.IdentifierContext, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_tuple_element

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterTuple_element"):
                listener.enterTuple_element(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitTuple_element"):
                listener.exitTuple_element(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitTuple_element"):
                return visitor.visitTuple_element(self)
            else:
                return visitor.visitChildren(self)

    def tuple_element(self):

        localctx = CSharpParser.Tuple_elementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_tuple_element)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 501
            self.type_()
            self.state = 503
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & (
                    (1 << CSharpParser.ADD) | (1 << CSharpParser.ALIAS) | (1 << CSharpParser.ARGLIST) | (
                    1 << CSharpParser.ASCENDING) | (1 << CSharpParser.ASYNC) | (1 << CSharpParser.AWAIT) | (
                            1 << CSharpParser.BY) | (1 << CSharpParser.DESCENDING) | (1 << CSharpParser.DYNAMIC) | (
                            1 << CSharpParser.EQUALS) | (1 << CSharpParser.FROM) | (1 << CSharpParser.GET) | (
                            1 << CSharpParser.GROUP) | (1 << CSharpParser.INTO) | (1 << CSharpParser.JOIN) | (
                            1 << CSharpParser.LET))) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & (
                    (1 << (CSharpParser.NAMEOF - 64)) | (1 << (CSharpParser.ON - 64)) | (
                    1 << (CSharpParser.ORDERBY - 64)) | (1 << (CSharpParser.PARTIAL - 64)) | (
                            1 << (CSharpParser.REMOVE - 64)) | (1 << (CSharpParser.SELECT - 64)) | (
                            1 << (CSharpParser.SET - 64)) | (1 << (CSharpParser.UNMANAGED - 64)) | (
                            1 << (CSharpParser.VAR - 64)) | (1 << (CSharpParser.WHEN - 64)) | (
                            1 << (CSharpParser.WHERE - 64)) | (1 << (CSharpParser.YIELD - 64)) | (
                            1 << (CSharpParser.IDENTIFIER - 64)))) != 0):
                self.state = 502
                self.identifier()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Simple_typeContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def numeric_type(self):
            return self.getTypedRuleContext(CSharpParser.Numeric_typeContext, 0)

        def BOOL(self):
            return self.getToken(CSharpParser.BOOL, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_simple_type

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterSimple_type"):
                listener.enterSimple_type(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitSimple_type"):
                listener.exitSimple_type(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitSimple_type"):
                return visitor.visitSimple_type(self)
            else:
                return visitor.visitChildren(self)

    def simple_type(self):

        localctx = CSharpParser.Simple_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_simple_type)
        try:
            self.state = 507
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [CSharpParser.BYTE, CSharpParser.CHAR, CSharpParser.DECIMAL, CSharpParser.DOUBLE,
                         CSharpParser.FLOAT, CSharpParser.INT, CSharpParser.LONG, CSharpParser.SBYTE,
                         CSharpParser.SHORT, CSharpParser.UINT, CSharpParser.ULONG, CSharpParser.USHORT]:
                self.enterOuterAlt(localctx, 1)
                self.state = 505
                self.numeric_type()
                pass
            elif token in [CSharpParser.BOOL]:
                self.enterOuterAlt(localctx, 2)
                self.state = 506
                self.match(CSharpParser.BOOL)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Numeric_typeContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def integral_type(self):
            return self.getTypedRuleContext(CSharpParser.Integral_typeContext, 0)

        def floating_point_type(self):
            return self.getTypedRuleContext(CSharpParser.Floating_point_typeContext, 0)

        def DECIMAL(self):
            return self.getToken(CSharpParser.DECIMAL, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_numeric_type

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterNumeric_type"):
                listener.enterNumeric_type(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitNumeric_type"):
                listener.exitNumeric_type(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitNumeric_type"):
                return visitor.visitNumeric_type(self)
            else:
                return visitor.visitChildren(self)

    def numeric_type(self):

        localctx = CSharpParser.Numeric_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_numeric_type)
        try:
            self.state = 512
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [CSharpParser.BYTE, CSharpParser.CHAR, CSharpParser.INT, CSharpParser.LONG, CSharpParser.SBYTE,
                         CSharpParser.SHORT, CSharpParser.UINT, CSharpParser.ULONG, CSharpParser.USHORT]:
                self.enterOuterAlt(localctx, 1)
                self.state = 509
                self.integral_type()
                pass
            elif token in [CSharpParser.DOUBLE, CSharpParser.FLOAT]:
                self.enterOuterAlt(localctx, 2)
                self.state = 510
                self.floating_point_type()
                pass
            elif token in [CSharpParser.DECIMAL]:
                self.enterOuterAlt(localctx, 3)
                self.state = 511
                self.match(CSharpParser.DECIMAL)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Integral_typeContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SBYTE(self):
            return self.getToken(CSharpParser.SBYTE, 0)

        def BYTE(self):
            return self.getToken(CSharpParser.BYTE, 0)

        def SHORT(self):
            return self.getToken(CSharpParser.SHORT, 0)

        def USHORT(self):
            return self.getToken(CSharpParser.USHORT, 0)

        def INT(self):
            return self.getToken(CSharpParser.INT, 0)

        def UINT(self):
            return self.getToken(CSharpParser.UINT, 0)

        def LONG(self):
            return self.getToken(CSharpParser.LONG, 0)

        def ULONG(self):
            return self.getToken(CSharpParser.ULONG, 0)

        def CHAR(self):
            return self.getToken(CSharpParser.CHAR, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_integral_type

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterIntegral_type"):
                listener.enterIntegral_type(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitIntegral_type"):
                listener.exitIntegral_type(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitIntegral_type"):
                return visitor.visitIntegral_type(self)
            else:
                return visitor.visitChildren(self)

    def integral_type(self):

        localctx = CSharpParser.Integral_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_integral_type)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 514
            _la = self._input.LA(1)
            if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & (
                    (1 << CSharpParser.BYTE) | (1 << CSharpParser.CHAR) | (1 << CSharpParser.INT) | (
                    1 << CSharpParser.LONG))) != 0) or ((((_la - 83)) & ~0x3f) == 0 and ((1 << (_la - 83)) & (
                    (1 << (CSharpParser.SBYTE - 83)) | (1 << (CSharpParser.SHORT - 83)) | (
                    1 << (CSharpParser.UINT - 83)) | (1 << (CSharpParser.ULONG - 83)) | (
                            1 << (CSharpParser.USHORT - 83)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Floating_point_typeContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FLOAT(self):
            return self.getToken(CSharpParser.FLOAT, 0)

        def DOUBLE(self):
            return self.getToken(CSharpParser.DOUBLE, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_floating_point_type

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterFloating_point_type"):
                listener.enterFloating_point_type(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitFloating_point_type"):
                listener.exitFloating_point_type(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitFloating_point_type"):
                return visitor.visitFloating_point_type(self)
            else:
                return visitor.visitChildren(self)

    def floating_point_type(self):

        localctx = CSharpParser.Floating_point_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_floating_point_type)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 516
            _la = self._input.LA(1)
            if not (_la == CSharpParser.DOUBLE or _la == CSharpParser.FLOAT):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Class_typeContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def namespace_or_type_name(self):
            return self.getTypedRuleContext(CSharpParser.Namespace_or_type_nameContext, 0)

        def OBJECT(self):
            return self.getToken(CSharpParser.OBJECT, 0)

        def DYNAMIC(self):
            return self.getToken(CSharpParser.DYNAMIC, 0)

        def STRING(self):
            return self.getToken(CSharpParser.STRING, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_class_type

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterClass_type"):
                listener.enterClass_type(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitClass_type"):
                listener.exitClass_type(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitClass_type"):
                return visitor.visitClass_type(self)
            else:
                return visitor.visitChildren(self)

    def class_type(self):

        localctx = CSharpParser.Class_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_class_type)
        try:
            self.state = 522
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 16, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 518
                self.namespace_or_type_name()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 519
                self.match(CSharpParser.OBJECT)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 520
                self.match(CSharpParser.DYNAMIC)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 521
                self.match(CSharpParser.STRING)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Type_argument_listContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LT(self):
            return self.getToken(CSharpParser.LT, 0)

        def type_(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(CSharpParser.Type_Context)
            else:
                return self.getTypedRuleContext(CSharpParser.Type_Context, i)

        def GT(self):
            return self.getToken(CSharpParser.GT, 0)

        def COMMA(self, i: int = None):
            if i is None:
                return self.getTokens(CSharpParser.COMMA)
            else:
                return self.getToken(CSharpParser.COMMA, i)

        def getRuleIndex(self):
            return CSharpParser.RULE_type_argument_list

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterType_argument_list"):
                listener.enterType_argument_list(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitType_argument_list"):
                listener.exitType_argument_list(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitType_argument_list"):
                return visitor.visitType_argument_list(self)
            else:
                return visitor.visitChildren(self)

    def type_argument_list(self):

        localctx = CSharpParser.Type_argument_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_type_argument_list)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 524
            self.match(CSharpParser.LT)
            self.state = 525
            self.type_()
            self.state = 530
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == CSharpParser.COMMA:
                self.state = 526
                self.match(CSharpParser.COMMA)
                self.state = 527
                self.type_()
                self.state = 532
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 533
            self.match(CSharpParser.GT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Argument_listContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def argument(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(CSharpParser.ArgumentContext)
            else:
                return self.getTypedRuleContext(CSharpParser.ArgumentContext, i)

        def COMMA(self, i: int = None):
            if i is None:
                return self.getTokens(CSharpParser.COMMA)
            else:
                return self.getToken(CSharpParser.COMMA, i)

        def getRuleIndex(self):
            return CSharpParser.RULE_argument_list

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterArgument_list"):
                listener.enterArgument_list(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitArgument_list"):
                listener.exitArgument_list(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitArgument_list"):
                return visitor.visitArgument_list(self)
            else:
                return visitor.visitChildren(self)

    def argument_list(self):

        localctx = CSharpParser.Argument_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_argument_list)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 535
            self.argument()
            self.state = 540
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == CSharpParser.COMMA:
                self.state = 536
                self.match(CSharpParser.COMMA)
                self.state = 537
                self.argument()
                self.state = 542
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ArgumentContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.refout = None  # Token

        def expression(self):
            return self.getTypedRuleContext(CSharpParser.ExpressionContext, 0)

        def identifier(self):
            return self.getTypedRuleContext(CSharpParser.IdentifierContext, 0)

        def COLON(self):
            return self.getToken(CSharpParser.COLON, 0)

        def VAR(self):
            return self.getToken(CSharpParser.VAR, 0)

        def type_(self):
            return self.getTypedRuleContext(CSharpParser.Type_Context, 0)

        def REF(self):
            return self.getToken(CSharpParser.REF, 0)

        def OUT(self):
            return self.getToken(CSharpParser.OUT, 0)

        def IN(self):
            return self.getToken(CSharpParser.IN, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_argument

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterArgument"):
                listener.enterArgument(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitArgument"):
                listener.exitArgument(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitArgument"):
                return visitor.visitArgument(self)
            else:
                return visitor.visitChildren(self)

    def argument(self):

        localctx = CSharpParser.ArgumentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_argument)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 546
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 19, self._ctx)
            if la_ == 1:
                self.state = 543
                self.identifier()
                self.state = 544
                self.match(CSharpParser.COLON)

            self.state = 549
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 20, self._ctx)
            if la_ == 1:
                self.state = 548
                localctx.refout = self._input.LT(1)
                _la = self._input.LA(1)
                if not (((((_la - 54)) & ~0x3f) == 0 and ((1 << (_la - 54)) & (
                        (1 << (CSharpParser.IN - 54)) | (1 << (CSharpParser.OUT - 54)) | (
                        1 << (CSharpParser.REF - 54)))) != 0)):
                    localctx.refout = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()

            self.state = 557
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 22, self._ctx)
            if la_ == 1:
                self.state = 551
                self.expression()
                pass

            elif la_ == 2:
                self.state = 554
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input, 21, self._ctx)
                if la_ == 1:
                    self.state = 552
                    self.match(CSharpParser.VAR)
                    pass

                elif la_ == 2:
                    self.state = 553
                    self.type_()
                    pass

                self.state = 556
                self.expression()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ExpressionContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def assignment(self):
            return self.getTypedRuleContext(CSharpParser.AssignmentContext, 0)

        def non_assignment_expression(self):
            return self.getTypedRuleContext(CSharpParser.Non_assignment_expressionContext, 0)

        def REF(self):
            return self.getToken(CSharpParser.REF, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_expression

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterExpression"):
                listener.enterExpression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitExpression"):
                listener.exitExpression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitExpression"):
                return visitor.visitExpression(self)
            else:
                return visitor.visitChildren(self)

    def expression(self):

        localctx = CSharpParser.ExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_expression)
        try:
            self.state = 563
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 23, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 559
                self.assignment()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 560
                self.non_assignment_expression()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 561
                self.match(CSharpParser.REF)
                self.state = 562
                self.non_assignment_expression()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Non_assignment_expressionContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def lambda_expression(self):
            return self.getTypedRuleContext(CSharpParser.Lambda_expressionContext, 0)

        def query_expression(self):
            return self.getTypedRuleContext(CSharpParser.Query_expressionContext, 0)

        def conditional_expression(self):
            return self.getTypedRuleContext(CSharpParser.Conditional_expressionContext, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_non_assignment_expression

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterNon_assignment_expression"):
                listener.enterNon_assignment_expression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitNon_assignment_expression"):
                listener.exitNon_assignment_expression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitNon_assignment_expression"):
                return visitor.visitNon_assignment_expression(self)
            else:
                return visitor.visitChildren(self)

    def non_assignment_expression(self):

        localctx = CSharpParser.Non_assignment_expressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_non_assignment_expression)
        try:
            self.state = 568
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 24, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 565
                self.lambda_expression()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 566
                self.query_expression()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 567
                self.conditional_expression()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AssignmentContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def unary_expression(self):
            return self.getTypedRuleContext(CSharpParser.Unary_expressionContext, 0)

        def assignment_operator(self):
            return self.getTypedRuleContext(CSharpParser.Assignment_operatorContext, 0)

        def expression(self):
            return self.getTypedRuleContext(CSharpParser.ExpressionContext, 0)

        def OP_COALESCING_ASSIGNMENT(self):
            return self.getToken(CSharpParser.OP_COALESCING_ASSIGNMENT, 0)

        def throwable_expression(self):
            return self.getTypedRuleContext(CSharpParser.Throwable_expressionContext, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_assignment

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterAssignment"):
                listener.enterAssignment(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitAssignment"):
                listener.exitAssignment(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitAssignment"):
                return visitor.visitAssignment(self)
            else:
                return visitor.visitChildren(self)

    def assignment(self):

        localctx = CSharpParser.AssignmentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_assignment)
        try:
            self.state = 578
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 25, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 570
                self.unary_expression()
                self.state = 571
                self.assignment_operator()
                self.state = 572
                self.expression()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 574
                self.unary_expression()
                self.state = 575
                self.match(CSharpParser.OP_COALESCING_ASSIGNMENT)
                self.state = 576
                self.throwable_expression()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Assignment_operatorContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ASSIGNMENT(self):
            return self.getToken(CSharpParser.ASSIGNMENT, 0)

        def OP_ADD_ASSIGNMENT(self):
            return self.getToken(CSharpParser.OP_ADD_ASSIGNMENT, 0)

        def OP_SUB_ASSIGNMENT(self):
            return self.getToken(CSharpParser.OP_SUB_ASSIGNMENT, 0)

        def OP_MULT_ASSIGNMENT(self):
            return self.getToken(CSharpParser.OP_MULT_ASSIGNMENT, 0)

        def OP_DIV_ASSIGNMENT(self):
            return self.getToken(CSharpParser.OP_DIV_ASSIGNMENT, 0)

        def OP_MOD_ASSIGNMENT(self):
            return self.getToken(CSharpParser.OP_MOD_ASSIGNMENT, 0)

        def OP_AND_ASSIGNMENT(self):
            return self.getToken(CSharpParser.OP_AND_ASSIGNMENT, 0)

        def OP_OR_ASSIGNMENT(self):
            return self.getToken(CSharpParser.OP_OR_ASSIGNMENT, 0)

        def OP_XOR_ASSIGNMENT(self):
            return self.getToken(CSharpParser.OP_XOR_ASSIGNMENT, 0)

        def OP_LEFT_SHIFT_ASSIGNMENT(self):
            return self.getToken(CSharpParser.OP_LEFT_SHIFT_ASSIGNMENT, 0)

        def right_shift_assignment(self):
            return self.getTypedRuleContext(CSharpParser.Right_shift_assignmentContext, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_assignment_operator

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterAssignment_operator"):
                listener.enterAssignment_operator(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitAssignment_operator"):
                listener.exitAssignment_operator(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitAssignment_operator"):
                return visitor.visitAssignment_operator(self)
            else:
                return visitor.visitChildren(self)

    def assignment_operator(self):

        localctx = CSharpParser.Assignment_operatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_assignment_operator)
        try:
            self.state = 591
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [CSharpParser.ASSIGNMENT]:
                self.enterOuterAlt(localctx, 1)
                self.state = 580
                self.match(CSharpParser.ASSIGNMENT)
                pass
            elif token in [CSharpParser.OP_ADD_ASSIGNMENT]:
                self.enterOuterAlt(localctx, 2)
                self.state = 581
                self.match(CSharpParser.OP_ADD_ASSIGNMENT)
                pass
            elif token in [CSharpParser.OP_SUB_ASSIGNMENT]:
                self.enterOuterAlt(localctx, 3)
                self.state = 582
                self.match(CSharpParser.OP_SUB_ASSIGNMENT)
                pass
            elif token in [CSharpParser.OP_MULT_ASSIGNMENT]:
                self.enterOuterAlt(localctx, 4)
                self.state = 583
                self.match(CSharpParser.OP_MULT_ASSIGNMENT)
                pass
            elif token in [CSharpParser.OP_DIV_ASSIGNMENT]:
                self.enterOuterAlt(localctx, 5)
                self.state = 584
                self.match(CSharpParser.OP_DIV_ASSIGNMENT)
                pass
            elif token in [CSharpParser.OP_MOD_ASSIGNMENT]:
                self.enterOuterAlt(localctx, 6)
                self.state = 585
                self.match(CSharpParser.OP_MOD_ASSIGNMENT)
                pass
            elif token in [CSharpParser.OP_AND_ASSIGNMENT]:
                self.enterOuterAlt(localctx, 7)
                self.state = 586
                self.match(CSharpParser.OP_AND_ASSIGNMENT)
                pass
            elif token in [CSharpParser.OP_OR_ASSIGNMENT]:
                self.enterOuterAlt(localctx, 8)
                self.state = 587
                self.match(CSharpParser.OP_OR_ASSIGNMENT)
                pass
            elif token in [CSharpParser.OP_XOR_ASSIGNMENT]:
                self.enterOuterAlt(localctx, 9)
                self.state = 588
                self.match(CSharpParser.OP_XOR_ASSIGNMENT)
                pass
            elif token in [CSharpParser.OP_LEFT_SHIFT_ASSIGNMENT]:
                self.enterOuterAlt(localctx, 10)
                self.state = 589
                self.match(CSharpParser.OP_LEFT_SHIFT_ASSIGNMENT)
                pass
            elif token in [CSharpParser.GT]:
                self.enterOuterAlt(localctx, 11)
                self.state = 590
                self.right_shift_assignment()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Conditional_expressionContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def null_coalescing_expression(self):
            return self.getTypedRuleContext(CSharpParser.Null_coalescing_expressionContext, 0)

        def INTERR(self):
            return self.getToken(CSharpParser.INTERR, 0)

        def throwable_expression(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(CSharpParser.Throwable_expressionContext)
            else:
                return self.getTypedRuleContext(CSharpParser.Throwable_expressionContext, i)

        def COLON(self):
            return self.getToken(CSharpParser.COLON, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_conditional_expression

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterConditional_expression"):
                listener.enterConditional_expression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitConditional_expression"):
                listener.exitConditional_expression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitConditional_expression"):
                return visitor.visitConditional_expression(self)
            else:
                return visitor.visitChildren(self)

    def conditional_expression(self):

        localctx = CSharpParser.Conditional_expressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_conditional_expression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 593
            self.null_coalescing_expression()
            self.state = 599
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 27, self._ctx)
            if la_ == 1:
                self.state = 594
                self.match(CSharpParser.INTERR)
                self.state = 595
                self.throwable_expression()
                self.state = 596
                self.match(CSharpParser.COLON)
                self.state = 597
                self.throwable_expression()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Null_coalescing_expressionContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def conditional_or_expression(self):
            return self.getTypedRuleContext(CSharpParser.Conditional_or_expressionContext, 0)

        def OP_COALESCING(self):
            return self.getToken(CSharpParser.OP_COALESCING, 0)

        def null_coalescing_expression(self):
            return self.getTypedRuleContext(CSharpParser.Null_coalescing_expressionContext, 0)

        def throw_expression(self):
            return self.getTypedRuleContext(CSharpParser.Throw_expressionContext, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_null_coalescing_expression

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterNull_coalescing_expression"):
                listener.enterNull_coalescing_expression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitNull_coalescing_expression"):
                listener.exitNull_coalescing_expression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitNull_coalescing_expression"):
                return visitor.visitNull_coalescing_expression(self)
            else:
                return visitor.visitChildren(self)

    def null_coalescing_expression(self):

        localctx = CSharpParser.Null_coalescing_expressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_null_coalescing_expression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 601
            self.conditional_or_expression()
            self.state = 607
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 29, self._ctx)
            if la_ == 1:
                self.state = 602
                self.match(CSharpParser.OP_COALESCING)
                self.state = 605
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [CSharpParser.ADD, CSharpParser.ALIAS, CSharpParser.ARGLIST, CSharpParser.ASCENDING,
                             CSharpParser.ASYNC, CSharpParser.AWAIT, CSharpParser.BASE, CSharpParser.BOOL,
                             CSharpParser.BY, CSharpParser.BYTE, CSharpParser.CHAR, CSharpParser.CHECKED,
                             CSharpParser.DECIMAL, CSharpParser.DEFAULT, CSharpParser.DELEGATE, CSharpParser.DESCENDING,
                             CSharpParser.DOUBLE, CSharpParser.DYNAMIC, CSharpParser.EQUALS, CSharpParser.FALSE,
                             CSharpParser.FLOAT, CSharpParser.FROM, CSharpParser.GET, CSharpParser.GROUP,
                             CSharpParser.INT, CSharpParser.INTO, CSharpParser.JOIN, CSharpParser.LET,
                             CSharpParser.LONG, CSharpParser.NAMEOF, CSharpParser.NEW, CSharpParser.NULL_,
                             CSharpParser.OBJECT, CSharpParser.ON, CSharpParser.ORDERBY, CSharpParser.PARTIAL,
                             CSharpParser.REMOVE, CSharpParser.SBYTE, CSharpParser.SELECT, CSharpParser.SET,
                             CSharpParser.SHORT, CSharpParser.SIZEOF, CSharpParser.STRING, CSharpParser.THIS,
                             CSharpParser.TRUE, CSharpParser.TYPEOF, CSharpParser.UINT, CSharpParser.ULONG,
                             CSharpParser.UNCHECKED, CSharpParser.UNMANAGED, CSharpParser.USHORT, CSharpParser.VAR,
                             CSharpParser.WHEN, CSharpParser.WHERE, CSharpParser.YIELD, CSharpParser.IDENTIFIER,
                             CSharpParser.LITERAL_ACCESS, CSharpParser.INTEGER_LITERAL,
                             CSharpParser.HEX_INTEGER_LITERAL, CSharpParser.BIN_INTEGER_LITERAL,
                             CSharpParser.REAL_LITERAL, CSharpParser.CHARACTER_LITERAL, CSharpParser.REGULAR_STRING,
                             CSharpParser.VERBATIUM_STRING, CSharpParser.INTERPOLATED_REGULAR_STRING_START,
                             CSharpParser.INTERPOLATED_VERBATIUM_STRING_START, CSharpParser.OPEN_PARENS,
                             CSharpParser.PLUS, CSharpParser.MINUS, CSharpParser.STAR, CSharpParser.AMP,
                             CSharpParser.CARET, CSharpParser.BANG, CSharpParser.TILDE, CSharpParser.OP_INC,
                             CSharpParser.OP_DEC, CSharpParser.OP_RANGE]:
                    self.state = 603
                    self.null_coalescing_expression()
                    pass
                elif token in [CSharpParser.THROW]:
                    self.state = 604
                    self.throw_expression()
                    pass
                else:
                    raise NoViableAltException(self)



        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Conditional_or_expressionContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def conditional_and_expression(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(CSharpParser.Conditional_and_expressionContext)
            else:
                return self.getTypedRuleContext(CSharpParser.Conditional_and_expressionContext, i)

        def OP_OR(self, i: int = None):
            if i is None:
                return self.getTokens(CSharpParser.OP_OR)
            else:
                return self.getToken(CSharpParser.OP_OR, i)

        def getRuleIndex(self):
            return CSharpParser.RULE_conditional_or_expression

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterConditional_or_expression"):
                listener.enterConditional_or_expression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitConditional_or_expression"):
                listener.exitConditional_or_expression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitConditional_or_expression"):
                return visitor.visitConditional_or_expression(self)
            else:
                return visitor.visitChildren(self)

    def conditional_or_expression(self):

        localctx = CSharpParser.Conditional_or_expressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_conditional_or_expression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 609
            self.conditional_and_expression()
            self.state = 614
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input, 30, self._ctx)
            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 610
                    self.match(CSharpParser.OP_OR)
                    self.state = 611
                    self.conditional_and_expression()
                self.state = 616
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 30, self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Conditional_and_expressionContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def inclusive_or_expression(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(CSharpParser.Inclusive_or_expressionContext)
            else:
                return self.getTypedRuleContext(CSharpParser.Inclusive_or_expressionContext, i)

        def OP_AND(self, i: int = None):
            if i is None:
                return self.getTokens(CSharpParser.OP_AND)
            else:
                return self.getToken(CSharpParser.OP_AND, i)

        def getRuleIndex(self):
            return CSharpParser.RULE_conditional_and_expression

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterConditional_and_expression"):
                listener.enterConditional_and_expression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitConditional_and_expression"):
                listener.exitConditional_and_expression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitConditional_and_expression"):
                return visitor.visitConditional_and_expression(self)
            else:
                return visitor.visitChildren(self)

    def conditional_and_expression(self):

        localctx = CSharpParser.Conditional_and_expressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_conditional_and_expression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 617
            self.inclusive_or_expression()
            self.state = 622
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input, 31, self._ctx)
            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 618
                    self.match(CSharpParser.OP_AND)
                    self.state = 619
                    self.inclusive_or_expression()
                self.state = 624
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 31, self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Inclusive_or_expressionContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def exclusive_or_expression(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(CSharpParser.Exclusive_or_expressionContext)
            else:
                return self.getTypedRuleContext(CSharpParser.Exclusive_or_expressionContext, i)

        def BITWISE_OR(self, i: int = None):
            if i is None:
                return self.getTokens(CSharpParser.BITWISE_OR)
            else:
                return self.getToken(CSharpParser.BITWISE_OR, i)

        def getRuleIndex(self):
            return CSharpParser.RULE_inclusive_or_expression

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterInclusive_or_expression"):
                listener.enterInclusive_or_expression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitInclusive_or_expression"):
                listener.exitInclusive_or_expression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitInclusive_or_expression"):
                return visitor.visitInclusive_or_expression(self)
            else:
                return visitor.visitChildren(self)

    def inclusive_or_expression(self):

        localctx = CSharpParser.Inclusive_or_expressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_inclusive_or_expression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 625
            self.exclusive_or_expression()
            self.state = 630
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input, 32, self._ctx)
            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 626
                    self.match(CSharpParser.BITWISE_OR)
                    self.state = 627
                    self.exclusive_or_expression()
                self.state = 632
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 32, self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Exclusive_or_expressionContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def and_expression(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(CSharpParser.And_expressionContext)
            else:
                return self.getTypedRuleContext(CSharpParser.And_expressionContext, i)

        def CARET(self, i: int = None):
            if i is None:
                return self.getTokens(CSharpParser.CARET)
            else:
                return self.getToken(CSharpParser.CARET, i)

        def getRuleIndex(self):
            return CSharpParser.RULE_exclusive_or_expression

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterExclusive_or_expression"):
                listener.enterExclusive_or_expression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitExclusive_or_expression"):
                listener.exitExclusive_or_expression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitExclusive_or_expression"):
                return visitor.visitExclusive_or_expression(self)
            else:
                return visitor.visitChildren(self)

    def exclusive_or_expression(self):

        localctx = CSharpParser.Exclusive_or_expressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_exclusive_or_expression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 633
            self.and_expression()
            self.state = 638
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input, 33, self._ctx)
            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 634
                    self.match(CSharpParser.CARET)
                    self.state = 635
                    self.and_expression()
                self.state = 640
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 33, self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class And_expressionContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def equality_expression(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(CSharpParser.Equality_expressionContext)
            else:
                return self.getTypedRuleContext(CSharpParser.Equality_expressionContext, i)

        def AMP(self, i: int = None):
            if i is None:
                return self.getTokens(CSharpParser.AMP)
            else:
                return self.getToken(CSharpParser.AMP, i)

        def getRuleIndex(self):
            return CSharpParser.RULE_and_expression

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterAnd_expression"):
                listener.enterAnd_expression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitAnd_expression"):
                listener.exitAnd_expression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitAnd_expression"):
                return visitor.visitAnd_expression(self)
            else:
                return visitor.visitChildren(self)

    def and_expression(self):

        localctx = CSharpParser.And_expressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_and_expression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 641
            self.equality_expression()
            self.state = 646
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input, 34, self._ctx)
            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 642
                    self.match(CSharpParser.AMP)
                    self.state = 643
                    self.equality_expression()
                self.state = 648
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 34, self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Equality_expressionContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def relational_expression(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(CSharpParser.Relational_expressionContext)
            else:
                return self.getTypedRuleContext(CSharpParser.Relational_expressionContext, i)

        def OP_EQ(self, i: int = None):
            if i is None:
                return self.getTokens(CSharpParser.OP_EQ)
            else:
                return self.getToken(CSharpParser.OP_EQ, i)

        def OP_NE(self, i: int = None):
            if i is None:
                return self.getTokens(CSharpParser.OP_NE)
            else:
                return self.getToken(CSharpParser.OP_NE, i)

        def getRuleIndex(self):
            return CSharpParser.RULE_equality_expression

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterEquality_expression"):
                listener.enterEquality_expression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitEquality_expression"):
                listener.exitEquality_expression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitEquality_expression"):
                return visitor.visitEquality_expression(self)
            else:
                return visitor.visitChildren(self)

    def equality_expression(self):

        localctx = CSharpParser.Equality_expressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_equality_expression)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 649
            self.relational_expression()
            self.state = 654
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input, 35, self._ctx)
            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 650
                    _la = self._input.LA(1)
                    if not (_la == CSharpParser.OP_EQ or _la == CSharpParser.OP_NE):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 651
                    self.relational_expression()
                self.state = 656
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 35, self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Relational_expressionContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def shift_expression(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(CSharpParser.Shift_expressionContext)
            else:
                return self.getTypedRuleContext(CSharpParser.Shift_expressionContext, i)

        def IS(self, i: int = None):
            if i is None:
                return self.getTokens(CSharpParser.IS)
            else:
                return self.getToken(CSharpParser.IS, i)

        def isType(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(CSharpParser.IsTypeContext)
            else:
                return self.getTypedRuleContext(CSharpParser.IsTypeContext, i)

        def AS(self, i: int = None):
            if i is None:
                return self.getTokens(CSharpParser.AS)
            else:
                return self.getToken(CSharpParser.AS, i)

        def type_(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(CSharpParser.Type_Context)
            else:
                return self.getTypedRuleContext(CSharpParser.Type_Context, i)

        def LT(self, i: int = None):
            if i is None:
                return self.getTokens(CSharpParser.LT)
            else:
                return self.getToken(CSharpParser.LT, i)

        def GT(self, i: int = None):
            if i is None:
                return self.getTokens(CSharpParser.GT)
            else:
                return self.getToken(CSharpParser.GT, i)

        def OP_LE(self, i: int = None):
            if i is None:
                return self.getTokens(CSharpParser.OP_LE)
            else:
                return self.getToken(CSharpParser.OP_LE, i)

        def OP_GE(self, i: int = None):
            if i is None:
                return self.getTokens(CSharpParser.OP_GE)
            else:
                return self.getToken(CSharpParser.OP_GE, i)

        def getRuleIndex(self):
            return CSharpParser.RULE_relational_expression

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterRelational_expression"):
                listener.enterRelational_expression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitRelational_expression"):
                listener.exitRelational_expression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitRelational_expression"):
                return visitor.visitRelational_expression(self)
            else:
                return visitor.visitChildren(self)

    def relational_expression(self):

        localctx = CSharpParser.Relational_expressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_relational_expression)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 657
            self.shift_expression()
            self.state = 666
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input, 37, self._ctx)
            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 664
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [CSharpParser.LT, CSharpParser.GT, CSharpParser.OP_LE, CSharpParser.OP_GE]:
                        self.state = 658
                        _la = self._input.LA(1)
                        if not (((((_la - 146)) & ~0x3f) == 0 and ((1 << (_la - 146)) & (
                                (1 << (CSharpParser.LT - 146)) | (1 << (CSharpParser.GT - 146)) | (
                                1 << (CSharpParser.OP_LE - 146)) | (1 << (CSharpParser.OP_GE - 146)))) != 0)):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 659
                        self.shift_expression()
                        pass
                    elif token in [CSharpParser.IS]:
                        self.state = 660
                        self.match(CSharpParser.IS)
                        self.state = 661
                        self.isType()
                        pass
                    elif token in [CSharpParser.AS]:
                        self.state = 662
                        self.match(CSharpParser.AS)
                        self.state = 663
                        self.type_()
                        pass
                    else:
                        raise NoViableAltException(self)

                self.state = 668
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 37, self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Shift_expressionContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def additive_expression(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(CSharpParser.Additive_expressionContext)
            else:
                return self.getTypedRuleContext(CSharpParser.Additive_expressionContext, i)

        def OP_LEFT_SHIFT(self, i: int = None):
            if i is None:
                return self.getTokens(CSharpParser.OP_LEFT_SHIFT)
            else:
                return self.getToken(CSharpParser.OP_LEFT_SHIFT, i)

        def right_shift(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(CSharpParser.Right_shiftContext)
            else:
                return self.getTypedRuleContext(CSharpParser.Right_shiftContext, i)

        def getRuleIndex(self):
            return CSharpParser.RULE_shift_expression

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterShift_expression"):
                listener.enterShift_expression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitShift_expression"):
                listener.exitShift_expression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitShift_expression"):
                return visitor.visitShift_expression(self)
            else:
                return visitor.visitChildren(self)

    def shift_expression(self):

        localctx = CSharpParser.Shift_expressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_shift_expression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 669
            self.additive_expression()
            self.state = 677
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input, 39, self._ctx)
            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 672
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [CSharpParser.OP_LEFT_SHIFT]:
                        self.state = 670
                        self.match(CSharpParser.OP_LEFT_SHIFT)
                        pass
                    elif token in [CSharpParser.GT]:
                        self.state = 671
                        self.right_shift()
                        pass
                    else:
                        raise NoViableAltException(self)

                    self.state = 674
                    self.additive_expression()
                self.state = 679
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 39, self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Additive_expressionContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def multiplicative_expression(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(CSharpParser.Multiplicative_expressionContext)
            else:
                return self.getTypedRuleContext(CSharpParser.Multiplicative_expressionContext, i)

        def PLUS(self, i: int = None):
            if i is None:
                return self.getTokens(CSharpParser.PLUS)
            else:
                return self.getToken(CSharpParser.PLUS, i)

        def MINUS(self, i: int = None):
            if i is None:
                return self.getTokens(CSharpParser.MINUS)
            else:
                return self.getToken(CSharpParser.MINUS, i)

        def getRuleIndex(self):
            return CSharpParser.RULE_additive_expression

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterAdditive_expression"):
                listener.enterAdditive_expression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitAdditive_expression"):
                listener.exitAdditive_expression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitAdditive_expression"):
                return visitor.visitAdditive_expression(self)
            else:
                return visitor.visitChildren(self)

    def additive_expression(self):

        localctx = CSharpParser.Additive_expressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_additive_expression)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 680
            self.multiplicative_expression()
            self.state = 685
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input, 40, self._ctx)
            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 681
                    _la = self._input.LA(1)
                    if not (_la == CSharpParser.PLUS or _la == CSharpParser.MINUS):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 682
                    self.multiplicative_expression()
                self.state = 687
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 40, self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Multiplicative_expressionContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def switch_expression(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(CSharpParser.Switch_expressionContext)
            else:
                return self.getTypedRuleContext(CSharpParser.Switch_expressionContext, i)

        def STAR(self, i: int = None):
            if i is None:
                return self.getTokens(CSharpParser.STAR)
            else:
                return self.getToken(CSharpParser.STAR, i)

        def DIV(self, i: int = None):
            if i is None:
                return self.getTokens(CSharpParser.DIV)
            else:
                return self.getToken(CSharpParser.DIV, i)

        def PERCENT(self, i: int = None):
            if i is None:
                return self.getTokens(CSharpParser.PERCENT)
            else:
                return self.getToken(CSharpParser.PERCENT, i)

        def getRuleIndex(self):
            return CSharpParser.RULE_multiplicative_expression

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterMultiplicative_expression"):
                listener.enterMultiplicative_expression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitMultiplicative_expression"):
                listener.exitMultiplicative_expression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitMultiplicative_expression"):
                return visitor.visitMultiplicative_expression(self)
            else:
                return visitor.visitChildren(self)

    def multiplicative_expression(self):

        localctx = CSharpParser.Multiplicative_expressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_multiplicative_expression)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 688
            self.switch_expression()
            self.state = 693
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input, 41, self._ctx)
            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 689
                    _la = self._input.LA(1)
                    if not (((((_la - 137)) & ~0x3f) == 0 and ((1 << (_la - 137)) & (
                            (1 << (CSharpParser.STAR - 137)) | (1 << (CSharpParser.DIV - 137)) | (
                            1 << (CSharpParser.PERCENT - 137)))) != 0)):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 690
                    self.switch_expression()
                self.state = 695
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 41, self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Switch_expressionContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def range_expression(self):
            return self.getTypedRuleContext(CSharpParser.Range_expressionContext, 0)

        def SWITCH(self):
            return self.getToken(CSharpParser.SWITCH, 0)

        def OPEN_BRACE(self):
            return self.getToken(CSharpParser.OPEN_BRACE, 0)

        def CLOSE_BRACE(self):
            return self.getToken(CSharpParser.CLOSE_BRACE, 0)

        def switch_expression_arms(self):
            return self.getTypedRuleContext(CSharpParser.Switch_expression_armsContext, 0)

        def COMMA(self):
            return self.getToken(CSharpParser.COMMA, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_switch_expression

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterSwitch_expression"):
                listener.enterSwitch_expression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitSwitch_expression"):
                listener.exitSwitch_expression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitSwitch_expression"):
                return visitor.visitSwitch_expression(self)
            else:
                return visitor.visitChildren(self)

    def switch_expression(self):

        localctx = CSharpParser.Switch_expressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_switch_expression)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 696
            self.range_expression()
            self.state = 706
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 44, self._ctx)
            if la_ == 1:
                self.state = 697
                self.match(CSharpParser.SWITCH)
                self.state = 698
                self.match(CSharpParser.OPEN_BRACE)
                self.state = 703
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & (
                        (1 << CSharpParser.ADD) | (1 << CSharpParser.ALIAS) | (1 << CSharpParser.ARGLIST) | (
                        1 << CSharpParser.ASCENDING) | (1 << CSharpParser.ASYNC) | (1 << CSharpParser.AWAIT) | (
                                1 << CSharpParser.BASE) | (1 << CSharpParser.BOOL) | (1 << CSharpParser.BY) | (
                                1 << CSharpParser.BYTE) | (1 << CSharpParser.CHAR) | (1 << CSharpParser.CHECKED) | (
                                1 << CSharpParser.DECIMAL) | (1 << CSharpParser.DEFAULT) | (
                                1 << CSharpParser.DELEGATE) | (1 << CSharpParser.DESCENDING) | (
                                1 << CSharpParser.DOUBLE) | (1 << CSharpParser.DYNAMIC) | (1 << CSharpParser.EQUALS) | (
                                1 << CSharpParser.FALSE) | (1 << CSharpParser.FLOAT) | (1 << CSharpParser.FROM) | (
                                1 << CSharpParser.GET) | (1 << CSharpParser.GROUP) | (1 << CSharpParser.INT) | (
                                1 << CSharpParser.INTO) | (1 << CSharpParser.JOIN) | (1 << CSharpParser.LET) | (
                                1 << CSharpParser.LONG))) != 0) or ((((_la - 64)) & ~0x3f) == 0 and (
                        (1 << (_la - 64)) & ((1 << (CSharpParser.NAMEOF - 64)) | (1 << (CSharpParser.NEW - 64)) | (
                        1 << (CSharpParser.NULL_ - 64)) | (1 << (CSharpParser.OBJECT - 64)) | (
                                                     1 << (CSharpParser.ON - 64)) | (
                                                     1 << (CSharpParser.ORDERBY - 64)) | (
                                                     1 << (CSharpParser.PARTIAL - 64)) | (
                                                     1 << (CSharpParser.REF - 64)) | (
                                                     1 << (CSharpParser.REMOVE - 64)) | (
                                                     1 << (CSharpParser.SBYTE - 64)) | (
                                                     1 << (CSharpParser.SELECT - 64)) | (
                                                     1 << (CSharpParser.SET - 64)) | (
                                                     1 << (CSharpParser.SHORT - 64)) | (
                                                     1 << (CSharpParser.SIZEOF - 64)) | (
                                                     1 << (CSharpParser.STRING - 64)) | (
                                                     1 << (CSharpParser.THIS - 64)) | (
                                                     1 << (CSharpParser.TRUE - 64)) | (
                                                     1 << (CSharpParser.TYPEOF - 64)) | (
                                                     1 << (CSharpParser.UINT - 64)) | (
                                                     1 << (CSharpParser.ULONG - 64)) | (
                                                     1 << (CSharpParser.UNCHECKED - 64)) | (
                                                     1 << (CSharpParser.UNMANAGED - 64)) | (
                                                     1 << (CSharpParser.USHORT - 64)) | (
                                                     1 << (CSharpParser.VAR - 64)) | (1 << (CSharpParser.WHEN - 64)) | (
                                                     1 << (CSharpParser.WHERE - 64)) | (
                                                     1 << (CSharpParser.YIELD - 64)) | (
                                                     1 << (CSharpParser.IDENTIFIER - 64)) | (
                                                     1 << (CSharpParser.LITERAL_ACCESS - 64)) | (
                                                     1 << (CSharpParser.INTEGER_LITERAL - 64)) | (
                                                     1 << (CSharpParser.HEX_INTEGER_LITERAL - 64)) | (
                                                     1 << (CSharpParser.BIN_INTEGER_LITERAL - 64)) | (
                                                     1 << (CSharpParser.REAL_LITERAL - 64)) | (
                                                     1 << (CSharpParser.CHARACTER_LITERAL - 64)) | (
                                                     1 << (CSharpParser.REGULAR_STRING - 64)) | (
                                                     1 << (CSharpParser.VERBATIUM_STRING - 64)) | (
                                                     1 << (CSharpParser.INTERPOLATED_REGULAR_STRING_START - 64)) | (
                                                     1 << (
                                                     CSharpParser.INTERPOLATED_VERBATIUM_STRING_START - 64)))) != 0) or (
                        (((_la - 129)) & ~0x3f) == 0 and ((1 << (_la - 129)) & (
                        (1 << (CSharpParser.OPEN_PARENS - 129)) | (1 << (CSharpParser.PLUS - 129)) | (
                        1 << (CSharpParser.MINUS - 129)) | (1 << (CSharpParser.STAR - 129)) | (
                                1 << (CSharpParser.AMP - 129)) | (1 << (CSharpParser.CARET - 129)) | (
                                1 << (CSharpParser.BANG - 129)) | (1 << (CSharpParser.TILDE - 129)) | (
                                1 << (CSharpParser.OP_INC - 129)) | (1 << (CSharpParser.OP_DEC - 129)) | (
                                1 << (CSharpParser.OP_RANGE - 129)))) != 0):
                    self.state = 699
                    self.switch_expression_arms()
                    self.state = 701
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la == CSharpParser.COMMA:
                        self.state = 700
                        self.match(CSharpParser.COMMA)

                self.state = 705
                self.match(CSharpParser.CLOSE_BRACE)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Switch_expression_armsContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def switch_expression_arm(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(CSharpParser.Switch_expression_armContext)
            else:
                return self.getTypedRuleContext(CSharpParser.Switch_expression_armContext, i)

        def COMMA(self, i: int = None):
            if i is None:
                return self.getTokens(CSharpParser.COMMA)
            else:
                return self.getToken(CSharpParser.COMMA, i)

        def getRuleIndex(self):
            return CSharpParser.RULE_switch_expression_arms

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterSwitch_expression_arms"):
                listener.enterSwitch_expression_arms(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitSwitch_expression_arms"):
                listener.exitSwitch_expression_arms(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitSwitch_expression_arms"):
                return visitor.visitSwitch_expression_arms(self)
            else:
                return visitor.visitChildren(self)

    def switch_expression_arms(self):

        localctx = CSharpParser.Switch_expression_armsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_switch_expression_arms)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 708
            self.switch_expression_arm()
            self.state = 713
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input, 45, self._ctx)
            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 709
                    self.match(CSharpParser.COMMA)
                    self.state = 710
                    self.switch_expression_arm()
                self.state = 715
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 45, self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Switch_expression_armContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(CSharpParser.ExpressionContext, 0)

        def right_arrow(self):
            return self.getTypedRuleContext(CSharpParser.Right_arrowContext, 0)

        def throwable_expression(self):
            return self.getTypedRuleContext(CSharpParser.Throwable_expressionContext, 0)

        def case_guard(self):
            return self.getTypedRuleContext(CSharpParser.Case_guardContext, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_switch_expression_arm

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterSwitch_expression_arm"):
                listener.enterSwitch_expression_arm(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitSwitch_expression_arm"):
                listener.exitSwitch_expression_arm(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitSwitch_expression_arm"):
                return visitor.visitSwitch_expression_arm(self)
            else:
                return visitor.visitChildren(self)

    def switch_expression_arm(self):

        localctx = CSharpParser.Switch_expression_armContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_switch_expression_arm)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 716
            self.expression()
            self.state = 718
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == CSharpParser.WHEN:
                self.state = 717
                self.case_guard()

            self.state = 720
            self.right_arrow()
            self.state = 721
            self.throwable_expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Range_expressionContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def unary_expression(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(CSharpParser.Unary_expressionContext)
            else:
                return self.getTypedRuleContext(CSharpParser.Unary_expressionContext, i)

        def OP_RANGE(self):
            return self.getToken(CSharpParser.OP_RANGE, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_range_expression

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterRange_expression"):
                listener.enterRange_expression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitRange_expression"):
                listener.exitRange_expression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitRange_expression"):
                return visitor.visitRange_expression(self)
            else:
                return visitor.visitChildren(self)

    def range_expression(self):

        localctx = CSharpParser.Range_expressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_range_expression)
        self._la = 0  # Token type
        try:
            self.state = 731
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 49, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 723
                self.unary_expression()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 725
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & (
                        (1 << CSharpParser.ADD) | (1 << CSharpParser.ALIAS) | (1 << CSharpParser.ARGLIST) | (
                        1 << CSharpParser.ASCENDING) | (1 << CSharpParser.ASYNC) | (1 << CSharpParser.AWAIT) | (
                                1 << CSharpParser.BASE) | (1 << CSharpParser.BOOL) | (1 << CSharpParser.BY) | (
                                1 << CSharpParser.BYTE) | (1 << CSharpParser.CHAR) | (1 << CSharpParser.CHECKED) | (
                                1 << CSharpParser.DECIMAL) | (1 << CSharpParser.DEFAULT) | (
                                1 << CSharpParser.DELEGATE) | (1 << CSharpParser.DESCENDING) | (
                                1 << CSharpParser.DOUBLE) | (1 << CSharpParser.DYNAMIC) | (1 << CSharpParser.EQUALS) | (
                                1 << CSharpParser.FALSE) | (1 << CSharpParser.FLOAT) | (1 << CSharpParser.FROM) | (
                                1 << CSharpParser.GET) | (1 << CSharpParser.GROUP) | (1 << CSharpParser.INT) | (
                                1 << CSharpParser.INTO) | (1 << CSharpParser.JOIN) | (1 << CSharpParser.LET) | (
                                1 << CSharpParser.LONG))) != 0) or ((((_la - 64)) & ~0x3f) == 0 and (
                        (1 << (_la - 64)) & ((1 << (CSharpParser.NAMEOF - 64)) | (1 << (CSharpParser.NEW - 64)) | (
                        1 << (CSharpParser.NULL_ - 64)) | (1 << (CSharpParser.OBJECT - 64)) | (
                                                     1 << (CSharpParser.ON - 64)) | (
                                                     1 << (CSharpParser.ORDERBY - 64)) | (
                                                     1 << (CSharpParser.PARTIAL - 64)) | (
                                                     1 << (CSharpParser.REMOVE - 64)) | (
                                                     1 << (CSharpParser.SBYTE - 64)) | (
                                                     1 << (CSharpParser.SELECT - 64)) | (
                                                     1 << (CSharpParser.SET - 64)) | (
                                                     1 << (CSharpParser.SHORT - 64)) | (
                                                     1 << (CSharpParser.SIZEOF - 64)) | (
                                                     1 << (CSharpParser.STRING - 64)) | (
                                                     1 << (CSharpParser.THIS - 64)) | (
                                                     1 << (CSharpParser.TRUE - 64)) | (
                                                     1 << (CSharpParser.TYPEOF - 64)) | (
                                                     1 << (CSharpParser.UINT - 64)) | (
                                                     1 << (CSharpParser.ULONG - 64)) | (
                                                     1 << (CSharpParser.UNCHECKED - 64)) | (
                                                     1 << (CSharpParser.UNMANAGED - 64)) | (
                                                     1 << (CSharpParser.USHORT - 64)) | (
                                                     1 << (CSharpParser.VAR - 64)) | (1 << (CSharpParser.WHEN - 64)) | (
                                                     1 << (CSharpParser.WHERE - 64)) | (
                                                     1 << (CSharpParser.YIELD - 64)) | (
                                                     1 << (CSharpParser.IDENTIFIER - 64)) | (
                                                     1 << (CSharpParser.LITERAL_ACCESS - 64)) | (
                                                     1 << (CSharpParser.INTEGER_LITERAL - 64)) | (
                                                     1 << (CSharpParser.HEX_INTEGER_LITERAL - 64)) | (
                                                     1 << (CSharpParser.BIN_INTEGER_LITERAL - 64)) | (
                                                     1 << (CSharpParser.REAL_LITERAL - 64)) | (
                                                     1 << (CSharpParser.CHARACTER_LITERAL - 64)) | (
                                                     1 << (CSharpParser.REGULAR_STRING - 64)) | (
                                                     1 << (CSharpParser.VERBATIUM_STRING - 64)) | (
                                                     1 << (CSharpParser.INTERPOLATED_REGULAR_STRING_START - 64)) | (
                                                     1 << (
                                                     CSharpParser.INTERPOLATED_VERBATIUM_STRING_START - 64)))) != 0) or (
                        (((_la - 129)) & ~0x3f) == 0 and ((1 << (_la - 129)) & (
                        (1 << (CSharpParser.OPEN_PARENS - 129)) | (1 << (CSharpParser.PLUS - 129)) | (
                        1 << (CSharpParser.MINUS - 129)) | (1 << (CSharpParser.STAR - 129)) | (
                                1 << (CSharpParser.AMP - 129)) | (1 << (CSharpParser.CARET - 129)) | (
                                1 << (CSharpParser.BANG - 129)) | (1 << (CSharpParser.TILDE - 129)) | (
                                1 << (CSharpParser.OP_INC - 129)) | (1 << (CSharpParser.OP_DEC - 129)))) != 0):
                    self.state = 724
                    self.unary_expression()

                self.state = 727
                self.match(CSharpParser.OP_RANGE)
                self.state = 729
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input, 48, self._ctx)
                if la_ == 1:
                    self.state = 728
                    self.unary_expression()

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Unary_expressionContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def cast_expression(self):
            return self.getTypedRuleContext(CSharpParser.Cast_expressionContext, 0)

        def primary_expression(self):
            return self.getTypedRuleContext(CSharpParser.Primary_expressionContext, 0)

        def PLUS(self):
            return self.getToken(CSharpParser.PLUS, 0)

        def unary_expression(self):
            return self.getTypedRuleContext(CSharpParser.Unary_expressionContext, 0)

        def MINUS(self):
            return self.getToken(CSharpParser.MINUS, 0)

        def BANG(self):
            return self.getToken(CSharpParser.BANG, 0)

        def TILDE(self):
            return self.getToken(CSharpParser.TILDE, 0)

        def OP_INC(self):
            return self.getToken(CSharpParser.OP_INC, 0)

        def OP_DEC(self):
            return self.getToken(CSharpParser.OP_DEC, 0)

        def AWAIT(self):
            return self.getToken(CSharpParser.AWAIT, 0)

        def AMP(self):
            return self.getToken(CSharpParser.AMP, 0)

        def STAR(self):
            return self.getToken(CSharpParser.STAR, 0)

        def CARET(self):
            return self.getToken(CSharpParser.CARET, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_unary_expression

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterUnary_expression"):
                listener.enterUnary_expression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitUnary_expression"):
                listener.exitUnary_expression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitUnary_expression"):
                return visitor.visitUnary_expression(self)
            else:
                return visitor.visitChildren(self)

    def unary_expression(self):

        localctx = CSharpParser.Unary_expressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_unary_expression)
        try:
            self.state = 755
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 50, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 733
                self.cast_expression()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 734
                self.primary_expression()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 735
                self.match(CSharpParser.PLUS)
                self.state = 736
                self.unary_expression()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 737
                self.match(CSharpParser.MINUS)
                self.state = 738
                self.unary_expression()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 739
                self.match(CSharpParser.BANG)
                self.state = 740
                self.unary_expression()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 741
                self.match(CSharpParser.TILDE)
                self.state = 742
                self.unary_expression()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 743
                self.match(CSharpParser.OP_INC)
                self.state = 744
                self.unary_expression()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 745
                self.match(CSharpParser.OP_DEC)
                self.state = 746
                self.unary_expression()
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 747
                self.match(CSharpParser.AWAIT)
                self.state = 748
                self.unary_expression()
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 749
                self.match(CSharpParser.AMP)
                self.state = 750
                self.unary_expression()
                pass

            elif la_ == 11:
                self.enterOuterAlt(localctx, 11)
                self.state = 751
                self.match(CSharpParser.STAR)
                self.state = 752
                self.unary_expression()
                pass

            elif la_ == 12:
                self.enterOuterAlt(localctx, 12)
                self.state = 753
                self.match(CSharpParser.CARET)
                self.state = 754
                self.unary_expression()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Cast_expressionContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPEN_PARENS(self):
            return self.getToken(CSharpParser.OPEN_PARENS, 0)

        def type_(self):
            return self.getTypedRuleContext(CSharpParser.Type_Context, 0)

        def CLOSE_PARENS(self):
            return self.getToken(CSharpParser.CLOSE_PARENS, 0)

        def unary_expression(self):
            return self.getTypedRuleContext(CSharpParser.Unary_expressionContext, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_cast_expression

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterCast_expression"):
                listener.enterCast_expression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitCast_expression"):
                listener.exitCast_expression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitCast_expression"):
                return visitor.visitCast_expression(self)
            else:
                return visitor.visitChildren(self)

    def cast_expression(self):

        localctx = CSharpParser.Cast_expressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_cast_expression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 757
            self.match(CSharpParser.OPEN_PARENS)
            self.state = 758
            self.type_()
            self.state = 759
            self.match(CSharpParser.CLOSE_PARENS)
            self.state = 760
            self.unary_expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Primary_expressionContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.pe = None  # Primary_expression_startContext

        def primary_expression_start(self):
            return self.getTypedRuleContext(CSharpParser.Primary_expression_startContext, 0)

        def BANG(self, i: int = None):
            if i is None:
                return self.getTokens(CSharpParser.BANG)
            else:
                return self.getToken(CSharpParser.BANG, i)

        def bracket_expression(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(CSharpParser.Bracket_expressionContext)
            else:
                return self.getTypedRuleContext(CSharpParser.Bracket_expressionContext, i)

        def member_access(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(CSharpParser.Member_accessContext)
            else:
                return self.getTypedRuleContext(CSharpParser.Member_accessContext, i)

        def method_invocation(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(CSharpParser.Method_invocationContext)
            else:
                return self.getTypedRuleContext(CSharpParser.Method_invocationContext, i)

        def OP_INC(self, i: int = None):
            if i is None:
                return self.getTokens(CSharpParser.OP_INC)
            else:
                return self.getToken(CSharpParser.OP_INC, i)

        def OP_DEC(self, i: int = None):
            if i is None:
                return self.getTokens(CSharpParser.OP_DEC)
            else:
                return self.getToken(CSharpParser.OP_DEC, i)

        def OP_PTR(self, i: int = None):
            if i is None:
                return self.getTokens(CSharpParser.OP_PTR)
            else:
                return self.getToken(CSharpParser.OP_PTR, i)

        def identifier(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(CSharpParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(CSharpParser.IdentifierContext, i)

        def getRuleIndex(self):
            return CSharpParser.RULE_primary_expression

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterPrimary_expression"):
                listener.enterPrimary_expression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitPrimary_expression"):
                listener.exitPrimary_expression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitPrimary_expression"):
                return visitor.visitPrimary_expression(self)
            else:
                return visitor.visitChildren(self)

    def primary_expression(self):

        localctx = CSharpParser.Primary_expressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_primary_expression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 762
            localctx.pe = self.primary_expression_start()
            self.state = 764
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 51, self._ctx)
            if la_ == 1:
                self.state = 763
                self.match(CSharpParser.BANG)

            self.state = 769
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input, 52, self._ctx)
            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 766
                    self.bracket_expression()
                self.state = 771
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 52, self._ctx)

            self.state = 773
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 53, self._ctx)
            if la_ == 1:
                self.state = 772
                self.match(CSharpParser.BANG)

            self.state = 797
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input, 58, self._ctx)
            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 781
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [CSharpParser.DOT, CSharpParser.INTERR]:
                        self.state = 775
                        self.member_access()
                        pass
                    elif token in [CSharpParser.OPEN_PARENS]:
                        self.state = 776
                        self.method_invocation()
                        pass
                    elif token in [CSharpParser.OP_INC]:
                        self.state = 777
                        self.match(CSharpParser.OP_INC)
                        pass
                    elif token in [CSharpParser.OP_DEC]:
                        self.state = 778
                        self.match(CSharpParser.OP_DEC)
                        pass
                    elif token in [CSharpParser.OP_PTR]:
                        self.state = 779
                        self.match(CSharpParser.OP_PTR)
                        self.state = 780
                        self.identifier()
                        pass
                    else:
                        raise NoViableAltException(self)

                    self.state = 784
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input, 55, self._ctx)
                    if la_ == 1:
                        self.state = 783
                        self.match(CSharpParser.BANG)

                    self.state = 789
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input, 56, self._ctx)
                    while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                        if _alt == 1:
                            self.state = 786
                            self.bracket_expression()
                        self.state = 791
                        self._errHandler.sync(self)
                        _alt = self._interp.adaptivePredict(self._input, 56, self._ctx)

                    self.state = 793
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input, 57, self._ctx)
                    if la_ == 1:
                        self.state = 792
                        self.match(CSharpParser.BANG)

                self.state = 799
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 58, self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Primary_expression_startContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def getRuleIndex(self):
            return CSharpParser.RULE_primary_expression_start

        def copyFrom(self, ctx: ParserRuleContext):
            super().copyFrom(ctx)

    class LiteralAccessExpressionContext(Primary_expression_startContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a CSharpParser.Primary_expression_startContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LITERAL_ACCESS(self):
            return self.getToken(CSharpParser.LITERAL_ACCESS, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterLiteralAccessExpression"):
                listener.enterLiteralAccessExpression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitLiteralAccessExpression"):
                listener.exitLiteralAccessExpression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitLiteralAccessExpression"):
                return visitor.visitLiteralAccessExpression(self)
            else:
                return visitor.visitChildren(self)

    class DefaultValueExpressionContext(Primary_expression_startContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a CSharpParser.Primary_expression_startContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DEFAULT(self):
            return self.getToken(CSharpParser.DEFAULT, 0)

        def OPEN_PARENS(self):
            return self.getToken(CSharpParser.OPEN_PARENS, 0)

        def type_(self):
            return self.getTypedRuleContext(CSharpParser.Type_Context, 0)

        def CLOSE_PARENS(self):
            return self.getToken(CSharpParser.CLOSE_PARENS, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterDefaultValueExpression"):
                listener.enterDefaultValueExpression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitDefaultValueExpression"):
                listener.exitDefaultValueExpression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitDefaultValueExpression"):
                return visitor.visitDefaultValueExpression(self)
            else:
                return visitor.visitChildren(self)

    class BaseAccessExpressionContext(Primary_expression_startContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a CSharpParser.Primary_expression_startContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def BASE(self):
            return self.getToken(CSharpParser.BASE, 0)

        def DOT(self):
            return self.getToken(CSharpParser.DOT, 0)

        def identifier(self):
            return self.getTypedRuleContext(CSharpParser.IdentifierContext, 0)

        def OPEN_BRACKET(self):
            return self.getToken(CSharpParser.OPEN_BRACKET, 0)

        def expression_list(self):
            return self.getTypedRuleContext(CSharpParser.Expression_listContext, 0)

        def CLOSE_BRACKET(self):
            return self.getToken(CSharpParser.CLOSE_BRACKET, 0)

        def type_argument_list(self):
            return self.getTypedRuleContext(CSharpParser.Type_argument_listContext, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterBaseAccessExpression"):
                listener.enterBaseAccessExpression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitBaseAccessExpression"):
                listener.exitBaseAccessExpression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitBaseAccessExpression"):
                return visitor.visitBaseAccessExpression(self)
            else:
                return visitor.visitChildren(self)

    class SizeofExpressionContext(Primary_expression_startContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a CSharpParser.Primary_expression_startContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def SIZEOF(self):
            return self.getToken(CSharpParser.SIZEOF, 0)

        def OPEN_PARENS(self):
            return self.getToken(CSharpParser.OPEN_PARENS, 0)

        def type_(self):
            return self.getTypedRuleContext(CSharpParser.Type_Context, 0)

        def CLOSE_PARENS(self):
            return self.getToken(CSharpParser.CLOSE_PARENS, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterSizeofExpression"):
                listener.enterSizeofExpression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitSizeofExpression"):
                listener.exitSizeofExpression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitSizeofExpression"):
                return visitor.visitSizeofExpression(self)
            else:
                return visitor.visitChildren(self)

    class ParenthesisExpressionsContext(Primary_expression_startContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a CSharpParser.Primary_expression_startContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def OPEN_PARENS(self):
            return self.getToken(CSharpParser.OPEN_PARENS, 0)

        def expression(self):
            return self.getTypedRuleContext(CSharpParser.ExpressionContext, 0)

        def CLOSE_PARENS(self):
            return self.getToken(CSharpParser.CLOSE_PARENS, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterParenthesisExpressions"):
                listener.enterParenthesisExpressions(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitParenthesisExpressions"):
                listener.exitParenthesisExpressions(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitParenthesisExpressions"):
                return visitor.visitParenthesisExpressions(self)
            else:
                return visitor.visitChildren(self)

    class ThisReferenceExpressionContext(Primary_expression_startContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a CSharpParser.Primary_expression_startContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def THIS(self):
            return self.getToken(CSharpParser.THIS, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterThisReferenceExpression"):
                listener.enterThisReferenceExpression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitThisReferenceExpression"):
                listener.exitThisReferenceExpression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitThisReferenceExpression"):
                return visitor.visitThisReferenceExpression(self)
            else:
                return visitor.visitChildren(self)

    class ObjectCreationExpressionContext(Primary_expression_startContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a CSharpParser.Primary_expression_startContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def NEW(self):
            return self.getToken(CSharpParser.NEW, 0)

        def type_(self):
            return self.getTypedRuleContext(CSharpParser.Type_Context, 0)

        def anonymous_object_initializer(self):
            return self.getTypedRuleContext(CSharpParser.Anonymous_object_initializerContext, 0)

        def rank_specifier(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(CSharpParser.Rank_specifierContext)
            else:
                return self.getTypedRuleContext(CSharpParser.Rank_specifierContext, i)

        def array_initializer(self):
            return self.getTypedRuleContext(CSharpParser.Array_initializerContext, 0)

        def object_creation_expression(self):
            return self.getTypedRuleContext(CSharpParser.Object_creation_expressionContext, 0)

        def object_or_collection_initializer(self):
            return self.getTypedRuleContext(CSharpParser.Object_or_collection_initializerContext, 0)

        def OPEN_BRACKET(self):
            return self.getToken(CSharpParser.OPEN_BRACKET, 0)

        def expression_list(self):
            return self.getTypedRuleContext(CSharpParser.Expression_listContext, 0)

        def CLOSE_BRACKET(self):
            return self.getToken(CSharpParser.CLOSE_BRACKET, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterObjectCreationExpression"):
                listener.enterObjectCreationExpression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitObjectCreationExpression"):
                listener.exitObjectCreationExpression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitObjectCreationExpression"):
                return visitor.visitObjectCreationExpression(self)
            else:
                return visitor.visitChildren(self)

    class AnonymousMethodExpressionContext(Primary_expression_startContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a CSharpParser.Primary_expression_startContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DELEGATE(self):
            return self.getToken(CSharpParser.DELEGATE, 0)

        def block(self):
            return self.getTypedRuleContext(CSharpParser.BlockContext, 0)

        def ASYNC(self):
            return self.getToken(CSharpParser.ASYNC, 0)

        def OPEN_PARENS(self):
            return self.getToken(CSharpParser.OPEN_PARENS, 0)

        def CLOSE_PARENS(self):
            return self.getToken(CSharpParser.CLOSE_PARENS, 0)

        def explicit_anonymous_function_parameter_list(self):
            return self.getTypedRuleContext(CSharpParser.Explicit_anonymous_function_parameter_listContext, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterAnonymousMethodExpression"):
                listener.enterAnonymousMethodExpression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitAnonymousMethodExpression"):
                listener.exitAnonymousMethodExpression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitAnonymousMethodExpression"):
                return visitor.visitAnonymousMethodExpression(self)
            else:
                return visitor.visitChildren(self)

    class TypeofExpressionContext(Primary_expression_startContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a CSharpParser.Primary_expression_startContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def TYPEOF(self):
            return self.getToken(CSharpParser.TYPEOF, 0)

        def OPEN_PARENS(self):
            return self.getToken(CSharpParser.OPEN_PARENS, 0)

        def CLOSE_PARENS(self):
            return self.getToken(CSharpParser.CLOSE_PARENS, 0)

        def unbound_type_name(self):
            return self.getTypedRuleContext(CSharpParser.Unbound_type_nameContext, 0)

        def type_(self):
            return self.getTypedRuleContext(CSharpParser.Type_Context, 0)

        def VOID(self):
            return self.getToken(CSharpParser.VOID, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterTypeofExpression"):
                listener.enterTypeofExpression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitTypeofExpression"):
                listener.exitTypeofExpression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitTypeofExpression"):
                return visitor.visitTypeofExpression(self)
            else:
                return visitor.visitChildren(self)

    class TupleExpressionContext(Primary_expression_startContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a CSharpParser.Primary_expression_startContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def OPEN_PARENS(self):
            return self.getToken(CSharpParser.OPEN_PARENS, 0)

        def argument(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(CSharpParser.ArgumentContext)
            else:
                return self.getTypedRuleContext(CSharpParser.ArgumentContext, i)

        def CLOSE_PARENS(self):
            return self.getToken(CSharpParser.CLOSE_PARENS, 0)

        def COMMA(self, i: int = None):
            if i is None:
                return self.getTokens(CSharpParser.COMMA)
            else:
                return self.getToken(CSharpParser.COMMA, i)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterTupleExpression"):
                listener.enterTupleExpression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitTupleExpression"):
                listener.exitTupleExpression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitTupleExpression"):
                return visitor.visitTupleExpression(self)
            else:
                return visitor.visitChildren(self)

    class UncheckedExpressionContext(Primary_expression_startContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a CSharpParser.Primary_expression_startContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def UNCHECKED(self):
            return self.getToken(CSharpParser.UNCHECKED, 0)

        def OPEN_PARENS(self):
            return self.getToken(CSharpParser.OPEN_PARENS, 0)

        def expression(self):
            return self.getTypedRuleContext(CSharpParser.ExpressionContext, 0)

        def CLOSE_PARENS(self):
            return self.getToken(CSharpParser.CLOSE_PARENS, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterUncheckedExpression"):
                listener.enterUncheckedExpression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitUncheckedExpression"):
                listener.exitUncheckedExpression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitUncheckedExpression"):
                return visitor.visitUncheckedExpression(self)
            else:
                return visitor.visitChildren(self)

    class SimpleNameExpressionContext(Primary_expression_startContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a CSharpParser.Primary_expression_startContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(CSharpParser.IdentifierContext, 0)

        def type_argument_list(self):
            return self.getTypedRuleContext(CSharpParser.Type_argument_listContext, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterSimpleNameExpression"):
                listener.enterSimpleNameExpression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitSimpleNameExpression"):
                listener.exitSimpleNameExpression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitSimpleNameExpression"):
                return visitor.visitSimpleNameExpression(self)
            else:
                return visitor.visitChildren(self)

    class MemberAccessExpressionContext(Primary_expression_startContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a CSharpParser.Primary_expression_startContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def predefined_type(self):
            return self.getTypedRuleContext(CSharpParser.Predefined_typeContext, 0)

        def qualified_alias_member(self):
            return self.getTypedRuleContext(CSharpParser.Qualified_alias_memberContext, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterMemberAccessExpression"):
                listener.enterMemberAccessExpression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitMemberAccessExpression"):
                listener.exitMemberAccessExpression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitMemberAccessExpression"):
                return visitor.visitMemberAccessExpression(self)
            else:
                return visitor.visitChildren(self)

    class CheckedExpressionContext(Primary_expression_startContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a CSharpParser.Primary_expression_startContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def CHECKED(self):
            return self.getToken(CSharpParser.CHECKED, 0)

        def OPEN_PARENS(self):
            return self.getToken(CSharpParser.OPEN_PARENS, 0)

        def expression(self):
            return self.getTypedRuleContext(CSharpParser.ExpressionContext, 0)

        def CLOSE_PARENS(self):
            return self.getToken(CSharpParser.CLOSE_PARENS, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterCheckedExpression"):
                listener.enterCheckedExpression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitCheckedExpression"):
                listener.exitCheckedExpression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitCheckedExpression"):
                return visitor.visitCheckedExpression(self)
            else:
                return visitor.visitChildren(self)

    class LiteralExpressionContext(Primary_expression_startContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a CSharpParser.Primary_expression_startContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def literal(self):
            return self.getTypedRuleContext(CSharpParser.LiteralContext, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterLiteralExpression"):
                listener.enterLiteralExpression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitLiteralExpression"):
                listener.exitLiteralExpression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitLiteralExpression"):
                return visitor.visitLiteralExpression(self)
            else:
                return visitor.visitChildren(self)

    class NameofExpressionContext(Primary_expression_startContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a CSharpParser.Primary_expression_startContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def NAMEOF(self):
            return self.getToken(CSharpParser.NAMEOF, 0)

        def OPEN_PARENS(self):
            return self.getToken(CSharpParser.OPEN_PARENS, 0)

        def identifier(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(CSharpParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(CSharpParser.IdentifierContext, i)

        def CLOSE_PARENS(self):
            return self.getToken(CSharpParser.CLOSE_PARENS, 0)

        def DOT(self, i: int = None):
            if i is None:
                return self.getTokens(CSharpParser.DOT)
            else:
                return self.getToken(CSharpParser.DOT, i)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterNameofExpression"):
                listener.enterNameofExpression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitNameofExpression"):
                listener.exitNameofExpression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitNameofExpression"):
                return visitor.visitNameofExpression(self)
            else:
                return visitor.visitChildren(self)

    def primary_expression_start(self):

        localctx = CSharpParser.Primary_expression_startContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_primary_expression_start)
        self._la = 0  # Token type
        try:
            self.state = 921
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 74, self._ctx)
            if la_ == 1:
                localctx = CSharpParser.LiteralExpressionContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 800
                self.literal()
                pass

            elif la_ == 2:
                localctx = CSharpParser.SimpleNameExpressionContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 801
                self.identifier()
                self.state = 803
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input, 59, self._ctx)
                if la_ == 1:
                    self.state = 802
                    self.type_argument_list()

                pass

            elif la_ == 3:
                localctx = CSharpParser.ParenthesisExpressionsContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 805
                self.match(CSharpParser.OPEN_PARENS)
                self.state = 806
                self.expression()
                self.state = 807
                self.match(CSharpParser.CLOSE_PARENS)
                pass

            elif la_ == 4:
                localctx = CSharpParser.MemberAccessExpressionContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 809
                self.predefined_type()
                pass

            elif la_ == 5:
                localctx = CSharpParser.MemberAccessExpressionContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 810
                self.qualified_alias_member()
                pass

            elif la_ == 6:
                localctx = CSharpParser.LiteralAccessExpressionContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 811
                self.match(CSharpParser.LITERAL_ACCESS)
                pass

            elif la_ == 7:
                localctx = CSharpParser.ThisReferenceExpressionContext(self, localctx)
                self.enterOuterAlt(localctx, 7)
                self.state = 812
                self.match(CSharpParser.THIS)
                pass

            elif la_ == 8:
                localctx = CSharpParser.BaseAccessExpressionContext(self, localctx)
                self.enterOuterAlt(localctx, 8)
                self.state = 813
                self.match(CSharpParser.BASE)
                self.state = 823
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [CSharpParser.DOT]:
                    self.state = 814
                    self.match(CSharpParser.DOT)
                    self.state = 815
                    self.identifier()
                    self.state = 817
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input, 60, self._ctx)
                    if la_ == 1:
                        self.state = 816
                        self.type_argument_list()

                    pass
                elif token in [CSharpParser.OPEN_BRACKET]:
                    self.state = 819
                    self.match(CSharpParser.OPEN_BRACKET)
                    self.state = 820
                    self.expression_list()
                    self.state = 821
                    self.match(CSharpParser.CLOSE_BRACKET)
                    pass
                else:
                    raise NoViableAltException(self)

                pass

            elif la_ == 9:
                localctx = CSharpParser.ObjectCreationExpressionContext(self, localctx)
                self.enterOuterAlt(localctx, 9)
                self.state = 825
                self.match(CSharpParser.NEW)
                self.state = 854
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [CSharpParser.ADD, CSharpParser.ALIAS, CSharpParser.ARGLIST, CSharpParser.ASCENDING,
                             CSharpParser.ASYNC, CSharpParser.AWAIT, CSharpParser.BOOL, CSharpParser.BY,
                             CSharpParser.BYTE, CSharpParser.CHAR, CSharpParser.DECIMAL, CSharpParser.DESCENDING,
                             CSharpParser.DOUBLE, CSharpParser.DYNAMIC, CSharpParser.EQUALS, CSharpParser.FLOAT,
                             CSharpParser.FROM, CSharpParser.GET, CSharpParser.GROUP, CSharpParser.INT,
                             CSharpParser.INTO, CSharpParser.JOIN, CSharpParser.LET, CSharpParser.LONG,
                             CSharpParser.NAMEOF, CSharpParser.OBJECT, CSharpParser.ON, CSharpParser.ORDERBY,
                             CSharpParser.PARTIAL, CSharpParser.REMOVE, CSharpParser.SBYTE, CSharpParser.SELECT,
                             CSharpParser.SET, CSharpParser.SHORT, CSharpParser.STRING, CSharpParser.UINT,
                             CSharpParser.ULONG, CSharpParser.UNMANAGED, CSharpParser.USHORT, CSharpParser.VAR,
                             CSharpParser.VOID, CSharpParser.WHEN, CSharpParser.WHERE, CSharpParser.YIELD,
                             CSharpParser.IDENTIFIER, CSharpParser.OPEN_PARENS]:
                    self.state = 826
                    self.type_()
                    self.state = 848
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input, 65, self._ctx)
                    if la_ == 1:
                        self.state = 827
                        self.object_creation_expression()
                        pass

                    elif la_ == 2:
                        self.state = 828
                        self.object_or_collection_initializer()
                        pass

                    elif la_ == 3:
                        self.state = 829
                        self.match(CSharpParser.OPEN_BRACKET)
                        self.state = 830
                        self.expression_list()
                        self.state = 831
                        self.match(CSharpParser.CLOSE_BRACKET)
                        self.state = 835
                        self._errHandler.sync(self)
                        _alt = self._interp.adaptivePredict(self._input, 62, self._ctx)
                        while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                            if _alt == 1:
                                self.state = 832
                                self.rank_specifier()
                            self.state = 837
                            self._errHandler.sync(self)
                            _alt = self._interp.adaptivePredict(self._input, 62, self._ctx)

                        self.state = 839
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input, 63, self._ctx)
                        if la_ == 1:
                            self.state = 838
                            self.array_initializer()

                        pass

                    elif la_ == 4:
                        self.state = 842
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        while True:
                            self.state = 841
                            self.rank_specifier()
                            self.state = 844
                            self._errHandler.sync(self)
                            _la = self._input.LA(1)
                            if not (_la == CSharpParser.OPEN_BRACKET):
                                break

                        self.state = 846
                        self.array_initializer()
                        pass

                    pass
                elif token in [CSharpParser.OPEN_BRACE]:
                    self.state = 850
                    self.anonymous_object_initializer()
                    pass
                elif token in [CSharpParser.OPEN_BRACKET]:
                    self.state = 851
                    self.rank_specifier()
                    self.state = 852
                    self.array_initializer()
                    pass
                else:
                    raise NoViableAltException(self)

                pass

            elif la_ == 10:
                localctx = CSharpParser.TupleExpressionContext(self, localctx)
                self.enterOuterAlt(localctx, 10)
                self.state = 856
                self.match(CSharpParser.OPEN_PARENS)
                self.state = 857
                self.argument()
                self.state = 860
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 858
                    self.match(CSharpParser.COMMA)
                    self.state = 859
                    self.argument()
                    self.state = 862
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la == CSharpParser.COMMA):
                        break

                self.state = 864
                self.match(CSharpParser.CLOSE_PARENS)
                pass

            elif la_ == 11:
                localctx = CSharpParser.TypeofExpressionContext(self, localctx)
                self.enterOuterAlt(localctx, 11)
                self.state = 866
                self.match(CSharpParser.TYPEOF)
                self.state = 867
                self.match(CSharpParser.OPEN_PARENS)
                self.state = 871
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input, 68, self._ctx)
                if la_ == 1:
                    self.state = 868
                    self.unbound_type_name()
                    pass

                elif la_ == 2:
                    self.state = 869
                    self.type_()
                    pass

                elif la_ == 3:
                    self.state = 870
                    self.match(CSharpParser.VOID)
                    pass

                self.state = 873
                self.match(CSharpParser.CLOSE_PARENS)
                pass

            elif la_ == 12:
                localctx = CSharpParser.CheckedExpressionContext(self, localctx)
                self.enterOuterAlt(localctx, 12)
                self.state = 874
                self.match(CSharpParser.CHECKED)
                self.state = 875
                self.match(CSharpParser.OPEN_PARENS)
                self.state = 876
                self.expression()
                self.state = 877
                self.match(CSharpParser.CLOSE_PARENS)
                pass

            elif la_ == 13:
                localctx = CSharpParser.UncheckedExpressionContext(self, localctx)
                self.enterOuterAlt(localctx, 13)
                self.state = 879
                self.match(CSharpParser.UNCHECKED)
                self.state = 880
                self.match(CSharpParser.OPEN_PARENS)
                self.state = 881
                self.expression()
                self.state = 882
                self.match(CSharpParser.CLOSE_PARENS)
                pass

            elif la_ == 14:
                localctx = CSharpParser.DefaultValueExpressionContext(self, localctx)
                self.enterOuterAlt(localctx, 14)
                self.state = 884
                self.match(CSharpParser.DEFAULT)
                self.state = 889
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input, 69, self._ctx)
                if la_ == 1:
                    self.state = 885
                    self.match(CSharpParser.OPEN_PARENS)
                    self.state = 886
                    self.type_()
                    self.state = 887
                    self.match(CSharpParser.CLOSE_PARENS)

                pass

            elif la_ == 15:
                localctx = CSharpParser.AnonymousMethodExpressionContext(self, localctx)
                self.enterOuterAlt(localctx, 15)
                self.state = 892
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == CSharpParser.ASYNC:
                    self.state = 891
                    self.match(CSharpParser.ASYNC)

                self.state = 894
                self.match(CSharpParser.DELEGATE)
                self.state = 900
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == CSharpParser.OPEN_PARENS:
                    self.state = 895
                    self.match(CSharpParser.OPEN_PARENS)
                    self.state = 897
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if ((((_la - 10)) & ~0x3f) == 0 and ((1 << (_la - 10)) & (
                            (1 << (CSharpParser.ADD - 10)) | (1 << (CSharpParser.ALIAS - 10)) | (
                            1 << (CSharpParser.ARGLIST - 10)) | (1 << (CSharpParser.ASCENDING - 10)) | (
                                    1 << (CSharpParser.ASYNC - 10)) | (1 << (CSharpParser.AWAIT - 10)) | (
                                    1 << (CSharpParser.BOOL - 10)) | (1 << (CSharpParser.BY - 10)) | (
                                    1 << (CSharpParser.BYTE - 10)) | (1 << (CSharpParser.CHAR - 10)) | (
                                    1 << (CSharpParser.DECIMAL - 10)) | (1 << (CSharpParser.DESCENDING - 10)) | (
                                    1 << (CSharpParser.DOUBLE - 10)) | (1 << (CSharpParser.DYNAMIC - 10)) | (
                                    1 << (CSharpParser.EQUALS - 10)) | (1 << (CSharpParser.FLOAT - 10)) | (
                                    1 << (CSharpParser.FROM - 10)) | (1 << (CSharpParser.GET - 10)) | (
                                    1 << (CSharpParser.GROUP - 10)) | (1 << (CSharpParser.IN - 10)) | (
                                    1 << (CSharpParser.INT - 10)) | (1 << (CSharpParser.INTO - 10)) | (
                                    1 << (CSharpParser.JOIN - 10)) | (1 << (CSharpParser.LET - 10)) | (
                                    1 << (CSharpParser.LONG - 10)) | (1 << (CSharpParser.NAMEOF - 10)) | (
                                    1 << (CSharpParser.OBJECT - 10)) | (1 << (CSharpParser.ON - 10)) | (
                                    1 << (CSharpParser.ORDERBY - 10)) | (1 << (CSharpParser.OUT - 10)))) != 0) or (
                            (((_la - 75)) & ~0x3f) == 0 and ((1 << (_la - 75)) & (
                            (1 << (CSharpParser.PARTIAL - 75)) | (1 << (CSharpParser.REF - 75)) | (
                            1 << (CSharpParser.REMOVE - 75)) | (1 << (CSharpParser.SBYTE - 75)) | (
                                    1 << (CSharpParser.SELECT - 75)) | (1 << (CSharpParser.SET - 75)) | (
                                    1 << (CSharpParser.SHORT - 75)) | (1 << (CSharpParser.STRING - 75)) | (
                                    1 << (CSharpParser.UINT - 75)) | (1 << (CSharpParser.ULONG - 75)) | (
                                    1 << (CSharpParser.UNMANAGED - 75)) | (1 << (CSharpParser.USHORT - 75)) | (
                                    1 << (CSharpParser.VAR - 75)) | (1 << (CSharpParser.VOID - 75)) | (
                                    1 << (CSharpParser.WHEN - 75)) | (1 << (CSharpParser.WHERE - 75)) | (
                                    1 << (CSharpParser.YIELD - 75)) | (1 << (CSharpParser.IDENTIFIER - 75)) | (
                                    1 << (CSharpParser.OPEN_PARENS - 75)))) != 0):
                        self.state = 896
                        self.explicit_anonymous_function_parameter_list()

                    self.state = 899
                    self.match(CSharpParser.CLOSE_PARENS)

                self.state = 902
                self.block()
                pass

            elif la_ == 16:
                localctx = CSharpParser.SizeofExpressionContext(self, localctx)
                self.enterOuterAlt(localctx, 16)
                self.state = 903
                self.match(CSharpParser.SIZEOF)
                self.state = 904
                self.match(CSharpParser.OPEN_PARENS)
                self.state = 905
                self.type_()
                self.state = 906
                self.match(CSharpParser.CLOSE_PARENS)
                pass

            elif la_ == 17:
                localctx = CSharpParser.NameofExpressionContext(self, localctx)
                self.enterOuterAlt(localctx, 17)
                self.state = 908
                self.match(CSharpParser.NAMEOF)
                self.state = 909
                self.match(CSharpParser.OPEN_PARENS)
                self.state = 915
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 73, self._ctx)
                while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 910
                        self.identifier()
                        self.state = 911
                        self.match(CSharpParser.DOT)
                    self.state = 917
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input, 73, self._ctx)

                self.state = 918
                self.identifier()
                self.state = 919
                self.match(CSharpParser.CLOSE_PARENS)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Throwable_expressionContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(CSharpParser.ExpressionContext, 0)

        def throw_expression(self):
            return self.getTypedRuleContext(CSharpParser.Throw_expressionContext, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_throwable_expression

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterThrowable_expression"):
                listener.enterThrowable_expression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitThrowable_expression"):
                listener.exitThrowable_expression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitThrowable_expression"):
                return visitor.visitThrowable_expression(self)
            else:
                return visitor.visitChildren(self)

    def throwable_expression(self):

        localctx = CSharpParser.Throwable_expressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_throwable_expression)
        try:
            self.state = 925
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [CSharpParser.ADD, CSharpParser.ALIAS, CSharpParser.ARGLIST, CSharpParser.ASCENDING,
                         CSharpParser.ASYNC, CSharpParser.AWAIT, CSharpParser.BASE, CSharpParser.BOOL, CSharpParser.BY,
                         CSharpParser.BYTE, CSharpParser.CHAR, CSharpParser.CHECKED, CSharpParser.DECIMAL,
                         CSharpParser.DEFAULT, CSharpParser.DELEGATE, CSharpParser.DESCENDING, CSharpParser.DOUBLE,
                         CSharpParser.DYNAMIC, CSharpParser.EQUALS, CSharpParser.FALSE, CSharpParser.FLOAT,
                         CSharpParser.FROM, CSharpParser.GET, CSharpParser.GROUP, CSharpParser.INT, CSharpParser.INTO,
                         CSharpParser.JOIN, CSharpParser.LET, CSharpParser.LONG, CSharpParser.NAMEOF, CSharpParser.NEW,
                         CSharpParser.NULL_, CSharpParser.OBJECT, CSharpParser.ON, CSharpParser.ORDERBY,
                         CSharpParser.PARTIAL, CSharpParser.REF, CSharpParser.REMOVE, CSharpParser.SBYTE,
                         CSharpParser.SELECT, CSharpParser.SET, CSharpParser.SHORT, CSharpParser.SIZEOF,
                         CSharpParser.STRING, CSharpParser.THIS, CSharpParser.TRUE, CSharpParser.TYPEOF,
                         CSharpParser.UINT, CSharpParser.ULONG, CSharpParser.UNCHECKED, CSharpParser.UNMANAGED,
                         CSharpParser.USHORT, CSharpParser.VAR, CSharpParser.WHEN, CSharpParser.WHERE,
                         CSharpParser.YIELD, CSharpParser.IDENTIFIER, CSharpParser.LITERAL_ACCESS,
                         CSharpParser.INTEGER_LITERAL, CSharpParser.HEX_INTEGER_LITERAL,
                         CSharpParser.BIN_INTEGER_LITERAL, CSharpParser.REAL_LITERAL, CSharpParser.CHARACTER_LITERAL,
                         CSharpParser.REGULAR_STRING, CSharpParser.VERBATIUM_STRING,
                         CSharpParser.INTERPOLATED_REGULAR_STRING_START,
                         CSharpParser.INTERPOLATED_VERBATIUM_STRING_START, CSharpParser.OPEN_PARENS, CSharpParser.PLUS,
                         CSharpParser.MINUS, CSharpParser.STAR, CSharpParser.AMP, CSharpParser.CARET, CSharpParser.BANG,
                         CSharpParser.TILDE, CSharpParser.OP_INC, CSharpParser.OP_DEC, CSharpParser.OP_RANGE]:
                self.enterOuterAlt(localctx, 1)
                self.state = 923
                self.expression()
                pass
            elif token in [CSharpParser.THROW]:
                self.enterOuterAlt(localctx, 2)
                self.state = 924
                self.throw_expression()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Throw_expressionContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def THROW(self):
            return self.getToken(CSharpParser.THROW, 0)

        def expression(self):
            return self.getTypedRuleContext(CSharpParser.ExpressionContext, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_throw_expression

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterThrow_expression"):
                listener.enterThrow_expression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitThrow_expression"):
                listener.exitThrow_expression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitThrow_expression"):
                return visitor.visitThrow_expression(self)
            else:
                return visitor.visitChildren(self)

    def throw_expression(self):

        localctx = CSharpParser.Throw_expressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_throw_expression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 927
            self.match(CSharpParser.THROW)
            self.state = 928
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Member_accessContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DOT(self):
            return self.getToken(CSharpParser.DOT, 0)

        def identifier(self):
            return self.getTypedRuleContext(CSharpParser.IdentifierContext, 0)

        def INTERR(self):
            return self.getToken(CSharpParser.INTERR, 0)

        def type_argument_list(self):
            return self.getTypedRuleContext(CSharpParser.Type_argument_listContext, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_member_access

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterMember_access"):
                listener.enterMember_access(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitMember_access"):
                listener.exitMember_access(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitMember_access"):
                return visitor.visitMember_access(self)
            else:
                return visitor.visitChildren(self)

    def member_access(self):

        localctx = CSharpParser.Member_accessContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_member_access)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 931
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == CSharpParser.INTERR:
                self.state = 930
                self.match(CSharpParser.INTERR)

            self.state = 933
            self.match(CSharpParser.DOT)
            self.state = 934
            self.identifier()
            self.state = 936
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 77, self._ctx)
            if la_ == 1:
                self.state = 935
                self.type_argument_list()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Bracket_expressionContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPEN_BRACKET(self):
            return self.getToken(CSharpParser.OPEN_BRACKET, 0)

        def indexer_argument(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(CSharpParser.Indexer_argumentContext)
            else:
                return self.getTypedRuleContext(CSharpParser.Indexer_argumentContext, i)

        def CLOSE_BRACKET(self):
            return self.getToken(CSharpParser.CLOSE_BRACKET, 0)

        def INTERR(self):
            return self.getToken(CSharpParser.INTERR, 0)

        def COMMA(self, i: int = None):
            if i is None:
                return self.getTokens(CSharpParser.COMMA)
            else:
                return self.getToken(CSharpParser.COMMA, i)

        def getRuleIndex(self):
            return CSharpParser.RULE_bracket_expression

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterBracket_expression"):
                listener.enterBracket_expression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitBracket_expression"):
                listener.exitBracket_expression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitBracket_expression"):
                return visitor.visitBracket_expression(self)
            else:
                return visitor.visitChildren(self)

    def bracket_expression(self):

        localctx = CSharpParser.Bracket_expressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_bracket_expression)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 939
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == CSharpParser.INTERR:
                self.state = 938
                self.match(CSharpParser.INTERR)

            self.state = 941
            self.match(CSharpParser.OPEN_BRACKET)
            self.state = 942
            self.indexer_argument()
            self.state = 947
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == CSharpParser.COMMA:
                self.state = 943
                self.match(CSharpParser.COMMA)
                self.state = 944
                self.indexer_argument()
                self.state = 949
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 950
            self.match(CSharpParser.CLOSE_BRACKET)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Indexer_argumentContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(CSharpParser.ExpressionContext, 0)

        def identifier(self):
            return self.getTypedRuleContext(CSharpParser.IdentifierContext, 0)

        def COLON(self):
            return self.getToken(CSharpParser.COLON, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_indexer_argument

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterIndexer_argument"):
                listener.enterIndexer_argument(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitIndexer_argument"):
                listener.exitIndexer_argument(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitIndexer_argument"):
                return visitor.visitIndexer_argument(self)
            else:
                return visitor.visitChildren(self)

    def indexer_argument(self):

        localctx = CSharpParser.Indexer_argumentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_indexer_argument)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 955
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 80, self._ctx)
            if la_ == 1:
                self.state = 952
                self.identifier()
                self.state = 953
                self.match(CSharpParser.COLON)

            self.state = 957
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Predefined_typeContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BOOL(self):
            return self.getToken(CSharpParser.BOOL, 0)

        def BYTE(self):
            return self.getToken(CSharpParser.BYTE, 0)

        def CHAR(self):
            return self.getToken(CSharpParser.CHAR, 0)

        def DECIMAL(self):
            return self.getToken(CSharpParser.DECIMAL, 0)

        def DOUBLE(self):
            return self.getToken(CSharpParser.DOUBLE, 0)

        def FLOAT(self):
            return self.getToken(CSharpParser.FLOAT, 0)

        def INT(self):
            return self.getToken(CSharpParser.INT, 0)

        def LONG(self):
            return self.getToken(CSharpParser.LONG, 0)

        def OBJECT(self):
            return self.getToken(CSharpParser.OBJECT, 0)

        def SBYTE(self):
            return self.getToken(CSharpParser.SBYTE, 0)

        def SHORT(self):
            return self.getToken(CSharpParser.SHORT, 0)

        def STRING(self):
            return self.getToken(CSharpParser.STRING, 0)

        def UINT(self):
            return self.getToken(CSharpParser.UINT, 0)

        def ULONG(self):
            return self.getToken(CSharpParser.ULONG, 0)

        def USHORT(self):
            return self.getToken(CSharpParser.USHORT, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_predefined_type

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterPredefined_type"):
                listener.enterPredefined_type(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitPredefined_type"):
                listener.exitPredefined_type(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitPredefined_type"):
                return visitor.visitPredefined_type(self)
            else:
                return visitor.visitChildren(self)

    def predefined_type(self):

        localctx = CSharpParser.Predefined_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_predefined_type)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 959
            _la = self._input.LA(1)
            if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & (
                    (1 << CSharpParser.BOOL) | (1 << CSharpParser.BYTE) | (1 << CSharpParser.CHAR) | (
                    1 << CSharpParser.DECIMAL) | (1 << CSharpParser.DOUBLE) | (1 << CSharpParser.FLOAT) | (
                            1 << CSharpParser.INT) | (1 << CSharpParser.LONG))) != 0) or (
                            (((_la - 68)) & ~0x3f) == 0 and ((1 << (_la - 68)) & (
                            (1 << (CSharpParser.OBJECT - 68)) | (1 << (CSharpParser.SBYTE - 68)) | (
                            1 << (CSharpParser.SHORT - 68)) | (1 << (CSharpParser.STRING - 68)) | (
                                    1 << (CSharpParser.UINT - 68)) | (1 << (CSharpParser.ULONG - 68)) | (
                                    1 << (CSharpParser.USHORT - 68)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Expression_listContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(CSharpParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(CSharpParser.ExpressionContext, i)

        def COMMA(self, i: int = None):
            if i is None:
                return self.getTokens(CSharpParser.COMMA)
            else:
                return self.getToken(CSharpParser.COMMA, i)

        def getRuleIndex(self):
            return CSharpParser.RULE_expression_list

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterExpression_list"):
                listener.enterExpression_list(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitExpression_list"):
                listener.exitExpression_list(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitExpression_list"):
                return visitor.visitExpression_list(self)
            else:
                return visitor.visitChildren(self)

    def expression_list(self):

        localctx = CSharpParser.Expression_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_expression_list)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 961
            self.expression()
            self.state = 966
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == CSharpParser.COMMA:
                self.state = 962
                self.match(CSharpParser.COMMA)
                self.state = 963
                self.expression()
                self.state = 968
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Object_or_collection_initializerContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def object_initializer(self):
            return self.getTypedRuleContext(CSharpParser.Object_initializerContext, 0)

        def collection_initializer(self):
            return self.getTypedRuleContext(CSharpParser.Collection_initializerContext, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_object_or_collection_initializer

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterObject_or_collection_initializer"):
                listener.enterObject_or_collection_initializer(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitObject_or_collection_initializer"):
                listener.exitObject_or_collection_initializer(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitObject_or_collection_initializer"):
                return visitor.visitObject_or_collection_initializer(self)
            else:
                return visitor.visitChildren(self)

    def object_or_collection_initializer(self):

        localctx = CSharpParser.Object_or_collection_initializerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_object_or_collection_initializer)
        try:
            self.state = 971
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 82, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 969
                self.object_initializer()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 970
                self.collection_initializer()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Object_initializerContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPEN_BRACE(self):
            return self.getToken(CSharpParser.OPEN_BRACE, 0)

        def CLOSE_BRACE(self):
            return self.getToken(CSharpParser.CLOSE_BRACE, 0)

        def member_initializer_list(self):
            return self.getTypedRuleContext(CSharpParser.Member_initializer_listContext, 0)

        def COMMA(self):
            return self.getToken(CSharpParser.COMMA, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_object_initializer

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterObject_initializer"):
                listener.enterObject_initializer(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitObject_initializer"):
                listener.exitObject_initializer(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitObject_initializer"):
                return visitor.visitObject_initializer(self)
            else:
                return visitor.visitChildren(self)

    def object_initializer(self):

        localctx = CSharpParser.Object_initializerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_object_initializer)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 973
            self.match(CSharpParser.OPEN_BRACE)
            self.state = 978
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & (
                    (1 << CSharpParser.ADD) | (1 << CSharpParser.ALIAS) | (1 << CSharpParser.ARGLIST) | (
                    1 << CSharpParser.ASCENDING) | (1 << CSharpParser.ASYNC) | (1 << CSharpParser.AWAIT) | (
                            1 << CSharpParser.BY) | (1 << CSharpParser.DESCENDING) | (1 << CSharpParser.DYNAMIC) | (
                            1 << CSharpParser.EQUALS) | (1 << CSharpParser.FROM) | (1 << CSharpParser.GET) | (
                            1 << CSharpParser.GROUP) | (1 << CSharpParser.INTO) | (1 << CSharpParser.JOIN) | (
                            1 << CSharpParser.LET))) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & (
                    (1 << (CSharpParser.NAMEOF - 64)) | (1 << (CSharpParser.ON - 64)) | (
                    1 << (CSharpParser.ORDERBY - 64)) | (1 << (CSharpParser.PARTIAL - 64)) | (
                            1 << (CSharpParser.REMOVE - 64)) | (1 << (CSharpParser.SELECT - 64)) | (
                            1 << (CSharpParser.SET - 64)) | (1 << (CSharpParser.UNMANAGED - 64)) | (
                            1 << (CSharpParser.VAR - 64)) | (1 << (CSharpParser.WHEN - 64)) | (
                            1 << (CSharpParser.WHERE - 64)) | (1 << (CSharpParser.YIELD - 64)) | (
                            1 << (CSharpParser.IDENTIFIER - 64)) | (1 << (CSharpParser.OPEN_BRACKET - 64)))) != 0):
                self.state = 974
                self.member_initializer_list()
                self.state = 976
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == CSharpParser.COMMA:
                    self.state = 975
                    self.match(CSharpParser.COMMA)

            self.state = 980
            self.match(CSharpParser.CLOSE_BRACE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Member_initializer_listContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def member_initializer(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(CSharpParser.Member_initializerContext)
            else:
                return self.getTypedRuleContext(CSharpParser.Member_initializerContext, i)

        def COMMA(self, i: int = None):
            if i is None:
                return self.getTokens(CSharpParser.COMMA)
            else:
                return self.getToken(CSharpParser.COMMA, i)

        def getRuleIndex(self):
            return CSharpParser.RULE_member_initializer_list

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterMember_initializer_list"):
                listener.enterMember_initializer_list(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitMember_initializer_list"):
                listener.exitMember_initializer_list(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitMember_initializer_list"):
                return visitor.visitMember_initializer_list(self)
            else:
                return visitor.visitChildren(self)

    def member_initializer_list(self):

        localctx = CSharpParser.Member_initializer_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_member_initializer_list)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 982
            self.member_initializer()
            self.state = 987
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input, 85, self._ctx)
            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 983
                    self.match(CSharpParser.COMMA)
                    self.state = 984
                    self.member_initializer()
                self.state = 989
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 85, self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Member_initializerContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ASSIGNMENT(self):
            return self.getToken(CSharpParser.ASSIGNMENT, 0)

        def initializer_value(self):
            return self.getTypedRuleContext(CSharpParser.Initializer_valueContext, 0)

        def identifier(self):
            return self.getTypedRuleContext(CSharpParser.IdentifierContext, 0)

        def OPEN_BRACKET(self):
            return self.getToken(CSharpParser.OPEN_BRACKET, 0)

        def expression(self):
            return self.getTypedRuleContext(CSharpParser.ExpressionContext, 0)

        def CLOSE_BRACKET(self):
            return self.getToken(CSharpParser.CLOSE_BRACKET, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_member_initializer

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterMember_initializer"):
                listener.enterMember_initializer(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitMember_initializer"):
                listener.exitMember_initializer(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitMember_initializer"):
                return visitor.visitMember_initializer(self)
            else:
                return visitor.visitChildren(self)

    def member_initializer(self):

        localctx = CSharpParser.Member_initializerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 96, self.RULE_member_initializer)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 995
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [CSharpParser.ADD, CSharpParser.ALIAS, CSharpParser.ARGLIST, CSharpParser.ASCENDING,
                         CSharpParser.ASYNC, CSharpParser.AWAIT, CSharpParser.BY, CSharpParser.DESCENDING,
                         CSharpParser.DYNAMIC, CSharpParser.EQUALS, CSharpParser.FROM, CSharpParser.GET,
                         CSharpParser.GROUP, CSharpParser.INTO, CSharpParser.JOIN, CSharpParser.LET,
                         CSharpParser.NAMEOF, CSharpParser.ON, CSharpParser.ORDERBY, CSharpParser.PARTIAL,
                         CSharpParser.REMOVE, CSharpParser.SELECT, CSharpParser.SET, CSharpParser.UNMANAGED,
                         CSharpParser.VAR, CSharpParser.WHEN, CSharpParser.WHERE, CSharpParser.YIELD,
                         CSharpParser.IDENTIFIER]:
                self.state = 990
                self.identifier()
                pass
            elif token in [CSharpParser.OPEN_BRACKET]:
                self.state = 991
                self.match(CSharpParser.OPEN_BRACKET)
                self.state = 992
                self.expression()
                self.state = 993
                self.match(CSharpParser.CLOSE_BRACKET)
                pass
            else:
                raise NoViableAltException(self)

            self.state = 997
            self.match(CSharpParser.ASSIGNMENT)
            self.state = 998
            self.initializer_value()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Initializer_valueContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(CSharpParser.ExpressionContext, 0)

        def object_or_collection_initializer(self):
            return self.getTypedRuleContext(CSharpParser.Object_or_collection_initializerContext, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_initializer_value

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterInitializer_value"):
                listener.enterInitializer_value(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitInitializer_value"):
                listener.exitInitializer_value(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitInitializer_value"):
                return visitor.visitInitializer_value(self)
            else:
                return visitor.visitChildren(self)

    def initializer_value(self):

        localctx = CSharpParser.Initializer_valueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 98, self.RULE_initializer_value)
        try:
            self.state = 1002
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [CSharpParser.ADD, CSharpParser.ALIAS, CSharpParser.ARGLIST, CSharpParser.ASCENDING,
                         CSharpParser.ASYNC, CSharpParser.AWAIT, CSharpParser.BASE, CSharpParser.BOOL, CSharpParser.BY,
                         CSharpParser.BYTE, CSharpParser.CHAR, CSharpParser.CHECKED, CSharpParser.DECIMAL,
                         CSharpParser.DEFAULT, CSharpParser.DELEGATE, CSharpParser.DESCENDING, CSharpParser.DOUBLE,
                         CSharpParser.DYNAMIC, CSharpParser.EQUALS, CSharpParser.FALSE, CSharpParser.FLOAT,
                         CSharpParser.FROM, CSharpParser.GET, CSharpParser.GROUP, CSharpParser.INT, CSharpParser.INTO,
                         CSharpParser.JOIN, CSharpParser.LET, CSharpParser.LONG, CSharpParser.NAMEOF, CSharpParser.NEW,
                         CSharpParser.NULL_, CSharpParser.OBJECT, CSharpParser.ON, CSharpParser.ORDERBY,
                         CSharpParser.PARTIAL, CSharpParser.REF, CSharpParser.REMOVE, CSharpParser.SBYTE,
                         CSharpParser.SELECT, CSharpParser.SET, CSharpParser.SHORT, CSharpParser.SIZEOF,
                         CSharpParser.STRING, CSharpParser.THIS, CSharpParser.TRUE, CSharpParser.TYPEOF,
                         CSharpParser.UINT, CSharpParser.ULONG, CSharpParser.UNCHECKED, CSharpParser.UNMANAGED,
                         CSharpParser.USHORT, CSharpParser.VAR, CSharpParser.WHEN, CSharpParser.WHERE,
                         CSharpParser.YIELD, CSharpParser.IDENTIFIER, CSharpParser.LITERAL_ACCESS,
                         CSharpParser.INTEGER_LITERAL, CSharpParser.HEX_INTEGER_LITERAL,
                         CSharpParser.BIN_INTEGER_LITERAL, CSharpParser.REAL_LITERAL, CSharpParser.CHARACTER_LITERAL,
                         CSharpParser.REGULAR_STRING, CSharpParser.VERBATIUM_STRING,
                         CSharpParser.INTERPOLATED_REGULAR_STRING_START,
                         CSharpParser.INTERPOLATED_VERBATIUM_STRING_START, CSharpParser.OPEN_PARENS, CSharpParser.PLUS,
                         CSharpParser.MINUS, CSharpParser.STAR, CSharpParser.AMP, CSharpParser.CARET, CSharpParser.BANG,
                         CSharpParser.TILDE, CSharpParser.OP_INC, CSharpParser.OP_DEC, CSharpParser.OP_RANGE]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1000
                self.expression()
                pass
            elif token in [CSharpParser.OPEN_BRACE]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1001
                self.object_or_collection_initializer()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Collection_initializerContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPEN_BRACE(self):
            return self.getToken(CSharpParser.OPEN_BRACE, 0)

        def element_initializer(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(CSharpParser.Element_initializerContext)
            else:
                return self.getTypedRuleContext(CSharpParser.Element_initializerContext, i)

        def CLOSE_BRACE(self):
            return self.getToken(CSharpParser.CLOSE_BRACE, 0)

        def COMMA(self, i: int = None):
            if i is None:
                return self.getTokens(CSharpParser.COMMA)
            else:
                return self.getToken(CSharpParser.COMMA, i)

        def getRuleIndex(self):
            return CSharpParser.RULE_collection_initializer

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterCollection_initializer"):
                listener.enterCollection_initializer(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitCollection_initializer"):
                listener.exitCollection_initializer(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitCollection_initializer"):
                return visitor.visitCollection_initializer(self)
            else:
                return visitor.visitChildren(self)

    def collection_initializer(self):

        localctx = CSharpParser.Collection_initializerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 100, self.RULE_collection_initializer)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1004
            self.match(CSharpParser.OPEN_BRACE)
            self.state = 1005
            self.element_initializer()
            self.state = 1010
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input, 88, self._ctx)
            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 1006
                    self.match(CSharpParser.COMMA)
                    self.state = 1007
                    self.element_initializer()
                self.state = 1012
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 88, self._ctx)

            self.state = 1014
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == CSharpParser.COMMA:
                self.state = 1013
                self.match(CSharpParser.COMMA)

            self.state = 1016
            self.match(CSharpParser.CLOSE_BRACE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Element_initializerContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def non_assignment_expression(self):
            return self.getTypedRuleContext(CSharpParser.Non_assignment_expressionContext, 0)

        def OPEN_BRACE(self):
            return self.getToken(CSharpParser.OPEN_BRACE, 0)

        def expression_list(self):
            return self.getTypedRuleContext(CSharpParser.Expression_listContext, 0)

        def CLOSE_BRACE(self):
            return self.getToken(CSharpParser.CLOSE_BRACE, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_element_initializer

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterElement_initializer"):
                listener.enterElement_initializer(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitElement_initializer"):
                listener.exitElement_initializer(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitElement_initializer"):
                return visitor.visitElement_initializer(self)
            else:
                return visitor.visitChildren(self)

    def element_initializer(self):

        localctx = CSharpParser.Element_initializerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 102, self.RULE_element_initializer)
        try:
            self.state = 1023
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [CSharpParser.ADD, CSharpParser.ALIAS, CSharpParser.ARGLIST, CSharpParser.ASCENDING,
                         CSharpParser.ASYNC, CSharpParser.AWAIT, CSharpParser.BASE, CSharpParser.BOOL, CSharpParser.BY,
                         CSharpParser.BYTE, CSharpParser.CHAR, CSharpParser.CHECKED, CSharpParser.DECIMAL,
                         CSharpParser.DEFAULT, CSharpParser.DELEGATE, CSharpParser.DESCENDING, CSharpParser.DOUBLE,
                         CSharpParser.DYNAMIC, CSharpParser.EQUALS, CSharpParser.FALSE, CSharpParser.FLOAT,
                         CSharpParser.FROM, CSharpParser.GET, CSharpParser.GROUP, CSharpParser.INT, CSharpParser.INTO,
                         CSharpParser.JOIN, CSharpParser.LET, CSharpParser.LONG, CSharpParser.NAMEOF, CSharpParser.NEW,
                         CSharpParser.NULL_, CSharpParser.OBJECT, CSharpParser.ON, CSharpParser.ORDERBY,
                         CSharpParser.PARTIAL, CSharpParser.REMOVE, CSharpParser.SBYTE, CSharpParser.SELECT,
                         CSharpParser.SET, CSharpParser.SHORT, CSharpParser.SIZEOF, CSharpParser.STRING,
                         CSharpParser.THIS, CSharpParser.TRUE, CSharpParser.TYPEOF, CSharpParser.UINT,
                         CSharpParser.ULONG, CSharpParser.UNCHECKED, CSharpParser.UNMANAGED, CSharpParser.USHORT,
                         CSharpParser.VAR, CSharpParser.WHEN, CSharpParser.WHERE, CSharpParser.YIELD,
                         CSharpParser.IDENTIFIER, CSharpParser.LITERAL_ACCESS, CSharpParser.INTEGER_LITERAL,
                         CSharpParser.HEX_INTEGER_LITERAL, CSharpParser.BIN_INTEGER_LITERAL, CSharpParser.REAL_LITERAL,
                         CSharpParser.CHARACTER_LITERAL, CSharpParser.REGULAR_STRING, CSharpParser.VERBATIUM_STRING,
                         CSharpParser.INTERPOLATED_REGULAR_STRING_START,
                         CSharpParser.INTERPOLATED_VERBATIUM_STRING_START, CSharpParser.OPEN_PARENS, CSharpParser.PLUS,
                         CSharpParser.MINUS, CSharpParser.STAR, CSharpParser.AMP, CSharpParser.CARET, CSharpParser.BANG,
                         CSharpParser.TILDE, CSharpParser.OP_INC, CSharpParser.OP_DEC, CSharpParser.OP_RANGE]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1018
                self.non_assignment_expression()
                pass
            elif token in [CSharpParser.OPEN_BRACE]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1019
                self.match(CSharpParser.OPEN_BRACE)
                self.state = 1020
                self.expression_list()
                self.state = 1021
                self.match(CSharpParser.CLOSE_BRACE)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Anonymous_object_initializerContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPEN_BRACE(self):
            return self.getToken(CSharpParser.OPEN_BRACE, 0)

        def CLOSE_BRACE(self):
            return self.getToken(CSharpParser.CLOSE_BRACE, 0)

        def member_declarator_list(self):
            return self.getTypedRuleContext(CSharpParser.Member_declarator_listContext, 0)

        def COMMA(self):
            return self.getToken(CSharpParser.COMMA, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_anonymous_object_initializer

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterAnonymous_object_initializer"):
                listener.enterAnonymous_object_initializer(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitAnonymous_object_initializer"):
                listener.exitAnonymous_object_initializer(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitAnonymous_object_initializer"):
                return visitor.visitAnonymous_object_initializer(self)
            else:
                return visitor.visitChildren(self)

    def anonymous_object_initializer(self):

        localctx = CSharpParser.Anonymous_object_initializerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 104, self.RULE_anonymous_object_initializer)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1025
            self.match(CSharpParser.OPEN_BRACE)
            self.state = 1030
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 10)) & ~0x3f) == 0 and ((1 << (_la - 10)) & (
                    (1 << (CSharpParser.ADD - 10)) | (1 << (CSharpParser.ALIAS - 10)) | (
                    1 << (CSharpParser.ARGLIST - 10)) | (1 << (CSharpParser.ASCENDING - 10)) | (
                            1 << (CSharpParser.ASYNC - 10)) | (1 << (CSharpParser.AWAIT - 10)) | (
                            1 << (CSharpParser.BASE - 10)) | (1 << (CSharpParser.BOOL - 10)) | (
                            1 << (CSharpParser.BY - 10)) | (1 << (CSharpParser.BYTE - 10)) | (
                            1 << (CSharpParser.CHAR - 10)) | (1 << (CSharpParser.CHECKED - 10)) | (
                            1 << (CSharpParser.DECIMAL - 10)) | (1 << (CSharpParser.DEFAULT - 10)) | (
                            1 << (CSharpParser.DELEGATE - 10)) | (1 << (CSharpParser.DESCENDING - 10)) | (
                            1 << (CSharpParser.DOUBLE - 10)) | (1 << (CSharpParser.DYNAMIC - 10)) | (
                            1 << (CSharpParser.EQUALS - 10)) | (1 << (CSharpParser.FALSE - 10)) | (
                            1 << (CSharpParser.FLOAT - 10)) | (1 << (CSharpParser.FROM - 10)) | (
                            1 << (CSharpParser.GET - 10)) | (1 << (CSharpParser.GROUP - 10)) | (
                            1 << (CSharpParser.INT - 10)) | (1 << (CSharpParser.INTO - 10)) | (
                            1 << (CSharpParser.JOIN - 10)) | (1 << (CSharpParser.LET - 10)) | (
                            1 << (CSharpParser.LONG - 10)) | (1 << (CSharpParser.NAMEOF - 10)) | (
                            1 << (CSharpParser.NEW - 10)) | (1 << (CSharpParser.NULL_ - 10)) | (
                            1 << (CSharpParser.OBJECT - 10)) | (1 << (CSharpParser.ON - 10)) | (
                            1 << (CSharpParser.ORDERBY - 10)))) != 0) or ((((_la - 75)) & ~0x3f) == 0 and (
                    (1 << (_la - 75)) & ((1 << (CSharpParser.PARTIAL - 75)) | (1 << (CSharpParser.REMOVE - 75)) | (
                    1 << (CSharpParser.SBYTE - 75)) | (1 << (CSharpParser.SELECT - 75)) | (
                                                 1 << (CSharpParser.SET - 75)) | (1 << (CSharpParser.SHORT - 75)) | (
                                                 1 << (CSharpParser.SIZEOF - 75)) | (
                                                 1 << (CSharpParser.STRING - 75)) | (1 << (CSharpParser.THIS - 75)) | (
                                                 1 << (CSharpParser.TRUE - 75)) | (1 << (CSharpParser.TYPEOF - 75)) | (
                                                 1 << (CSharpParser.UINT - 75)) | (1 << (CSharpParser.ULONG - 75)) | (
                                                 1 << (CSharpParser.UNCHECKED - 75)) | (
                                                 1 << (CSharpParser.UNMANAGED - 75)) | (
                                                 1 << (CSharpParser.USHORT - 75)) | (1 << (CSharpParser.VAR - 75)) | (
                                                 1 << (CSharpParser.WHEN - 75)) | (1 << (CSharpParser.WHERE - 75)) | (
                                                 1 << (CSharpParser.YIELD - 75)) | (
                                                 1 << (CSharpParser.IDENTIFIER - 75)) | (
                                                 1 << (CSharpParser.LITERAL_ACCESS - 75)) | (
                                                 1 << (CSharpParser.INTEGER_LITERAL - 75)) | (
                                                 1 << (CSharpParser.HEX_INTEGER_LITERAL - 75)) | (
                                                 1 << (CSharpParser.BIN_INTEGER_LITERAL - 75)) | (
                                                 1 << (CSharpParser.REAL_LITERAL - 75)) | (
                                                 1 << (CSharpParser.CHARACTER_LITERAL - 75)) | (
                                                 1 << (CSharpParser.REGULAR_STRING - 75)) | (
                                                 1 << (CSharpParser.VERBATIUM_STRING - 75)) | (
                                                 1 << (CSharpParser.INTERPOLATED_REGULAR_STRING_START - 75)) | (
                                                 1 << (CSharpParser.INTERPOLATED_VERBATIUM_STRING_START - 75)) | (
                                                 1 << (CSharpParser.OPEN_PARENS - 75)))) != 0):
                self.state = 1026
                self.member_declarator_list()
                self.state = 1028
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == CSharpParser.COMMA:
                    self.state = 1027
                    self.match(CSharpParser.COMMA)

            self.state = 1032
            self.match(CSharpParser.CLOSE_BRACE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Member_declarator_listContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def member_declarator(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(CSharpParser.Member_declaratorContext)
            else:
                return self.getTypedRuleContext(CSharpParser.Member_declaratorContext, i)

        def COMMA(self, i: int = None):
            if i is None:
                return self.getTokens(CSharpParser.COMMA)
            else:
                return self.getToken(CSharpParser.COMMA, i)

        def getRuleIndex(self):
            return CSharpParser.RULE_member_declarator_list

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterMember_declarator_list"):
                listener.enterMember_declarator_list(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitMember_declarator_list"):
                listener.exitMember_declarator_list(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitMember_declarator_list"):
                return visitor.visitMember_declarator_list(self)
            else:
                return visitor.visitChildren(self)

    def member_declarator_list(self):

        localctx = CSharpParser.Member_declarator_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 106, self.RULE_member_declarator_list)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1034
            self.member_declarator()
            self.state = 1039
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input, 93, self._ctx)
            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 1035
                    self.match(CSharpParser.COMMA)
                    self.state = 1036
                    self.member_declarator()
                self.state = 1041
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 93, self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Member_declaratorContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def primary_expression(self):
            return self.getTypedRuleContext(CSharpParser.Primary_expressionContext, 0)

        def identifier(self):
            return self.getTypedRuleContext(CSharpParser.IdentifierContext, 0)

        def ASSIGNMENT(self):
            return self.getToken(CSharpParser.ASSIGNMENT, 0)

        def expression(self):
            return self.getTypedRuleContext(CSharpParser.ExpressionContext, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_member_declarator

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterMember_declarator"):
                listener.enterMember_declarator(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitMember_declarator"):
                listener.exitMember_declarator(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitMember_declarator"):
                return visitor.visitMember_declarator(self)
            else:
                return visitor.visitChildren(self)

    def member_declarator(self):

        localctx = CSharpParser.Member_declaratorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 108, self.RULE_member_declarator)
        try:
            self.state = 1047
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 94, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1042
                self.primary_expression()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1043
                self.identifier()
                self.state = 1044
                self.match(CSharpParser.ASSIGNMENT)
                self.state = 1045
                self.expression()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Unbound_type_nameContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(CSharpParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(CSharpParser.IdentifierContext, i)

        def DOUBLE_COLON(self):
            return self.getToken(CSharpParser.DOUBLE_COLON, 0)

        def DOT(self, i: int = None):
            if i is None:
                return self.getTokens(CSharpParser.DOT)
            else:
                return self.getToken(CSharpParser.DOT, i)

        def generic_dimension_specifier(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(CSharpParser.Generic_dimension_specifierContext)
            else:
                return self.getTypedRuleContext(CSharpParser.Generic_dimension_specifierContext, i)

        def getRuleIndex(self):
            return CSharpParser.RULE_unbound_type_name

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterUnbound_type_name"):
                listener.enterUnbound_type_name(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitUnbound_type_name"):
                listener.exitUnbound_type_name(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitUnbound_type_name"):
                return visitor.visitUnbound_type_name(self)
            else:
                return visitor.visitChildren(self)

    def unbound_type_name(self):

        localctx = CSharpParser.Unbound_type_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 110, self.RULE_unbound_type_name)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1049
            self.identifier()
            self.state = 1058
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [CSharpParser.CLOSE_PARENS, CSharpParser.DOT, CSharpParser.LT]:
                self.state = 1051
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == CSharpParser.LT:
                    self.state = 1050
                    self.generic_dimension_specifier()

                pass
            elif token in [CSharpParser.DOUBLE_COLON]:
                self.state = 1053
                self.match(CSharpParser.DOUBLE_COLON)
                self.state = 1054
                self.identifier()
                self.state = 1056
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == CSharpParser.LT:
                    self.state = 1055
                    self.generic_dimension_specifier()

                pass
            else:
                raise NoViableAltException(self)

            self.state = 1067
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == CSharpParser.DOT:
                self.state = 1060
                self.match(CSharpParser.DOT)
                self.state = 1061
                self.identifier()
                self.state = 1063
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == CSharpParser.LT:
                    self.state = 1062
                    self.generic_dimension_specifier()

                self.state = 1069
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Generic_dimension_specifierContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LT(self):
            return self.getToken(CSharpParser.LT, 0)

        def GT(self):
            return self.getToken(CSharpParser.GT, 0)

        def COMMA(self, i: int = None):
            if i is None:
                return self.getTokens(CSharpParser.COMMA)
            else:
                return self.getToken(CSharpParser.COMMA, i)

        def getRuleIndex(self):
            return CSharpParser.RULE_generic_dimension_specifier

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterGeneric_dimension_specifier"):
                listener.enterGeneric_dimension_specifier(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitGeneric_dimension_specifier"):
                listener.exitGeneric_dimension_specifier(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitGeneric_dimension_specifier"):
                return visitor.visitGeneric_dimension_specifier(self)
            else:
                return visitor.visitChildren(self)

    def generic_dimension_specifier(self):

        localctx = CSharpParser.Generic_dimension_specifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 112, self.RULE_generic_dimension_specifier)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1070
            self.match(CSharpParser.LT)
            self.state = 1074
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == CSharpParser.COMMA:
                self.state = 1071
                self.match(CSharpParser.COMMA)
                self.state = 1076
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1077
            self.match(CSharpParser.GT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class IsTypeContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def base_type(self):
            return self.getTypedRuleContext(CSharpParser.Base_typeContext, 0)

        def rank_specifier(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(CSharpParser.Rank_specifierContext)
            else:
                return self.getTypedRuleContext(CSharpParser.Rank_specifierContext, i)

        def STAR(self, i: int = None):
            if i is None:
                return self.getTokens(CSharpParser.STAR)
            else:
                return self.getToken(CSharpParser.STAR, i)

        def INTERR(self):
            return self.getToken(CSharpParser.INTERR, 0)

        def isTypePatternArms(self):
            return self.getTypedRuleContext(CSharpParser.IsTypePatternArmsContext, 0)

        def identifier(self):
            return self.getTypedRuleContext(CSharpParser.IdentifierContext, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_isType

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterIsType"):
                listener.enterIsType(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitIsType"):
                listener.exitIsType(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitIsType"):
                return visitor.visitIsType(self)
            else:
                return visitor.visitChildren(self)

    def isType(self):

        localctx = CSharpParser.IsTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 114, self.RULE_isType)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1079
            self.base_type()
            self.state = 1084
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input, 102, self._ctx)
            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 1082
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [CSharpParser.OPEN_BRACKET]:
                        self.state = 1080
                        self.rank_specifier()
                        pass
                    elif token in [CSharpParser.STAR]:
                        self.state = 1081
                        self.match(CSharpParser.STAR)
                        pass
                    else:
                        raise NoViableAltException(self)

                self.state = 1086
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 102, self._ctx)

            self.state = 1088
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 103, self._ctx)
            if la_ == 1:
                self.state = 1087
                self.match(CSharpParser.INTERR)

            self.state = 1091
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 104, self._ctx)
            if la_ == 1:
                self.state = 1090
                self.isTypePatternArms()

            self.state = 1094
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 105, self._ctx)
            if la_ == 1:
                self.state = 1093
                self.identifier()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class IsTypePatternArmsContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPEN_BRACE(self):
            return self.getToken(CSharpParser.OPEN_BRACE, 0)

        def isTypePatternArm(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(CSharpParser.IsTypePatternArmContext)
            else:
                return self.getTypedRuleContext(CSharpParser.IsTypePatternArmContext, i)

        def CLOSE_BRACE(self):
            return self.getToken(CSharpParser.CLOSE_BRACE, 0)

        def COMMA(self, i: int = None):
            if i is None:
                return self.getTokens(CSharpParser.COMMA)
            else:
                return self.getToken(CSharpParser.COMMA, i)

        def getRuleIndex(self):
            return CSharpParser.RULE_isTypePatternArms

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterIsTypePatternArms"):
                listener.enterIsTypePatternArms(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitIsTypePatternArms"):
                listener.exitIsTypePatternArms(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitIsTypePatternArms"):
                return visitor.visitIsTypePatternArms(self)
            else:
                return visitor.visitChildren(self)

    def isTypePatternArms(self):

        localctx = CSharpParser.IsTypePatternArmsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 116, self.RULE_isTypePatternArms)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1096
            self.match(CSharpParser.OPEN_BRACE)
            self.state = 1097
            self.isTypePatternArm()
            self.state = 1102
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == CSharpParser.COMMA:
                self.state = 1098
                self.match(CSharpParser.COMMA)
                self.state = 1099
                self.isTypePatternArm()
                self.state = 1104
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1105
            self.match(CSharpParser.CLOSE_BRACE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class IsTypePatternArmContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(CSharpParser.IdentifierContext, 0)

        def COLON(self):
            return self.getToken(CSharpParser.COLON, 0)

        def expression(self):
            return self.getTypedRuleContext(CSharpParser.ExpressionContext, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_isTypePatternArm

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterIsTypePatternArm"):
                listener.enterIsTypePatternArm(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitIsTypePatternArm"):
                listener.exitIsTypePatternArm(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitIsTypePatternArm"):
                return visitor.visitIsTypePatternArm(self)
            else:
                return visitor.visitChildren(self)

    def isTypePatternArm(self):

        localctx = CSharpParser.IsTypePatternArmContext(self, self._ctx, self.state)
        self.enterRule(localctx, 118, self.RULE_isTypePatternArm)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1107
            self.identifier()
            self.state = 1108
            self.match(CSharpParser.COLON)
            self.state = 1109
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Lambda_expressionContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def anonymous_function_signature(self):
            return self.getTypedRuleContext(CSharpParser.Anonymous_function_signatureContext, 0)

        def right_arrow(self):
            return self.getTypedRuleContext(CSharpParser.Right_arrowContext, 0)

        def anonymous_function_body(self):
            return self.getTypedRuleContext(CSharpParser.Anonymous_function_bodyContext, 0)

        def ASYNC(self):
            return self.getToken(CSharpParser.ASYNC, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_lambda_expression

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterLambda_expression"):
                listener.enterLambda_expression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitLambda_expression"):
                listener.exitLambda_expression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitLambda_expression"):
                return visitor.visitLambda_expression(self)
            else:
                return visitor.visitChildren(self)

    def lambda_expression(self):

        localctx = CSharpParser.Lambda_expressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 120, self.RULE_lambda_expression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1112
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 107, self._ctx)
            if la_ == 1:
                self.state = 1111
                self.match(CSharpParser.ASYNC)

            self.state = 1114
            self.anonymous_function_signature()
            self.state = 1115
            self.right_arrow()
            self.state = 1116
            self.anonymous_function_body()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Anonymous_function_signatureContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPEN_PARENS(self):
            return self.getToken(CSharpParser.OPEN_PARENS, 0)

        def CLOSE_PARENS(self):
            return self.getToken(CSharpParser.CLOSE_PARENS, 0)

        def explicit_anonymous_function_parameter_list(self):
            return self.getTypedRuleContext(CSharpParser.Explicit_anonymous_function_parameter_listContext, 0)

        def implicit_anonymous_function_parameter_list(self):
            return self.getTypedRuleContext(CSharpParser.Implicit_anonymous_function_parameter_listContext, 0)

        def identifier(self):
            return self.getTypedRuleContext(CSharpParser.IdentifierContext, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_anonymous_function_signature

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterAnonymous_function_signature"):
                listener.enterAnonymous_function_signature(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitAnonymous_function_signature"):
                listener.exitAnonymous_function_signature(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitAnonymous_function_signature"):
                return visitor.visitAnonymous_function_signature(self)
            else:
                return visitor.visitChildren(self)

    def anonymous_function_signature(self):

        localctx = CSharpParser.Anonymous_function_signatureContext(self, self._ctx, self.state)
        self.enterRule(localctx, 122, self.RULE_anonymous_function_signature)
        try:
            self.state = 1129
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 108, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1118
                self.match(CSharpParser.OPEN_PARENS)
                self.state = 1119
                self.match(CSharpParser.CLOSE_PARENS)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1120
                self.match(CSharpParser.OPEN_PARENS)
                self.state = 1121
                self.explicit_anonymous_function_parameter_list()
                self.state = 1122
                self.match(CSharpParser.CLOSE_PARENS)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1124
                self.match(CSharpParser.OPEN_PARENS)
                self.state = 1125
                self.implicit_anonymous_function_parameter_list()
                self.state = 1126
                self.match(CSharpParser.CLOSE_PARENS)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1128
                self.identifier()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Explicit_anonymous_function_parameter_listContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def explicit_anonymous_function_parameter(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(CSharpParser.Explicit_anonymous_function_parameterContext)
            else:
                return self.getTypedRuleContext(CSharpParser.Explicit_anonymous_function_parameterContext, i)

        def COMMA(self, i: int = None):
            if i is None:
                return self.getTokens(CSharpParser.COMMA)
            else:
                return self.getToken(CSharpParser.COMMA, i)

        def getRuleIndex(self):
            return CSharpParser.RULE_explicit_anonymous_function_parameter_list

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterExplicit_anonymous_function_parameter_list"):
                listener.enterExplicit_anonymous_function_parameter_list(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitExplicit_anonymous_function_parameter_list"):
                listener.exitExplicit_anonymous_function_parameter_list(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitExplicit_anonymous_function_parameter_list"):
                return visitor.visitExplicit_anonymous_function_parameter_list(self)
            else:
                return visitor.visitChildren(self)

    def explicit_anonymous_function_parameter_list(self):

        localctx = CSharpParser.Explicit_anonymous_function_parameter_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 124, self.RULE_explicit_anonymous_function_parameter_list)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1131
            self.explicit_anonymous_function_parameter()
            self.state = 1136
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == CSharpParser.COMMA:
                self.state = 1132
                self.match(CSharpParser.COMMA)
                self.state = 1133
                self.explicit_anonymous_function_parameter()
                self.state = 1138
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Explicit_anonymous_function_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.refout = None  # Token

        def type_(self):
            return self.getTypedRuleContext(CSharpParser.Type_Context, 0)

        def identifier(self):
            return self.getTypedRuleContext(CSharpParser.IdentifierContext, 0)

        def REF(self):
            return self.getToken(CSharpParser.REF, 0)

        def OUT(self):
            return self.getToken(CSharpParser.OUT, 0)

        def IN(self):
            return self.getToken(CSharpParser.IN, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_explicit_anonymous_function_parameter

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterExplicit_anonymous_function_parameter"):
                listener.enterExplicit_anonymous_function_parameter(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitExplicit_anonymous_function_parameter"):
                listener.exitExplicit_anonymous_function_parameter(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitExplicit_anonymous_function_parameter"):
                return visitor.visitExplicit_anonymous_function_parameter(self)
            else:
                return visitor.visitChildren(self)

    def explicit_anonymous_function_parameter(self):

        localctx = CSharpParser.Explicit_anonymous_function_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 126, self.RULE_explicit_anonymous_function_parameter)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1140
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 54)) & ~0x3f) == 0 and ((1 << (_la - 54)) & (
                    (1 << (CSharpParser.IN - 54)) | (1 << (CSharpParser.OUT - 54)) | (
                    1 << (CSharpParser.REF - 54)))) != 0):
                self.state = 1139
                localctx.refout = self._input.LT(1)
                _la = self._input.LA(1)
                if not (((((_la - 54)) & ~0x3f) == 0 and ((1 << (_la - 54)) & (
                        (1 << (CSharpParser.IN - 54)) | (1 << (CSharpParser.OUT - 54)) | (
                        1 << (CSharpParser.REF - 54)))) != 0)):
                    localctx.refout = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()

            self.state = 1142
            self.type_()
            self.state = 1143
            self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Implicit_anonymous_function_parameter_listContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(CSharpParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(CSharpParser.IdentifierContext, i)

        def COMMA(self, i: int = None):
            if i is None:
                return self.getTokens(CSharpParser.COMMA)
            else:
                return self.getToken(CSharpParser.COMMA, i)

        def getRuleIndex(self):
            return CSharpParser.RULE_implicit_anonymous_function_parameter_list

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterImplicit_anonymous_function_parameter_list"):
                listener.enterImplicit_anonymous_function_parameter_list(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitImplicit_anonymous_function_parameter_list"):
                listener.exitImplicit_anonymous_function_parameter_list(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitImplicit_anonymous_function_parameter_list"):
                return visitor.visitImplicit_anonymous_function_parameter_list(self)
            else:
                return visitor.visitChildren(self)

    def implicit_anonymous_function_parameter_list(self):

        localctx = CSharpParser.Implicit_anonymous_function_parameter_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 128, self.RULE_implicit_anonymous_function_parameter_list)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1145
            self.identifier()
            self.state = 1150
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == CSharpParser.COMMA:
                self.state = 1146
                self.match(CSharpParser.COMMA)
                self.state = 1147
                self.identifier()
                self.state = 1152
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Anonymous_function_bodyContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def throwable_expression(self):
            return self.getTypedRuleContext(CSharpParser.Throwable_expressionContext, 0)

        def block(self):
            return self.getTypedRuleContext(CSharpParser.BlockContext, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_anonymous_function_body

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterAnonymous_function_body"):
                listener.enterAnonymous_function_body(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitAnonymous_function_body"):
                listener.exitAnonymous_function_body(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitAnonymous_function_body"):
                return visitor.visitAnonymous_function_body(self)
            else:
                return visitor.visitChildren(self)

    def anonymous_function_body(self):

        localctx = CSharpParser.Anonymous_function_bodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 130, self.RULE_anonymous_function_body)
        try:
            self.state = 1155
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [CSharpParser.ADD, CSharpParser.ALIAS, CSharpParser.ARGLIST, CSharpParser.ASCENDING,
                         CSharpParser.ASYNC, CSharpParser.AWAIT, CSharpParser.BASE, CSharpParser.BOOL, CSharpParser.BY,
                         CSharpParser.BYTE, CSharpParser.CHAR, CSharpParser.CHECKED, CSharpParser.DECIMAL,
                         CSharpParser.DEFAULT, CSharpParser.DELEGATE, CSharpParser.DESCENDING, CSharpParser.DOUBLE,
                         CSharpParser.DYNAMIC, CSharpParser.EQUALS, CSharpParser.FALSE, CSharpParser.FLOAT,
                         CSharpParser.FROM, CSharpParser.GET, CSharpParser.GROUP, CSharpParser.INT, CSharpParser.INTO,
                         CSharpParser.JOIN, CSharpParser.LET, CSharpParser.LONG, CSharpParser.NAMEOF, CSharpParser.NEW,
                         CSharpParser.NULL_, CSharpParser.OBJECT, CSharpParser.ON, CSharpParser.ORDERBY,
                         CSharpParser.PARTIAL, CSharpParser.REF, CSharpParser.REMOVE, CSharpParser.SBYTE,
                         CSharpParser.SELECT, CSharpParser.SET, CSharpParser.SHORT, CSharpParser.SIZEOF,
                         CSharpParser.STRING, CSharpParser.THIS, CSharpParser.THROW, CSharpParser.TRUE,
                         CSharpParser.TYPEOF, CSharpParser.UINT, CSharpParser.ULONG, CSharpParser.UNCHECKED,
                         CSharpParser.UNMANAGED, CSharpParser.USHORT, CSharpParser.VAR, CSharpParser.WHEN,
                         CSharpParser.WHERE, CSharpParser.YIELD, CSharpParser.IDENTIFIER, CSharpParser.LITERAL_ACCESS,
                         CSharpParser.INTEGER_LITERAL, CSharpParser.HEX_INTEGER_LITERAL,
                         CSharpParser.BIN_INTEGER_LITERAL, CSharpParser.REAL_LITERAL, CSharpParser.CHARACTER_LITERAL,
                         CSharpParser.REGULAR_STRING, CSharpParser.VERBATIUM_STRING,
                         CSharpParser.INTERPOLATED_REGULAR_STRING_START,
                         CSharpParser.INTERPOLATED_VERBATIUM_STRING_START, CSharpParser.OPEN_PARENS, CSharpParser.PLUS,
                         CSharpParser.MINUS, CSharpParser.STAR, CSharpParser.AMP, CSharpParser.CARET, CSharpParser.BANG,
                         CSharpParser.TILDE, CSharpParser.OP_INC, CSharpParser.OP_DEC, CSharpParser.OP_RANGE]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1153
                self.throwable_expression()
                pass
            elif token in [CSharpParser.OPEN_BRACE]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1154
                self.block()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Query_expressionContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def from_clause(self):
            return self.getTypedRuleContext(CSharpParser.From_clauseContext, 0)

        def query_body(self):
            return self.getTypedRuleContext(CSharpParser.Query_bodyContext, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_query_expression

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterQuery_expression"):
                listener.enterQuery_expression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitQuery_expression"):
                listener.exitQuery_expression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitQuery_expression"):
                return visitor.visitQuery_expression(self)
            else:
                return visitor.visitChildren(self)

    def query_expression(self):

        localctx = CSharpParser.Query_expressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 132, self.RULE_query_expression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1157
            self.from_clause()
            self.state = 1158
            self.query_body()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class From_clauseContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FROM(self):
            return self.getToken(CSharpParser.FROM, 0)

        def identifier(self):
            return self.getTypedRuleContext(CSharpParser.IdentifierContext, 0)

        def IN(self):
            return self.getToken(CSharpParser.IN, 0)

        def expression(self):
            return self.getTypedRuleContext(CSharpParser.ExpressionContext, 0)

        def type_(self):
            return self.getTypedRuleContext(CSharpParser.Type_Context, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_from_clause

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterFrom_clause"):
                listener.enterFrom_clause(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitFrom_clause"):
                listener.exitFrom_clause(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitFrom_clause"):
                return visitor.visitFrom_clause(self)
            else:
                return visitor.visitChildren(self)

    def from_clause(self):

        localctx = CSharpParser.From_clauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 134, self.RULE_from_clause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1160
            self.match(CSharpParser.FROM)
            self.state = 1162
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 113, self._ctx)
            if la_ == 1:
                self.state = 1161
                self.type_()

            self.state = 1164
            self.identifier()
            self.state = 1165
            self.match(CSharpParser.IN)
            self.state = 1166
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Query_bodyContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def select_or_group_clause(self):
            return self.getTypedRuleContext(CSharpParser.Select_or_group_clauseContext, 0)

        def query_body_clause(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(CSharpParser.Query_body_clauseContext)
            else:
                return self.getTypedRuleContext(CSharpParser.Query_body_clauseContext, i)

        def query_continuation(self):
            return self.getTypedRuleContext(CSharpParser.Query_continuationContext, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_query_body

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterQuery_body"):
                listener.enterQuery_body(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitQuery_body"):
                listener.exitQuery_body(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitQuery_body"):
                return visitor.visitQuery_body(self)
            else:
                return visitor.visitChildren(self)

    def query_body(self):

        localctx = CSharpParser.Query_bodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 136, self.RULE_query_body)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1171
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 48)) & ~0x3f) == 0 and ((1 << (_la - 48)) & (
                    (1 << (CSharpParser.FROM - 48)) | (1 << (CSharpParser.JOIN - 48)) | (
                    1 << (CSharpParser.LET - 48)) | (1 << (CSharpParser.ORDERBY - 48)) | (
                            1 << (CSharpParser.WHERE - 48)))) != 0):
                self.state = 1168
                self.query_body_clause()
                self.state = 1173
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1174
            self.select_or_group_clause()
            self.state = 1176
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 115, self._ctx)
            if la_ == 1:
                self.state = 1175
                self.query_continuation()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Query_body_clauseContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def from_clause(self):
            return self.getTypedRuleContext(CSharpParser.From_clauseContext, 0)

        def let_clause(self):
            return self.getTypedRuleContext(CSharpParser.Let_clauseContext, 0)

        def where_clause(self):
            return self.getTypedRuleContext(CSharpParser.Where_clauseContext, 0)

        def combined_join_clause(self):
            return self.getTypedRuleContext(CSharpParser.Combined_join_clauseContext, 0)

        def orderby_clause(self):
            return self.getTypedRuleContext(CSharpParser.Orderby_clauseContext, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_query_body_clause

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterQuery_body_clause"):
                listener.enterQuery_body_clause(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitQuery_body_clause"):
                listener.exitQuery_body_clause(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitQuery_body_clause"):
                return visitor.visitQuery_body_clause(self)
            else:
                return visitor.visitChildren(self)

    def query_body_clause(self):

        localctx = CSharpParser.Query_body_clauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 138, self.RULE_query_body_clause)
        try:
            self.state = 1183
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [CSharpParser.FROM]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1178
                self.from_clause()
                pass
            elif token in [CSharpParser.LET]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1179
                self.let_clause()
                pass
            elif token in [CSharpParser.WHERE]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1180
                self.where_clause()
                pass
            elif token in [CSharpParser.JOIN]:
                self.enterOuterAlt(localctx, 4)
                self.state = 1181
                self.combined_join_clause()
                pass
            elif token in [CSharpParser.ORDERBY]:
                self.enterOuterAlt(localctx, 5)
                self.state = 1182
                self.orderby_clause()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Let_clauseContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LET(self):
            return self.getToken(CSharpParser.LET, 0)

        def identifier(self):
            return self.getTypedRuleContext(CSharpParser.IdentifierContext, 0)

        def ASSIGNMENT(self):
            return self.getToken(CSharpParser.ASSIGNMENT, 0)

        def expression(self):
            return self.getTypedRuleContext(CSharpParser.ExpressionContext, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_let_clause

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterLet_clause"):
                listener.enterLet_clause(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitLet_clause"):
                listener.exitLet_clause(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitLet_clause"):
                return visitor.visitLet_clause(self)
            else:
                return visitor.visitChildren(self)

    def let_clause(self):

        localctx = CSharpParser.Let_clauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 140, self.RULE_let_clause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1185
            self.match(CSharpParser.LET)
            self.state = 1186
            self.identifier()
            self.state = 1187
            self.match(CSharpParser.ASSIGNMENT)
            self.state = 1188
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Where_clauseContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WHERE(self):
            return self.getToken(CSharpParser.WHERE, 0)

        def expression(self):
            return self.getTypedRuleContext(CSharpParser.ExpressionContext, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_where_clause

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterWhere_clause"):
                listener.enterWhere_clause(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitWhere_clause"):
                listener.exitWhere_clause(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitWhere_clause"):
                return visitor.visitWhere_clause(self)
            else:
                return visitor.visitChildren(self)

    def where_clause(self):

        localctx = CSharpParser.Where_clauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 142, self.RULE_where_clause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1190
            self.match(CSharpParser.WHERE)
            self.state = 1191
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Combined_join_clauseContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def JOIN(self):
            return self.getToken(CSharpParser.JOIN, 0)

        def identifier(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(CSharpParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(CSharpParser.IdentifierContext, i)

        def IN(self):
            return self.getToken(CSharpParser.IN, 0)

        def expression(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(CSharpParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(CSharpParser.ExpressionContext, i)

        def ON(self):
            return self.getToken(CSharpParser.ON, 0)

        def EQUALS(self):
            return self.getToken(CSharpParser.EQUALS, 0)

        def type_(self):
            return self.getTypedRuleContext(CSharpParser.Type_Context, 0)

        def INTO(self):
            return self.getToken(CSharpParser.INTO, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_combined_join_clause

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterCombined_join_clause"):
                listener.enterCombined_join_clause(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitCombined_join_clause"):
                listener.exitCombined_join_clause(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitCombined_join_clause"):
                return visitor.visitCombined_join_clause(self)
            else:
                return visitor.visitChildren(self)

    def combined_join_clause(self):

        localctx = CSharpParser.Combined_join_clauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 144, self.RULE_combined_join_clause)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1193
            self.match(CSharpParser.JOIN)
            self.state = 1195
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 117, self._ctx)
            if la_ == 1:
                self.state = 1194
                self.type_()

            self.state = 1197
            self.identifier()
            self.state = 1198
            self.match(CSharpParser.IN)
            self.state = 1199
            self.expression()
            self.state = 1200
            self.match(CSharpParser.ON)
            self.state = 1201
            self.expression()
            self.state = 1202
            self.match(CSharpParser.EQUALS)
            self.state = 1203
            self.expression()
            self.state = 1206
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == CSharpParser.INTO:
                self.state = 1204
                self.match(CSharpParser.INTO)
                self.state = 1205
                self.identifier()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Orderby_clauseContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ORDERBY(self):
            return self.getToken(CSharpParser.ORDERBY, 0)

        def ordering(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(CSharpParser.OrderingContext)
            else:
                return self.getTypedRuleContext(CSharpParser.OrderingContext, i)

        def COMMA(self, i: int = None):
            if i is None:
                return self.getTokens(CSharpParser.COMMA)
            else:
                return self.getToken(CSharpParser.COMMA, i)

        def getRuleIndex(self):
            return CSharpParser.RULE_orderby_clause

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterOrderby_clause"):
                listener.enterOrderby_clause(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitOrderby_clause"):
                listener.exitOrderby_clause(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitOrderby_clause"):
                return visitor.visitOrderby_clause(self)
            else:
                return visitor.visitChildren(self)

    def orderby_clause(self):

        localctx = CSharpParser.Orderby_clauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 146, self.RULE_orderby_clause)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1208
            self.match(CSharpParser.ORDERBY)
            self.state = 1209
            self.ordering()
            self.state = 1214
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == CSharpParser.COMMA:
                self.state = 1210
                self.match(CSharpParser.COMMA)
                self.state = 1211
                self.ordering()
                self.state = 1216
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class OrderingContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.dir = None  # Token

        def expression(self):
            return self.getTypedRuleContext(CSharpParser.ExpressionContext, 0)

        def ASCENDING(self):
            return self.getToken(CSharpParser.ASCENDING, 0)

        def DESCENDING(self):
            return self.getToken(CSharpParser.DESCENDING, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_ordering

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterOrdering"):
                listener.enterOrdering(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitOrdering"):
                listener.exitOrdering(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitOrdering"):
                return visitor.visitOrdering(self)
            else:
                return visitor.visitChildren(self)

    def ordering(self):

        localctx = CSharpParser.OrderingContext(self, self._ctx, self.state)
        self.enterRule(localctx, 148, self.RULE_ordering)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1217
            self.expression()
            self.state = 1219
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == CSharpParser.ASCENDING or _la == CSharpParser.DESCENDING:
                self.state = 1218
                localctx.dir = self._input.LT(1)
                _la = self._input.LA(1)
                if not (_la == CSharpParser.ASCENDING or _la == CSharpParser.DESCENDING):
                    localctx.dir = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Select_or_group_clauseContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SELECT(self):
            return self.getToken(CSharpParser.SELECT, 0)

        def expression(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(CSharpParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(CSharpParser.ExpressionContext, i)

        def GROUP(self):
            return self.getToken(CSharpParser.GROUP, 0)

        def BY(self):
            return self.getToken(CSharpParser.BY, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_select_or_group_clause

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterSelect_or_group_clause"):
                listener.enterSelect_or_group_clause(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitSelect_or_group_clause"):
                listener.exitSelect_or_group_clause(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitSelect_or_group_clause"):
                return visitor.visitSelect_or_group_clause(self)
            else:
                return visitor.visitChildren(self)

    def select_or_group_clause(self):

        localctx = CSharpParser.Select_or_group_clauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 150, self.RULE_select_or_group_clause)
        try:
            self.state = 1228
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [CSharpParser.SELECT]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1221
                self.match(CSharpParser.SELECT)
                self.state = 1222
                self.expression()
                pass
            elif token in [CSharpParser.GROUP]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1223
                self.match(CSharpParser.GROUP)
                self.state = 1224
                self.expression()
                self.state = 1225
                self.match(CSharpParser.BY)
                self.state = 1226
                self.expression()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Query_continuationContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INTO(self):
            return self.getToken(CSharpParser.INTO, 0)

        def identifier(self):
            return self.getTypedRuleContext(CSharpParser.IdentifierContext, 0)

        def query_body(self):
            return self.getTypedRuleContext(CSharpParser.Query_bodyContext, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_query_continuation

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterQuery_continuation"):
                listener.enterQuery_continuation(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitQuery_continuation"):
                listener.exitQuery_continuation(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitQuery_continuation"):
                return visitor.visitQuery_continuation(self)
            else:
                return visitor.visitChildren(self)

    def query_continuation(self):

        localctx = CSharpParser.Query_continuationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 152, self.RULE_query_continuation)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1230
            self.match(CSharpParser.INTO)
            self.state = 1231
            self.identifier()
            self.state = 1232
            self.query_body()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class StatementContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def labeled_Statement(self):
            return self.getTypedRuleContext(CSharpParser.Labeled_StatementContext, 0)

        def declarationStatement(self):
            return self.getTypedRuleContext(CSharpParser.DeclarationStatementContext, 0)

        def embedded_statement(self):
            return self.getTypedRuleContext(CSharpParser.Embedded_statementContext, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_statement

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterStatement"):
                listener.enterStatement(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitStatement"):
                listener.exitStatement(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitStatement"):
                return visitor.visitStatement(self)
            else:
                return visitor.visitChildren(self)

    def statement(self):

        localctx = CSharpParser.StatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 154, self.RULE_statement)
        try:
            self.state = 1237
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 122, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1234
                self.labeled_Statement()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1235
                self.declarationStatement()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1236
                self.embedded_statement()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DeclarationStatementContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def local_variable_declaration(self):
            return self.getTypedRuleContext(CSharpParser.Local_variable_declarationContext, 0)

        def SEMICOLON(self):
            return self.getToken(CSharpParser.SEMICOLON, 0)

        def local_constant_declaration(self):
            return self.getTypedRuleContext(CSharpParser.Local_constant_declarationContext, 0)

        def local_function_declaration(self):
            return self.getTypedRuleContext(CSharpParser.Local_function_declarationContext, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_declarationStatement

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterDeclarationStatement"):
                listener.enterDeclarationStatement(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitDeclarationStatement"):
                listener.exitDeclarationStatement(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitDeclarationStatement"):
                return visitor.visitDeclarationStatement(self)
            else:
                return visitor.visitChildren(self)

    def declarationStatement(self):

        localctx = CSharpParser.DeclarationStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 156, self.RULE_declarationStatement)
        try:
            self.state = 1246
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 123, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1239
                self.local_variable_declaration()
                self.state = 1240
                self.match(CSharpParser.SEMICOLON)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1242
                self.local_constant_declaration()
                self.state = 1243
                self.match(CSharpParser.SEMICOLON)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1245
                self.local_function_declaration()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Local_function_declarationContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def local_function_header(self):
            return self.getTypedRuleContext(CSharpParser.Local_function_headerContext, 0)

        def local_function_body(self):
            return self.getTypedRuleContext(CSharpParser.Local_function_bodyContext, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_local_function_declaration

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterLocal_function_declaration"):
                listener.enterLocal_function_declaration(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitLocal_function_declaration"):
                listener.exitLocal_function_declaration(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitLocal_function_declaration"):
                return visitor.visitLocal_function_declaration(self)
            else:
                return visitor.visitChildren(self)

    def local_function_declaration(self):

        localctx = CSharpParser.Local_function_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 158, self.RULE_local_function_declaration)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1248
            self.local_function_header()
            self.state = 1249
            self.local_function_body()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Local_function_headerContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def return_type(self):
            return self.getTypedRuleContext(CSharpParser.Return_typeContext, 0)

        def identifier(self):
            return self.getTypedRuleContext(CSharpParser.IdentifierContext, 0)

        def OPEN_PARENS(self):
            return self.getToken(CSharpParser.OPEN_PARENS, 0)

        def CLOSE_PARENS(self):
            return self.getToken(CSharpParser.CLOSE_PARENS, 0)

        def local_function_modifiers(self):
            return self.getTypedRuleContext(CSharpParser.Local_function_modifiersContext, 0)

        def type_parameter_list(self):
            return self.getTypedRuleContext(CSharpParser.Type_parameter_listContext, 0)

        def formal_parameter_list(self):
            return self.getTypedRuleContext(CSharpParser.Formal_parameter_listContext, 0)

        def type_parameter_constraints_clauses(self):
            return self.getTypedRuleContext(CSharpParser.Type_parameter_constraints_clausesContext, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_local_function_header

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterLocal_function_header"):
                listener.enterLocal_function_header(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitLocal_function_header"):
                listener.exitLocal_function_header(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitLocal_function_header"):
                return visitor.visitLocal_function_header(self)
            else:
                return visitor.visitChildren(self)

    def local_function_header(self):

        localctx = CSharpParser.Local_function_headerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 160, self.RULE_local_function_header)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1252
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 124, self._ctx)
            if la_ == 1:
                self.state = 1251
                self.local_function_modifiers()

            self.state = 1254
            self.return_type()
            self.state = 1255
            self.identifier()
            self.state = 1257
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == CSharpParser.LT:
                self.state = 1256
                self.type_parameter_list()

            self.state = 1259
            self.match(CSharpParser.OPEN_PARENS)
            self.state = 1261
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 10)) & ~0x3f) == 0 and ((1 << (_la - 10)) & (
                    (1 << (CSharpParser.ADD - 10)) | (1 << (CSharpParser.ALIAS - 10)) | (
                    1 << (CSharpParser.ARGLIST - 10)) | (1 << (CSharpParser.ASCENDING - 10)) | (
                            1 << (CSharpParser.ASYNC - 10)) | (1 << (CSharpParser.AWAIT - 10)) | (
                            1 << (CSharpParser.BOOL - 10)) | (1 << (CSharpParser.BY - 10)) | (
                            1 << (CSharpParser.BYTE - 10)) | (1 << (CSharpParser.CHAR - 10)) | (
                            1 << (CSharpParser.DECIMAL - 10)) | (1 << (CSharpParser.DESCENDING - 10)) | (
                            1 << (CSharpParser.DOUBLE - 10)) | (1 << (CSharpParser.DYNAMIC - 10)) | (
                            1 << (CSharpParser.EQUALS - 10)) | (1 << (CSharpParser.FLOAT - 10)) | (
                            1 << (CSharpParser.FROM - 10)) | (1 << (CSharpParser.GET - 10)) | (
                            1 << (CSharpParser.GROUP - 10)) | (1 << (CSharpParser.IN - 10)) | (
                            1 << (CSharpParser.INT - 10)) | (1 << (CSharpParser.INTO - 10)) | (
                            1 << (CSharpParser.JOIN - 10)) | (1 << (CSharpParser.LET - 10)) | (
                            1 << (CSharpParser.LONG - 10)) | (1 << (CSharpParser.NAMEOF - 10)) | (
                            1 << (CSharpParser.OBJECT - 10)) | (1 << (CSharpParser.ON - 10)) | (
                            1 << (CSharpParser.ORDERBY - 10)) | (1 << (CSharpParser.OUT - 10)))) != 0) or (
                    (((_la - 74)) & ~0x3f) == 0 and ((1 << (_la - 74)) & (
                    (1 << (CSharpParser.PARAMS - 74)) | (1 << (CSharpParser.PARTIAL - 74)) | (
                    1 << (CSharpParser.REF - 74)) | (1 << (CSharpParser.REMOVE - 74)) | (
                            1 << (CSharpParser.SBYTE - 74)) | (1 << (CSharpParser.SELECT - 74)) | (
                            1 << (CSharpParser.SET - 74)) | (1 << (CSharpParser.SHORT - 74)) | (
                            1 << (CSharpParser.STRING - 74)) | (1 << (CSharpParser.THIS - 74)) | (
                            1 << (CSharpParser.UINT - 74)) | (1 << (CSharpParser.ULONG - 74)) | (
                            1 << (CSharpParser.UNMANAGED - 74)) | (1 << (CSharpParser.USHORT - 74)) | (
                            1 << (CSharpParser.VAR - 74)) | (1 << (CSharpParser.VOID - 74)) | (
                            1 << (CSharpParser.WHEN - 74)) | (1 << (CSharpParser.WHERE - 74)) | (
                            1 << (CSharpParser.YIELD - 74)) | (1 << (CSharpParser.IDENTIFIER - 74)) | (
                            1 << (CSharpParser.OPEN_BRACKET - 74)) | (1 << (CSharpParser.OPEN_PARENS - 74)))) != 0):
                self.state = 1260
                self.formal_parameter_list()

            self.state = 1263
            self.match(CSharpParser.CLOSE_PARENS)
            self.state = 1265
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == CSharpParser.WHERE:
                self.state = 1264
                self.type_parameter_constraints_clauses()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Local_function_modifiersContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ASYNC(self):
            return self.getToken(CSharpParser.ASYNC, 0)

        def UNSAFE(self):
            return self.getToken(CSharpParser.UNSAFE, 0)

        def STATIC(self):
            return self.getToken(CSharpParser.STATIC, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_local_function_modifiers

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterLocal_function_modifiers"):
                listener.enterLocal_function_modifiers(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitLocal_function_modifiers"):
                listener.exitLocal_function_modifiers(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitLocal_function_modifiers"):
                return visitor.visitLocal_function_modifiers(self)
            else:
                return visitor.visitChildren(self)

    def local_function_modifiers(self):

        localctx = CSharpParser.Local_function_modifiersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 162, self.RULE_local_function_modifiers)
        self._la = 0  # Token type
        try:
            self.state = 1273
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [CSharpParser.ASYNC, CSharpParser.UNSAFE]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1267
                _la = self._input.LA(1)
                if not (_la == CSharpParser.ASYNC or _la == CSharpParser.UNSAFE):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1269
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == CSharpParser.STATIC:
                    self.state = 1268
                    self.match(CSharpParser.STATIC)

                pass
            elif token in [CSharpParser.STATIC]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1271
                self.match(CSharpParser.STATIC)
                self.state = 1272
                _la = self._input.LA(1)
                if not (_la == CSharpParser.ASYNC or _la == CSharpParser.UNSAFE):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Local_function_bodyContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def block(self):
            return self.getTypedRuleContext(CSharpParser.BlockContext, 0)

        def right_arrow(self):
            return self.getTypedRuleContext(CSharpParser.Right_arrowContext, 0)

        def throwable_expression(self):
            return self.getTypedRuleContext(CSharpParser.Throwable_expressionContext, 0)

        def SEMICOLON(self):
            return self.getToken(CSharpParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_local_function_body

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterLocal_function_body"):
                listener.enterLocal_function_body(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitLocal_function_body"):
                listener.exitLocal_function_body(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitLocal_function_body"):
                return visitor.visitLocal_function_body(self)
            else:
                return visitor.visitChildren(self)

    def local_function_body(self):

        localctx = CSharpParser.Local_function_bodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 164, self.RULE_local_function_body)
        try:
            self.state = 1280
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [CSharpParser.OPEN_BRACE]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1275
                self.block()
                pass
            elif token in [CSharpParser.ASSIGNMENT]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1276
                self.right_arrow()
                self.state = 1277
                self.throwable_expression()
                self.state = 1278
                self.match(CSharpParser.SEMICOLON)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Labeled_StatementContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(CSharpParser.IdentifierContext, 0)

        def COLON(self):
            return self.getToken(CSharpParser.COLON, 0)

        def statement(self):
            return self.getTypedRuleContext(CSharpParser.StatementContext, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_labeled_Statement

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterLabeled_Statement"):
                listener.enterLabeled_Statement(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitLabeled_Statement"):
                listener.exitLabeled_Statement(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitLabeled_Statement"):
                return visitor.visitLabeled_Statement(self)
            else:
                return visitor.visitChildren(self)

    def labeled_Statement(self):

        localctx = CSharpParser.Labeled_StatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 166, self.RULE_labeled_Statement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1282
            self.identifier()
            self.state = 1283
            self.match(CSharpParser.COLON)
            self.state = 1284
            self.statement()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Embedded_statementContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def block(self):
            return self.getTypedRuleContext(CSharpParser.BlockContext, 0)

        def simple_embedded_statement(self):
            return self.getTypedRuleContext(CSharpParser.Simple_embedded_statementContext, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_embedded_statement

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterEmbedded_statement"):
                listener.enterEmbedded_statement(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitEmbedded_statement"):
                listener.exitEmbedded_statement(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitEmbedded_statement"):
                return visitor.visitEmbedded_statement(self)
            else:
                return visitor.visitChildren(self)

    def embedded_statement(self):

        localctx = CSharpParser.Embedded_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 168, self.RULE_embedded_statement)
        try:
            self.state = 1288
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [CSharpParser.OPEN_BRACE]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1286
                self.block()
                pass
            elif token in [CSharpParser.ADD, CSharpParser.ALIAS, CSharpParser.ARGLIST, CSharpParser.ASCENDING,
                           CSharpParser.ASYNC, CSharpParser.AWAIT, CSharpParser.BASE, CSharpParser.BOOL,
                           CSharpParser.BREAK, CSharpParser.BY, CSharpParser.BYTE, CSharpParser.CHAR,
                           CSharpParser.CHECKED, CSharpParser.CONTINUE, CSharpParser.DECIMAL, CSharpParser.DEFAULT,
                           CSharpParser.DELEGATE, CSharpParser.DESCENDING, CSharpParser.DO, CSharpParser.DOUBLE,
                           CSharpParser.DYNAMIC, CSharpParser.EQUALS, CSharpParser.FALSE, CSharpParser.FIXED,
                           CSharpParser.FLOAT, CSharpParser.FOR, CSharpParser.FOREACH, CSharpParser.FROM,
                           CSharpParser.GET, CSharpParser.GOTO, CSharpParser.GROUP, CSharpParser.IF, CSharpParser.INT,
                           CSharpParser.INTO, CSharpParser.JOIN, CSharpParser.LET, CSharpParser.LOCK, CSharpParser.LONG,
                           CSharpParser.NAMEOF, CSharpParser.NEW, CSharpParser.NULL_, CSharpParser.OBJECT,
                           CSharpParser.ON, CSharpParser.ORDERBY, CSharpParser.PARTIAL, CSharpParser.REF,
                           CSharpParser.REMOVE, CSharpParser.RETURN, CSharpParser.SBYTE, CSharpParser.SELECT,
                           CSharpParser.SET, CSharpParser.SHORT, CSharpParser.SIZEOF, CSharpParser.STRING,
                           CSharpParser.SWITCH, CSharpParser.THIS, CSharpParser.THROW, CSharpParser.TRUE,
                           CSharpParser.TRY, CSharpParser.TYPEOF, CSharpParser.UINT, CSharpParser.ULONG,
                           CSharpParser.UNCHECKED, CSharpParser.UNMANAGED, CSharpParser.UNSAFE, CSharpParser.USHORT,
                           CSharpParser.USING, CSharpParser.VAR, CSharpParser.WHEN, CSharpParser.WHERE,
                           CSharpParser.WHILE, CSharpParser.YIELD, CSharpParser.IDENTIFIER, CSharpParser.LITERAL_ACCESS,
                           CSharpParser.INTEGER_LITERAL, CSharpParser.HEX_INTEGER_LITERAL,
                           CSharpParser.BIN_INTEGER_LITERAL, CSharpParser.REAL_LITERAL, CSharpParser.CHARACTER_LITERAL,
                           CSharpParser.REGULAR_STRING, CSharpParser.VERBATIUM_STRING,
                           CSharpParser.INTERPOLATED_REGULAR_STRING_START,
                           CSharpParser.INTERPOLATED_VERBATIUM_STRING_START, CSharpParser.OPEN_PARENS,
                           CSharpParser.SEMICOLON, CSharpParser.PLUS, CSharpParser.MINUS, CSharpParser.STAR,
                           CSharpParser.AMP, CSharpParser.CARET, CSharpParser.BANG, CSharpParser.TILDE,
                           CSharpParser.OP_INC, CSharpParser.OP_DEC, CSharpParser.OP_RANGE]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1287
                self.simple_embedded_statement()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Simple_embedded_statementContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def getRuleIndex(self):
            return CSharpParser.RULE_simple_embedded_statement

        def copyFrom(self, ctx: ParserRuleContext):
            super().copyFrom(ctx)

    class TryStatementContext(Simple_embedded_statementContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a CSharpParser.Simple_embedded_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def TRY(self):
            return self.getToken(CSharpParser.TRY, 0)

        def block(self):
            return self.getTypedRuleContext(CSharpParser.BlockContext, 0)

        def catch_clauses(self):
            return self.getTypedRuleContext(CSharpParser.Catch_clausesContext, 0)

        def finally_clause(self):
            return self.getTypedRuleContext(CSharpParser.Finally_clauseContext, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterTryStatement"):
                listener.enterTryStatement(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitTryStatement"):
                listener.exitTryStatement(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitTryStatement"):
                return visitor.visitTryStatement(self)
            else:
                return visitor.visitChildren(self)

    class CheckedStatementContext(Simple_embedded_statementContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a CSharpParser.Simple_embedded_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def CHECKED(self):
            return self.getToken(CSharpParser.CHECKED, 0)

        def block(self):
            return self.getTypedRuleContext(CSharpParser.BlockContext, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterCheckedStatement"):
                listener.enterCheckedStatement(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitCheckedStatement"):
                listener.exitCheckedStatement(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitCheckedStatement"):
                return visitor.visitCheckedStatement(self)
            else:
                return visitor.visitChildren(self)

    class ThrowStatementContext(Simple_embedded_statementContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a CSharpParser.Simple_embedded_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def THROW(self):
            return self.getToken(CSharpParser.THROW, 0)

        def SEMICOLON(self):
            return self.getToken(CSharpParser.SEMICOLON, 0)

        def expression(self):
            return self.getTypedRuleContext(CSharpParser.ExpressionContext, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterThrowStatement"):
                listener.enterThrowStatement(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitThrowStatement"):
                listener.exitThrowStatement(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitThrowStatement"):
                return visitor.visitThrowStatement(self)
            else:
                return visitor.visitChildren(self)

    class TheEmptyStatementContext(Simple_embedded_statementContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a CSharpParser.Simple_embedded_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def SEMICOLON(self):
            return self.getToken(CSharpParser.SEMICOLON, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterTheEmptyStatement"):
                listener.enterTheEmptyStatement(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitTheEmptyStatement"):
                listener.exitTheEmptyStatement(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitTheEmptyStatement"):
                return visitor.visitTheEmptyStatement(self)
            else:
                return visitor.visitChildren(self)

    class UnsafeStatementContext(Simple_embedded_statementContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a CSharpParser.Simple_embedded_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def UNSAFE(self):
            return self.getToken(CSharpParser.UNSAFE, 0)

        def block(self):
            return self.getTypedRuleContext(CSharpParser.BlockContext, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterUnsafeStatement"):
                listener.enterUnsafeStatement(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitUnsafeStatement"):
                listener.exitUnsafeStatement(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitUnsafeStatement"):
                return visitor.visitUnsafeStatement(self)
            else:
                return visitor.visitChildren(self)

    class ForStatementContext(Simple_embedded_statementContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a CSharpParser.Simple_embedded_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def FOR(self):
            return self.getToken(CSharpParser.FOR, 0)

        def OPEN_PARENS(self):
            return self.getToken(CSharpParser.OPEN_PARENS, 0)

        def SEMICOLON(self, i: int = None):
            if i is None:
                return self.getTokens(CSharpParser.SEMICOLON)
            else:
                return self.getToken(CSharpParser.SEMICOLON, i)

        def CLOSE_PARENS(self):
            return self.getToken(CSharpParser.CLOSE_PARENS, 0)

        def embedded_statement(self):
            return self.getTypedRuleContext(CSharpParser.Embedded_statementContext, 0)

        def for_initializer(self):
            return self.getTypedRuleContext(CSharpParser.For_initializerContext, 0)

        def expression(self):
            return self.getTypedRuleContext(CSharpParser.ExpressionContext, 0)

        def for_iterator(self):
            return self.getTypedRuleContext(CSharpParser.For_iteratorContext, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterForStatement"):
                listener.enterForStatement(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitForStatement"):
                listener.exitForStatement(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitForStatement"):
                return visitor.visitForStatement(self)
            else:
                return visitor.visitChildren(self)

    class BreakStatementContext(Simple_embedded_statementContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a CSharpParser.Simple_embedded_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def BREAK(self):
            return self.getToken(CSharpParser.BREAK, 0)

        def SEMICOLON(self):
            return self.getToken(CSharpParser.SEMICOLON, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterBreakStatement"):
                listener.enterBreakStatement(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitBreakStatement"):
                listener.exitBreakStatement(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitBreakStatement"):
                return visitor.visitBreakStatement(self)
            else:
                return visitor.visitChildren(self)

    class IfStatementContext(Simple_embedded_statementContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a CSharpParser.Simple_embedded_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def IF(self):
            return self.getToken(CSharpParser.IF, 0)

        def OPEN_PARENS(self):
            return self.getToken(CSharpParser.OPEN_PARENS, 0)

        def expression(self):
            return self.getTypedRuleContext(CSharpParser.ExpressionContext, 0)

        def CLOSE_PARENS(self):
            return self.getToken(CSharpParser.CLOSE_PARENS, 0)

        def if_body(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(CSharpParser.If_bodyContext)
            else:
                return self.getTypedRuleContext(CSharpParser.If_bodyContext, i)

        def ELSE(self):
            return self.getToken(CSharpParser.ELSE, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterIfStatement"):
                listener.enterIfStatement(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitIfStatement"):
                listener.exitIfStatement(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitIfStatement"):
                return visitor.visitIfStatement(self)
            else:
                return visitor.visitChildren(self)

    class ReturnStatementContext(Simple_embedded_statementContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a CSharpParser.Simple_embedded_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def RETURN(self):
            return self.getToken(CSharpParser.RETURN, 0)

        def SEMICOLON(self):
            return self.getToken(CSharpParser.SEMICOLON, 0)

        def expression(self):
            return self.getTypedRuleContext(CSharpParser.ExpressionContext, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterReturnStatement"):
                listener.enterReturnStatement(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitReturnStatement"):
                listener.exitReturnStatement(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitReturnStatement"):
                return visitor.visitReturnStatement(self)
            else:
                return visitor.visitChildren(self)

    class GotoStatementContext(Simple_embedded_statementContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a CSharpParser.Simple_embedded_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def GOTO(self):
            return self.getToken(CSharpParser.GOTO, 0)

        def SEMICOLON(self):
            return self.getToken(CSharpParser.SEMICOLON, 0)

        def identifier(self):
            return self.getTypedRuleContext(CSharpParser.IdentifierContext, 0)

        def CASE(self):
            return self.getToken(CSharpParser.CASE, 0)

        def expression(self):
            return self.getTypedRuleContext(CSharpParser.ExpressionContext, 0)

        def DEFAULT(self):
            return self.getToken(CSharpParser.DEFAULT, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterGotoStatement"):
                listener.enterGotoStatement(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitGotoStatement"):
                listener.exitGotoStatement(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitGotoStatement"):
                return visitor.visitGotoStatement(self)
            else:
                return visitor.visitChildren(self)

    class SwitchStatementContext(Simple_embedded_statementContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a CSharpParser.Simple_embedded_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def SWITCH(self):
            return self.getToken(CSharpParser.SWITCH, 0)

        def OPEN_PARENS(self):
            return self.getToken(CSharpParser.OPEN_PARENS, 0)

        def expression(self):
            return self.getTypedRuleContext(CSharpParser.ExpressionContext, 0)

        def CLOSE_PARENS(self):
            return self.getToken(CSharpParser.CLOSE_PARENS, 0)

        def OPEN_BRACE(self):
            return self.getToken(CSharpParser.OPEN_BRACE, 0)

        def CLOSE_BRACE(self):
            return self.getToken(CSharpParser.CLOSE_BRACE, 0)

        def switch_section(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(CSharpParser.Switch_sectionContext)
            else:
                return self.getTypedRuleContext(CSharpParser.Switch_sectionContext, i)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterSwitchStatement"):
                listener.enterSwitchStatement(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitSwitchStatement"):
                listener.exitSwitchStatement(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitSwitchStatement"):
                return visitor.visitSwitchStatement(self)
            else:
                return visitor.visitChildren(self)

    class FixedStatementContext(Simple_embedded_statementContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a CSharpParser.Simple_embedded_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def FIXED(self):
            return self.getToken(CSharpParser.FIXED, 0)

        def OPEN_PARENS(self):
            return self.getToken(CSharpParser.OPEN_PARENS, 0)

        def pointer_type(self):
            return self.getTypedRuleContext(CSharpParser.Pointer_typeContext, 0)

        def fixed_pointer_declarators(self):
            return self.getTypedRuleContext(CSharpParser.Fixed_pointer_declaratorsContext, 0)

        def CLOSE_PARENS(self):
            return self.getToken(CSharpParser.CLOSE_PARENS, 0)

        def embedded_statement(self):
            return self.getTypedRuleContext(CSharpParser.Embedded_statementContext, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterFixedStatement"):
                listener.enterFixedStatement(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitFixedStatement"):
                listener.exitFixedStatement(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitFixedStatement"):
                return visitor.visitFixedStatement(self)
            else:
                return visitor.visitChildren(self)

    class WhileStatementContext(Simple_embedded_statementContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a CSharpParser.Simple_embedded_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def WHILE(self):
            return self.getToken(CSharpParser.WHILE, 0)

        def OPEN_PARENS(self):
            return self.getToken(CSharpParser.OPEN_PARENS, 0)

        def expression(self):
            return self.getTypedRuleContext(CSharpParser.ExpressionContext, 0)

        def CLOSE_PARENS(self):
            return self.getToken(CSharpParser.CLOSE_PARENS, 0)

        def embedded_statement(self):
            return self.getTypedRuleContext(CSharpParser.Embedded_statementContext, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterWhileStatement"):
                listener.enterWhileStatement(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitWhileStatement"):
                listener.exitWhileStatement(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitWhileStatement"):
                return visitor.visitWhileStatement(self)
            else:
                return visitor.visitChildren(self)

    class DoStatementContext(Simple_embedded_statementContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a CSharpParser.Simple_embedded_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DO(self):
            return self.getToken(CSharpParser.DO, 0)

        def embedded_statement(self):
            return self.getTypedRuleContext(CSharpParser.Embedded_statementContext, 0)

        def WHILE(self):
            return self.getToken(CSharpParser.WHILE, 0)

        def OPEN_PARENS(self):
            return self.getToken(CSharpParser.OPEN_PARENS, 0)

        def expression(self):
            return self.getTypedRuleContext(CSharpParser.ExpressionContext, 0)

        def CLOSE_PARENS(self):
            return self.getToken(CSharpParser.CLOSE_PARENS, 0)

        def SEMICOLON(self):
            return self.getToken(CSharpParser.SEMICOLON, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterDoStatement"):
                listener.enterDoStatement(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitDoStatement"):
                listener.exitDoStatement(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitDoStatement"):
                return visitor.visitDoStatement(self)
            else:
                return visitor.visitChildren(self)

    class ForeachStatementContext(Simple_embedded_statementContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a CSharpParser.Simple_embedded_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def FOREACH(self):
            return self.getToken(CSharpParser.FOREACH, 0)

        def OPEN_PARENS(self):
            return self.getToken(CSharpParser.OPEN_PARENS, 0)

        def local_variable_type(self):
            return self.getTypedRuleContext(CSharpParser.Local_variable_typeContext, 0)

        def identifier(self):
            return self.getTypedRuleContext(CSharpParser.IdentifierContext, 0)

        def IN(self):
            return self.getToken(CSharpParser.IN, 0)

        def expression(self):
            return self.getTypedRuleContext(CSharpParser.ExpressionContext, 0)

        def CLOSE_PARENS(self):
            return self.getToken(CSharpParser.CLOSE_PARENS, 0)

        def embedded_statement(self):
            return self.getTypedRuleContext(CSharpParser.Embedded_statementContext, 0)

        def AWAIT(self):
            return self.getToken(CSharpParser.AWAIT, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterForeachStatement"):
                listener.enterForeachStatement(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitForeachStatement"):
                listener.exitForeachStatement(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitForeachStatement"):
                return visitor.visitForeachStatement(self)
            else:
                return visitor.visitChildren(self)

    class UncheckedStatementContext(Simple_embedded_statementContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a CSharpParser.Simple_embedded_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def UNCHECKED(self):
            return self.getToken(CSharpParser.UNCHECKED, 0)

        def block(self):
            return self.getTypedRuleContext(CSharpParser.BlockContext, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterUncheckedStatement"):
                listener.enterUncheckedStatement(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitUncheckedStatement"):
                listener.exitUncheckedStatement(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitUncheckedStatement"):
                return visitor.visitUncheckedStatement(self)
            else:
                return visitor.visitChildren(self)

    class ExpressionStatementContext(Simple_embedded_statementContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a CSharpParser.Simple_embedded_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expression(self):
            return self.getTypedRuleContext(CSharpParser.ExpressionContext, 0)

        def SEMICOLON(self):
            return self.getToken(CSharpParser.SEMICOLON, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterExpressionStatement"):
                listener.enterExpressionStatement(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitExpressionStatement"):
                listener.exitExpressionStatement(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitExpressionStatement"):
                return visitor.visitExpressionStatement(self)
            else:
                return visitor.visitChildren(self)

    class ContinueStatementContext(Simple_embedded_statementContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a CSharpParser.Simple_embedded_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def CONTINUE(self):
            return self.getToken(CSharpParser.CONTINUE, 0)

        def SEMICOLON(self):
            return self.getToken(CSharpParser.SEMICOLON, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterContinueStatement"):
                listener.enterContinueStatement(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitContinueStatement"):
                listener.exitContinueStatement(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitContinueStatement"):
                return visitor.visitContinueStatement(self)
            else:
                return visitor.visitChildren(self)

    class UsingStatementContext(Simple_embedded_statementContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a CSharpParser.Simple_embedded_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def USING(self):
            return self.getToken(CSharpParser.USING, 0)

        def OPEN_PARENS(self):
            return self.getToken(CSharpParser.OPEN_PARENS, 0)

        def resource_acquisition(self):
            return self.getTypedRuleContext(CSharpParser.Resource_acquisitionContext, 0)

        def CLOSE_PARENS(self):
            return self.getToken(CSharpParser.CLOSE_PARENS, 0)

        def embedded_statement(self):
            return self.getTypedRuleContext(CSharpParser.Embedded_statementContext, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterUsingStatement"):
                listener.enterUsingStatement(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitUsingStatement"):
                listener.exitUsingStatement(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitUsingStatement"):
                return visitor.visitUsingStatement(self)
            else:
                return visitor.visitChildren(self)

    class LockStatementContext(Simple_embedded_statementContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a CSharpParser.Simple_embedded_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LOCK(self):
            return self.getToken(CSharpParser.LOCK, 0)

        def OPEN_PARENS(self):
            return self.getToken(CSharpParser.OPEN_PARENS, 0)

        def expression(self):
            return self.getTypedRuleContext(CSharpParser.ExpressionContext, 0)

        def CLOSE_PARENS(self):
            return self.getToken(CSharpParser.CLOSE_PARENS, 0)

        def embedded_statement(self):
            return self.getTypedRuleContext(CSharpParser.Embedded_statementContext, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterLockStatement"):
                listener.enterLockStatement(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitLockStatement"):
                listener.exitLockStatement(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitLockStatement"):
                return visitor.visitLockStatement(self)
            else:
                return visitor.visitChildren(self)

    class YieldStatementContext(Simple_embedded_statementContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a CSharpParser.Simple_embedded_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def YIELD(self):
            return self.getToken(CSharpParser.YIELD, 0)

        def SEMICOLON(self):
            return self.getToken(CSharpParser.SEMICOLON, 0)

        def RETURN(self):
            return self.getToken(CSharpParser.RETURN, 0)

        def expression(self):
            return self.getTypedRuleContext(CSharpParser.ExpressionContext, 0)

        def BREAK(self):
            return self.getToken(CSharpParser.BREAK, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterYieldStatement"):
                listener.enterYieldStatement(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitYieldStatement"):
                listener.exitYieldStatement(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitYieldStatement"):
                return visitor.visitYieldStatement(self)
            else:
                return visitor.visitChildren(self)

    def simple_embedded_statement(self):

        localctx = CSharpParser.Simple_embedded_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 170, self.RULE_simple_embedded_statement)
        self._la = 0  # Token type
        try:
            self.state = 1420
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 144, self._ctx)
            if la_ == 1:
                localctx = CSharpParser.TheEmptyStatementContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1290
                self.match(CSharpParser.SEMICOLON)
                pass

            elif la_ == 2:
                localctx = CSharpParser.ExpressionStatementContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1291
                self.expression()
                self.state = 1292
                self.match(CSharpParser.SEMICOLON)
                pass

            elif la_ == 3:
                localctx = CSharpParser.IfStatementContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 1294
                self.match(CSharpParser.IF)
                self.state = 1295
                self.match(CSharpParser.OPEN_PARENS)
                self.state = 1296
                self.expression()
                self.state = 1297
                self.match(CSharpParser.CLOSE_PARENS)
                self.state = 1298
                self.if_body()
                self.state = 1301
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input, 132, self._ctx)
                if la_ == 1:
                    self.state = 1299
                    self.match(CSharpParser.ELSE)
                    self.state = 1300
                    self.if_body()

                pass

            elif la_ == 4:
                localctx = CSharpParser.SwitchStatementContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 1303
                self.match(CSharpParser.SWITCH)
                self.state = 1304
                self.match(CSharpParser.OPEN_PARENS)
                self.state = 1305
                self.expression()
                self.state = 1306
                self.match(CSharpParser.CLOSE_PARENS)
                self.state = 1307
                self.match(CSharpParser.OPEN_BRACE)
                self.state = 1311
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la == CSharpParser.CASE or _la == CSharpParser.DEFAULT:
                    self.state = 1308
                    self.switch_section()
                    self.state = 1313
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1314
                self.match(CSharpParser.CLOSE_BRACE)
                pass

            elif la_ == 5:
                localctx = CSharpParser.WhileStatementContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 1316
                self.match(CSharpParser.WHILE)
                self.state = 1317
                self.match(CSharpParser.OPEN_PARENS)
                self.state = 1318
                self.expression()
                self.state = 1319
                self.match(CSharpParser.CLOSE_PARENS)
                self.state = 1320
                self.embedded_statement()
                pass

            elif la_ == 6:
                localctx = CSharpParser.DoStatementContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 1322
                self.match(CSharpParser.DO)
                self.state = 1323
                self.embedded_statement()
                self.state = 1324
                self.match(CSharpParser.WHILE)
                self.state = 1325
                self.match(CSharpParser.OPEN_PARENS)
                self.state = 1326
                self.expression()
                self.state = 1327
                self.match(CSharpParser.CLOSE_PARENS)
                self.state = 1328
                self.match(CSharpParser.SEMICOLON)
                pass

            elif la_ == 7:
                localctx = CSharpParser.ForStatementContext(self, localctx)
                self.enterOuterAlt(localctx, 7)
                self.state = 1330
                self.match(CSharpParser.FOR)
                self.state = 1331
                self.match(CSharpParser.OPEN_PARENS)
                self.state = 1333
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & (
                        (1 << CSharpParser.ADD) | (1 << CSharpParser.ALIAS) | (1 << CSharpParser.ARGLIST) | (
                        1 << CSharpParser.ASCENDING) | (1 << CSharpParser.ASYNC) | (1 << CSharpParser.AWAIT) | (
                                1 << CSharpParser.BASE) | (1 << CSharpParser.BOOL) | (1 << CSharpParser.BY) | (
                                1 << CSharpParser.BYTE) | (1 << CSharpParser.CHAR) | (1 << CSharpParser.CHECKED) | (
                                1 << CSharpParser.DECIMAL) | (1 << CSharpParser.DEFAULT) | (
                                1 << CSharpParser.DELEGATE) | (1 << CSharpParser.DESCENDING) | (
                                1 << CSharpParser.DOUBLE) | (1 << CSharpParser.DYNAMIC) | (1 << CSharpParser.EQUALS) | (
                                1 << CSharpParser.FALSE) | (1 << CSharpParser.FIXED) | (1 << CSharpParser.FLOAT) | (
                                1 << CSharpParser.FROM) | (1 << CSharpParser.GET) | (1 << CSharpParser.GROUP) | (
                                1 << CSharpParser.INT) | (1 << CSharpParser.INTO) | (1 << CSharpParser.JOIN) | (
                                1 << CSharpParser.LET) | (1 << CSharpParser.LONG))) != 0) or (
                        (((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & (
                        (1 << (CSharpParser.NAMEOF - 64)) | (1 << (CSharpParser.NEW - 64)) | (
                        1 << (CSharpParser.NULL_ - 64)) | (1 << (CSharpParser.OBJECT - 64)) | (
                                1 << (CSharpParser.ON - 64)) | (1 << (CSharpParser.ORDERBY - 64)) | (
                                1 << (CSharpParser.PARTIAL - 64)) | (1 << (CSharpParser.REF - 64)) | (
                                1 << (CSharpParser.REMOVE - 64)) | (1 << (CSharpParser.SBYTE - 64)) | (
                                1 << (CSharpParser.SELECT - 64)) | (1 << (CSharpParser.SET - 64)) | (
                                1 << (CSharpParser.SHORT - 64)) | (1 << (CSharpParser.SIZEOF - 64)) | (
                                1 << (CSharpParser.STRING - 64)) | (1 << (CSharpParser.THIS - 64)) | (
                                1 << (CSharpParser.TRUE - 64)) | (1 << (CSharpParser.TYPEOF - 64)) | (
                                1 << (CSharpParser.UINT - 64)) | (1 << (CSharpParser.ULONG - 64)) | (
                                1 << (CSharpParser.UNCHECKED - 64)) | (1 << (CSharpParser.UNMANAGED - 64)) | (
                                1 << (CSharpParser.USHORT - 64)) | (1 << (CSharpParser.USING - 64)) | (
                                1 << (CSharpParser.VAR - 64)) | (1 << (CSharpParser.VOID - 64)) | (
                                1 << (CSharpParser.WHEN - 64)) | (1 << (CSharpParser.WHERE - 64)) | (
                                1 << (CSharpParser.YIELD - 64)) | (1 << (CSharpParser.IDENTIFIER - 64)) | (
                                1 << (CSharpParser.LITERAL_ACCESS - 64)) | (
                                1 << (CSharpParser.INTEGER_LITERAL - 64)) | (
                                1 << (CSharpParser.HEX_INTEGER_LITERAL - 64)) | (
                                1 << (CSharpParser.BIN_INTEGER_LITERAL - 64)) | (
                                1 << (CSharpParser.REAL_LITERAL - 64)) | (
                                1 << (CSharpParser.CHARACTER_LITERAL - 64)) | (
                                1 << (CSharpParser.REGULAR_STRING - 64)) | (
                                1 << (CSharpParser.VERBATIUM_STRING - 64)) | (
                                1 << (CSharpParser.INTERPOLATED_REGULAR_STRING_START - 64)) | (
                                1 << (CSharpParser.INTERPOLATED_VERBATIUM_STRING_START - 64)))) != 0) or (
                        (((_la - 129)) & ~0x3f) == 0 and ((1 << (_la - 129)) & (
                        (1 << (CSharpParser.OPEN_PARENS - 129)) | (1 << (CSharpParser.PLUS - 129)) | (
                        1 << (CSharpParser.MINUS - 129)) | (1 << (CSharpParser.STAR - 129)) | (
                                1 << (CSharpParser.AMP - 129)) | (1 << (CSharpParser.CARET - 129)) | (
                                1 << (CSharpParser.BANG - 129)) | (1 << (CSharpParser.TILDE - 129)) | (
                                1 << (CSharpParser.OP_INC - 129)) | (1 << (CSharpParser.OP_DEC - 129)) | (
                                1 << (CSharpParser.OP_RANGE - 129)))) != 0):
                    self.state = 1332
                    self.for_initializer()

                self.state = 1335
                self.match(CSharpParser.SEMICOLON)
                self.state = 1337
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & (
                        (1 << CSharpParser.ADD) | (1 << CSharpParser.ALIAS) | (1 << CSharpParser.ARGLIST) | (
                        1 << CSharpParser.ASCENDING) | (1 << CSharpParser.ASYNC) | (1 << CSharpParser.AWAIT) | (
                                1 << CSharpParser.BASE) | (1 << CSharpParser.BOOL) | (1 << CSharpParser.BY) | (
                                1 << CSharpParser.BYTE) | (1 << CSharpParser.CHAR) | (1 << CSharpParser.CHECKED) | (
                                1 << CSharpParser.DECIMAL) | (1 << CSharpParser.DEFAULT) | (
                                1 << CSharpParser.DELEGATE) | (1 << CSharpParser.DESCENDING) | (
                                1 << CSharpParser.DOUBLE) | (1 << CSharpParser.DYNAMIC) | (1 << CSharpParser.EQUALS) | (
                                1 << CSharpParser.FALSE) | (1 << CSharpParser.FLOAT) | (1 << CSharpParser.FROM) | (
                                1 << CSharpParser.GET) | (1 << CSharpParser.GROUP) | (1 << CSharpParser.INT) | (
                                1 << CSharpParser.INTO) | (1 << CSharpParser.JOIN) | (1 << CSharpParser.LET) | (
                                1 << CSharpParser.LONG))) != 0) or ((((_la - 64)) & ~0x3f) == 0 and (
                        (1 << (_la - 64)) & ((1 << (CSharpParser.NAMEOF - 64)) | (1 << (CSharpParser.NEW - 64)) | (
                        1 << (CSharpParser.NULL_ - 64)) | (1 << (CSharpParser.OBJECT - 64)) | (
                                                     1 << (CSharpParser.ON - 64)) | (
                                                     1 << (CSharpParser.ORDERBY - 64)) | (
                                                     1 << (CSharpParser.PARTIAL - 64)) | (
                                                     1 << (CSharpParser.REF - 64)) | (
                                                     1 << (CSharpParser.REMOVE - 64)) | (
                                                     1 << (CSharpParser.SBYTE - 64)) | (
                                                     1 << (CSharpParser.SELECT - 64)) | (
                                                     1 << (CSharpParser.SET - 64)) | (
                                                     1 << (CSharpParser.SHORT - 64)) | (
                                                     1 << (CSharpParser.SIZEOF - 64)) | (
                                                     1 << (CSharpParser.STRING - 64)) | (
                                                     1 << (CSharpParser.THIS - 64)) | (
                                                     1 << (CSharpParser.TRUE - 64)) | (
                                                     1 << (CSharpParser.TYPEOF - 64)) | (
                                                     1 << (CSharpParser.UINT - 64)) | (
                                                     1 << (CSharpParser.ULONG - 64)) | (
                                                     1 << (CSharpParser.UNCHECKED - 64)) | (
                                                     1 << (CSharpParser.UNMANAGED - 64)) | (
                                                     1 << (CSharpParser.USHORT - 64)) | (
                                                     1 << (CSharpParser.VAR - 64)) | (1 << (CSharpParser.WHEN - 64)) | (
                                                     1 << (CSharpParser.WHERE - 64)) | (
                                                     1 << (CSharpParser.YIELD - 64)) | (
                                                     1 << (CSharpParser.IDENTIFIER - 64)) | (
                                                     1 << (CSharpParser.LITERAL_ACCESS - 64)) | (
                                                     1 << (CSharpParser.INTEGER_LITERAL - 64)) | (
                                                     1 << (CSharpParser.HEX_INTEGER_LITERAL - 64)) | (
                                                     1 << (CSharpParser.BIN_INTEGER_LITERAL - 64)) | (
                                                     1 << (CSharpParser.REAL_LITERAL - 64)) | (
                                                     1 << (CSharpParser.CHARACTER_LITERAL - 64)) | (
                                                     1 << (CSharpParser.REGULAR_STRING - 64)) | (
                                                     1 << (CSharpParser.VERBATIUM_STRING - 64)) | (
                                                     1 << (CSharpParser.INTERPOLATED_REGULAR_STRING_START - 64)) | (
                                                     1 << (
                                                     CSharpParser.INTERPOLATED_VERBATIUM_STRING_START - 64)))) != 0) or (
                        (((_la - 129)) & ~0x3f) == 0 and ((1 << (_la - 129)) & (
                        (1 << (CSharpParser.OPEN_PARENS - 129)) | (1 << (CSharpParser.PLUS - 129)) | (
                        1 << (CSharpParser.MINUS - 129)) | (1 << (CSharpParser.STAR - 129)) | (
                                1 << (CSharpParser.AMP - 129)) | (1 << (CSharpParser.CARET - 129)) | (
                                1 << (CSharpParser.BANG - 129)) | (1 << (CSharpParser.TILDE - 129)) | (
                                1 << (CSharpParser.OP_INC - 129)) | (1 << (CSharpParser.OP_DEC - 129)) | (
                                1 << (CSharpParser.OP_RANGE - 129)))) != 0):
                    self.state = 1336
                    self.expression()

                self.state = 1339
                self.match(CSharpParser.SEMICOLON)
                self.state = 1341
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & (
                        (1 << CSharpParser.ADD) | (1 << CSharpParser.ALIAS) | (1 << CSharpParser.ARGLIST) | (
                        1 << CSharpParser.ASCENDING) | (1 << CSharpParser.ASYNC) | (1 << CSharpParser.AWAIT) | (
                                1 << CSharpParser.BASE) | (1 << CSharpParser.BOOL) | (1 << CSharpParser.BY) | (
                                1 << CSharpParser.BYTE) | (1 << CSharpParser.CHAR) | (1 << CSharpParser.CHECKED) | (
                                1 << CSharpParser.DECIMAL) | (1 << CSharpParser.DEFAULT) | (
                                1 << CSharpParser.DELEGATE) | (1 << CSharpParser.DESCENDING) | (
                                1 << CSharpParser.DOUBLE) | (1 << CSharpParser.DYNAMIC) | (1 << CSharpParser.EQUALS) | (
                                1 << CSharpParser.FALSE) | (1 << CSharpParser.FLOAT) | (1 << CSharpParser.FROM) | (
                                1 << CSharpParser.GET) | (1 << CSharpParser.GROUP) | (1 << CSharpParser.INT) | (
                                1 << CSharpParser.INTO) | (1 << CSharpParser.JOIN) | (1 << CSharpParser.LET) | (
                                1 << CSharpParser.LONG))) != 0) or ((((_la - 64)) & ~0x3f) == 0 and (
                        (1 << (_la - 64)) & ((1 << (CSharpParser.NAMEOF - 64)) | (1 << (CSharpParser.NEW - 64)) | (
                        1 << (CSharpParser.NULL_ - 64)) | (1 << (CSharpParser.OBJECT - 64)) | (
                                                     1 << (CSharpParser.ON - 64)) | (
                                                     1 << (CSharpParser.ORDERBY - 64)) | (
                                                     1 << (CSharpParser.PARTIAL - 64)) | (
                                                     1 << (CSharpParser.REF - 64)) | (
                                                     1 << (CSharpParser.REMOVE - 64)) | (
                                                     1 << (CSharpParser.SBYTE - 64)) | (
                                                     1 << (CSharpParser.SELECT - 64)) | (
                                                     1 << (CSharpParser.SET - 64)) | (
                                                     1 << (CSharpParser.SHORT - 64)) | (
                                                     1 << (CSharpParser.SIZEOF - 64)) | (
                                                     1 << (CSharpParser.STRING - 64)) | (
                                                     1 << (CSharpParser.THIS - 64)) | (
                                                     1 << (CSharpParser.TRUE - 64)) | (
                                                     1 << (CSharpParser.TYPEOF - 64)) | (
                                                     1 << (CSharpParser.UINT - 64)) | (
                                                     1 << (CSharpParser.ULONG - 64)) | (
                                                     1 << (CSharpParser.UNCHECKED - 64)) | (
                                                     1 << (CSharpParser.UNMANAGED - 64)) | (
                                                     1 << (CSharpParser.USHORT - 64)) | (
                                                     1 << (CSharpParser.VAR - 64)) | (1 << (CSharpParser.WHEN - 64)) | (
                                                     1 << (CSharpParser.WHERE - 64)) | (
                                                     1 << (CSharpParser.YIELD - 64)) | (
                                                     1 << (CSharpParser.IDENTIFIER - 64)) | (
                                                     1 << (CSharpParser.LITERAL_ACCESS - 64)) | (
                                                     1 << (CSharpParser.INTEGER_LITERAL - 64)) | (
                                                     1 << (CSharpParser.HEX_INTEGER_LITERAL - 64)) | (
                                                     1 << (CSharpParser.BIN_INTEGER_LITERAL - 64)) | (
                                                     1 << (CSharpParser.REAL_LITERAL - 64)) | (
                                                     1 << (CSharpParser.CHARACTER_LITERAL - 64)) | (
                                                     1 << (CSharpParser.REGULAR_STRING - 64)) | (
                                                     1 << (CSharpParser.VERBATIUM_STRING - 64)) | (
                                                     1 << (CSharpParser.INTERPOLATED_REGULAR_STRING_START - 64)) | (
                                                     1 << (
                                                     CSharpParser.INTERPOLATED_VERBATIUM_STRING_START - 64)))) != 0) or (
                        (((_la - 129)) & ~0x3f) == 0 and ((1 << (_la - 129)) & (
                        (1 << (CSharpParser.OPEN_PARENS - 129)) | (1 << (CSharpParser.PLUS - 129)) | (
                        1 << (CSharpParser.MINUS - 129)) | (1 << (CSharpParser.STAR - 129)) | (
                                1 << (CSharpParser.AMP - 129)) | (1 << (CSharpParser.CARET - 129)) | (
                                1 << (CSharpParser.BANG - 129)) | (1 << (CSharpParser.TILDE - 129)) | (
                                1 << (CSharpParser.OP_INC - 129)) | (1 << (CSharpParser.OP_DEC - 129)) | (
                                1 << (CSharpParser.OP_RANGE - 129)))) != 0):
                    self.state = 1340
                    self.for_iterator()

                self.state = 1343
                self.match(CSharpParser.CLOSE_PARENS)
                self.state = 1344
                self.embedded_statement()
                pass

            elif la_ == 8:
                localctx = CSharpParser.ForeachStatementContext(self, localctx)
                self.enterOuterAlt(localctx, 8)
                self.state = 1346
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == CSharpParser.AWAIT:
                    self.state = 1345
                    self.match(CSharpParser.AWAIT)

                self.state = 1348
                self.match(CSharpParser.FOREACH)
                self.state = 1349
                self.match(CSharpParser.OPEN_PARENS)
                self.state = 1350
                self.local_variable_type()
                self.state = 1351
                self.identifier()
                self.state = 1352
                self.match(CSharpParser.IN)
                self.state = 1353
                self.expression()
                self.state = 1354
                self.match(CSharpParser.CLOSE_PARENS)
                self.state = 1355
                self.embedded_statement()
                pass

            elif la_ == 9:
                localctx = CSharpParser.BreakStatementContext(self, localctx)
                self.enterOuterAlt(localctx, 9)
                self.state = 1357
                self.match(CSharpParser.BREAK)
                self.state = 1358
                self.match(CSharpParser.SEMICOLON)
                pass

            elif la_ == 10:
                localctx = CSharpParser.ContinueStatementContext(self, localctx)
                self.enterOuterAlt(localctx, 10)
                self.state = 1359
                self.match(CSharpParser.CONTINUE)
                self.state = 1360
                self.match(CSharpParser.SEMICOLON)
                pass

            elif la_ == 11:
                localctx = CSharpParser.GotoStatementContext(self, localctx)
                self.enterOuterAlt(localctx, 11)
                self.state = 1361
                self.match(CSharpParser.GOTO)
                self.state = 1366
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [CSharpParser.ADD, CSharpParser.ALIAS, CSharpParser.ARGLIST, CSharpParser.ASCENDING,
                             CSharpParser.ASYNC, CSharpParser.AWAIT, CSharpParser.BY, CSharpParser.DESCENDING,
                             CSharpParser.DYNAMIC, CSharpParser.EQUALS, CSharpParser.FROM, CSharpParser.GET,
                             CSharpParser.GROUP, CSharpParser.INTO, CSharpParser.JOIN, CSharpParser.LET,
                             CSharpParser.NAMEOF, CSharpParser.ON, CSharpParser.ORDERBY, CSharpParser.PARTIAL,
                             CSharpParser.REMOVE, CSharpParser.SELECT, CSharpParser.SET, CSharpParser.UNMANAGED,
                             CSharpParser.VAR, CSharpParser.WHEN, CSharpParser.WHERE, CSharpParser.YIELD,
                             CSharpParser.IDENTIFIER]:
                    self.state = 1362
                    self.identifier()
                    pass
                elif token in [CSharpParser.CASE]:
                    self.state = 1363
                    self.match(CSharpParser.CASE)
                    self.state = 1364
                    self.expression()
                    pass
                elif token in [CSharpParser.DEFAULT]:
                    self.state = 1365
                    self.match(CSharpParser.DEFAULT)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 1368
                self.match(CSharpParser.SEMICOLON)
                pass

            elif la_ == 12:
                localctx = CSharpParser.ReturnStatementContext(self, localctx)
                self.enterOuterAlt(localctx, 12)
                self.state = 1369
                self.match(CSharpParser.RETURN)
                self.state = 1371
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & (
                        (1 << CSharpParser.ADD) | (1 << CSharpParser.ALIAS) | (1 << CSharpParser.ARGLIST) | (
                        1 << CSharpParser.ASCENDING) | (1 << CSharpParser.ASYNC) | (1 << CSharpParser.AWAIT) | (
                                1 << CSharpParser.BASE) | (1 << CSharpParser.BOOL) | (1 << CSharpParser.BY) | (
                                1 << CSharpParser.BYTE) | (1 << CSharpParser.CHAR) | (1 << CSharpParser.CHECKED) | (
                                1 << CSharpParser.DECIMAL) | (1 << CSharpParser.DEFAULT) | (
                                1 << CSharpParser.DELEGATE) | (1 << CSharpParser.DESCENDING) | (
                                1 << CSharpParser.DOUBLE) | (1 << CSharpParser.DYNAMIC) | (1 << CSharpParser.EQUALS) | (
                                1 << CSharpParser.FALSE) | (1 << CSharpParser.FLOAT) | (1 << CSharpParser.FROM) | (
                                1 << CSharpParser.GET) | (1 << CSharpParser.GROUP) | (1 << CSharpParser.INT) | (
                                1 << CSharpParser.INTO) | (1 << CSharpParser.JOIN) | (1 << CSharpParser.LET) | (
                                1 << CSharpParser.LONG))) != 0) or ((((_la - 64)) & ~0x3f) == 0 and (
                        (1 << (_la - 64)) & ((1 << (CSharpParser.NAMEOF - 64)) | (1 << (CSharpParser.NEW - 64)) | (
                        1 << (CSharpParser.NULL_ - 64)) | (1 << (CSharpParser.OBJECT - 64)) | (
                                                     1 << (CSharpParser.ON - 64)) | (
                                                     1 << (CSharpParser.ORDERBY - 64)) | (
                                                     1 << (CSharpParser.PARTIAL - 64)) | (
                                                     1 << (CSharpParser.REF - 64)) | (
                                                     1 << (CSharpParser.REMOVE - 64)) | (
                                                     1 << (CSharpParser.SBYTE - 64)) | (
                                                     1 << (CSharpParser.SELECT - 64)) | (
                                                     1 << (CSharpParser.SET - 64)) | (
                                                     1 << (CSharpParser.SHORT - 64)) | (
                                                     1 << (CSharpParser.SIZEOF - 64)) | (
                                                     1 << (CSharpParser.STRING - 64)) | (
                                                     1 << (CSharpParser.THIS - 64)) | (
                                                     1 << (CSharpParser.TRUE - 64)) | (
                                                     1 << (CSharpParser.TYPEOF - 64)) | (
                                                     1 << (CSharpParser.UINT - 64)) | (
                                                     1 << (CSharpParser.ULONG - 64)) | (
                                                     1 << (CSharpParser.UNCHECKED - 64)) | (
                                                     1 << (CSharpParser.UNMANAGED - 64)) | (
                                                     1 << (CSharpParser.USHORT - 64)) | (
                                                     1 << (CSharpParser.VAR - 64)) | (1 << (CSharpParser.WHEN - 64)) | (
                                                     1 << (CSharpParser.WHERE - 64)) | (
                                                     1 << (CSharpParser.YIELD - 64)) | (
                                                     1 << (CSharpParser.IDENTIFIER - 64)) | (
                                                     1 << (CSharpParser.LITERAL_ACCESS - 64)) | (
                                                     1 << (CSharpParser.INTEGER_LITERAL - 64)) | (
                                                     1 << (CSharpParser.HEX_INTEGER_LITERAL - 64)) | (
                                                     1 << (CSharpParser.BIN_INTEGER_LITERAL - 64)) | (
                                                     1 << (CSharpParser.REAL_LITERAL - 64)) | (
                                                     1 << (CSharpParser.CHARACTER_LITERAL - 64)) | (
                                                     1 << (CSharpParser.REGULAR_STRING - 64)) | (
                                                     1 << (CSharpParser.VERBATIUM_STRING - 64)) | (
                                                     1 << (CSharpParser.INTERPOLATED_REGULAR_STRING_START - 64)) | (
                                                     1 << (
                                                     CSharpParser.INTERPOLATED_VERBATIUM_STRING_START - 64)))) != 0) or (
                        (((_la - 129)) & ~0x3f) == 0 and ((1 << (_la - 129)) & (
                        (1 << (CSharpParser.OPEN_PARENS - 129)) | (1 << (CSharpParser.PLUS - 129)) | (
                        1 << (CSharpParser.MINUS - 129)) | (1 << (CSharpParser.STAR - 129)) | (
                                1 << (CSharpParser.AMP - 129)) | (1 << (CSharpParser.CARET - 129)) | (
                                1 << (CSharpParser.BANG - 129)) | (1 << (CSharpParser.TILDE - 129)) | (
                                1 << (CSharpParser.OP_INC - 129)) | (1 << (CSharpParser.OP_DEC - 129)) | (
                                1 << (CSharpParser.OP_RANGE - 129)))) != 0):
                    self.state = 1370
                    self.expression()

                self.state = 1373
                self.match(CSharpParser.SEMICOLON)
                pass

            elif la_ == 13:
                localctx = CSharpParser.ThrowStatementContext(self, localctx)
                self.enterOuterAlt(localctx, 13)
                self.state = 1374
                self.match(CSharpParser.THROW)
                self.state = 1376
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & (
                        (1 << CSharpParser.ADD) | (1 << CSharpParser.ALIAS) | (1 << CSharpParser.ARGLIST) | (
                        1 << CSharpParser.ASCENDING) | (1 << CSharpParser.ASYNC) | (1 << CSharpParser.AWAIT) | (
                                1 << CSharpParser.BASE) | (1 << CSharpParser.BOOL) | (1 << CSharpParser.BY) | (
                                1 << CSharpParser.BYTE) | (1 << CSharpParser.CHAR) | (1 << CSharpParser.CHECKED) | (
                                1 << CSharpParser.DECIMAL) | (1 << CSharpParser.DEFAULT) | (
                                1 << CSharpParser.DELEGATE) | (1 << CSharpParser.DESCENDING) | (
                                1 << CSharpParser.DOUBLE) | (1 << CSharpParser.DYNAMIC) | (1 << CSharpParser.EQUALS) | (
                                1 << CSharpParser.FALSE) | (1 << CSharpParser.FLOAT) | (1 << CSharpParser.FROM) | (
                                1 << CSharpParser.GET) | (1 << CSharpParser.GROUP) | (1 << CSharpParser.INT) | (
                                1 << CSharpParser.INTO) | (1 << CSharpParser.JOIN) | (1 << CSharpParser.LET) | (
                                1 << CSharpParser.LONG))) != 0) or ((((_la - 64)) & ~0x3f) == 0 and (
                        (1 << (_la - 64)) & ((1 << (CSharpParser.NAMEOF - 64)) | (1 << (CSharpParser.NEW - 64)) | (
                        1 << (CSharpParser.NULL_ - 64)) | (1 << (CSharpParser.OBJECT - 64)) | (
                                                     1 << (CSharpParser.ON - 64)) | (
                                                     1 << (CSharpParser.ORDERBY - 64)) | (
                                                     1 << (CSharpParser.PARTIAL - 64)) | (
                                                     1 << (CSharpParser.REF - 64)) | (
                                                     1 << (CSharpParser.REMOVE - 64)) | (
                                                     1 << (CSharpParser.SBYTE - 64)) | (
                                                     1 << (CSharpParser.SELECT - 64)) | (
                                                     1 << (CSharpParser.SET - 64)) | (
                                                     1 << (CSharpParser.SHORT - 64)) | (
                                                     1 << (CSharpParser.SIZEOF - 64)) | (
                                                     1 << (CSharpParser.STRING - 64)) | (
                                                     1 << (CSharpParser.THIS - 64)) | (
                                                     1 << (CSharpParser.TRUE - 64)) | (
                                                     1 << (CSharpParser.TYPEOF - 64)) | (
                                                     1 << (CSharpParser.UINT - 64)) | (
                                                     1 << (CSharpParser.ULONG - 64)) | (
                                                     1 << (CSharpParser.UNCHECKED - 64)) | (
                                                     1 << (CSharpParser.UNMANAGED - 64)) | (
                                                     1 << (CSharpParser.USHORT - 64)) | (
                                                     1 << (CSharpParser.VAR - 64)) | (1 << (CSharpParser.WHEN - 64)) | (
                                                     1 << (CSharpParser.WHERE - 64)) | (
                                                     1 << (CSharpParser.YIELD - 64)) | (
                                                     1 << (CSharpParser.IDENTIFIER - 64)) | (
                                                     1 << (CSharpParser.LITERAL_ACCESS - 64)) | (
                                                     1 << (CSharpParser.INTEGER_LITERAL - 64)) | (
                                                     1 << (CSharpParser.HEX_INTEGER_LITERAL - 64)) | (
                                                     1 << (CSharpParser.BIN_INTEGER_LITERAL - 64)) | (
                                                     1 << (CSharpParser.REAL_LITERAL - 64)) | (
                                                     1 << (CSharpParser.CHARACTER_LITERAL - 64)) | (
                                                     1 << (CSharpParser.REGULAR_STRING - 64)) | (
                                                     1 << (CSharpParser.VERBATIUM_STRING - 64)) | (
                                                     1 << (CSharpParser.INTERPOLATED_REGULAR_STRING_START - 64)) | (
                                                     1 << (
                                                     CSharpParser.INTERPOLATED_VERBATIUM_STRING_START - 64)))) != 0) or (
                        (((_la - 129)) & ~0x3f) == 0 and ((1 << (_la - 129)) & (
                        (1 << (CSharpParser.OPEN_PARENS - 129)) | (1 << (CSharpParser.PLUS - 129)) | (
                        1 << (CSharpParser.MINUS - 129)) | (1 << (CSharpParser.STAR - 129)) | (
                                1 << (CSharpParser.AMP - 129)) | (1 << (CSharpParser.CARET - 129)) | (
                                1 << (CSharpParser.BANG - 129)) | (1 << (CSharpParser.TILDE - 129)) | (
                                1 << (CSharpParser.OP_INC - 129)) | (1 << (CSharpParser.OP_DEC - 129)) | (
                                1 << (CSharpParser.OP_RANGE - 129)))) != 0):
                    self.state = 1375
                    self.expression()

                self.state = 1378
                self.match(CSharpParser.SEMICOLON)
                pass

            elif la_ == 14:
                localctx = CSharpParser.TryStatementContext(self, localctx)
                self.enterOuterAlt(localctx, 14)
                self.state = 1379
                self.match(CSharpParser.TRY)
                self.state = 1380
                self.block()
                self.state = 1386
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [CSharpParser.CATCH]:
                    self.state = 1381
                    self.catch_clauses()
                    self.state = 1383
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la == CSharpParser.FINALLY:
                        self.state = 1382
                        self.finally_clause()

                    pass
                elif token in [CSharpParser.FINALLY]:
                    self.state = 1385
                    self.finally_clause()
                    pass
                else:
                    raise NoViableAltException(self)

                pass

            elif la_ == 15:
                localctx = CSharpParser.CheckedStatementContext(self, localctx)
                self.enterOuterAlt(localctx, 15)
                self.state = 1388
                self.match(CSharpParser.CHECKED)
                self.state = 1389
                self.block()
                pass

            elif la_ == 16:
                localctx = CSharpParser.UncheckedStatementContext(self, localctx)
                self.enterOuterAlt(localctx, 16)
                self.state = 1390
                self.match(CSharpParser.UNCHECKED)
                self.state = 1391
                self.block()
                pass

            elif la_ == 17:
                localctx = CSharpParser.LockStatementContext(self, localctx)
                self.enterOuterAlt(localctx, 17)
                self.state = 1392
                self.match(CSharpParser.LOCK)
                self.state = 1393
                self.match(CSharpParser.OPEN_PARENS)
                self.state = 1394
                self.expression()
                self.state = 1395
                self.match(CSharpParser.CLOSE_PARENS)
                self.state = 1396
                self.embedded_statement()
                pass

            elif la_ == 18:
                localctx = CSharpParser.UsingStatementContext(self, localctx)
                self.enterOuterAlt(localctx, 18)
                self.state = 1398
                self.match(CSharpParser.USING)
                self.state = 1399
                self.match(CSharpParser.OPEN_PARENS)
                self.state = 1400
                self.resource_acquisition()
                self.state = 1401
                self.match(CSharpParser.CLOSE_PARENS)
                self.state = 1402
                self.embedded_statement()
                pass

            elif la_ == 19:
                localctx = CSharpParser.YieldStatementContext(self, localctx)
                self.enterOuterAlt(localctx, 19)
                self.state = 1404
                self.match(CSharpParser.YIELD)
                self.state = 1408
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [CSharpParser.RETURN]:
                    self.state = 1405
                    self.match(CSharpParser.RETURN)
                    self.state = 1406
                    self.expression()
                    pass
                elif token in [CSharpParser.BREAK]:
                    self.state = 1407
                    self.match(CSharpParser.BREAK)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 1410
                self.match(CSharpParser.SEMICOLON)
                pass

            elif la_ == 20:
                localctx = CSharpParser.UnsafeStatementContext(self, localctx)
                self.enterOuterAlt(localctx, 20)
                self.state = 1411
                self.match(CSharpParser.UNSAFE)
                self.state = 1412
                self.block()
                pass

            elif la_ == 21:
                localctx = CSharpParser.FixedStatementContext(self, localctx)
                self.enterOuterAlt(localctx, 21)
                self.state = 1413
                self.match(CSharpParser.FIXED)
                self.state = 1414
                self.match(CSharpParser.OPEN_PARENS)
                self.state = 1415
                self.pointer_type()
                self.state = 1416
                self.fixed_pointer_declarators()
                self.state = 1417
                self.match(CSharpParser.CLOSE_PARENS)
                self.state = 1418
                self.embedded_statement()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class BlockContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPEN_BRACE(self):
            return self.getToken(CSharpParser.OPEN_BRACE, 0)

        def CLOSE_BRACE(self):
            return self.getToken(CSharpParser.CLOSE_BRACE, 0)

        def statement_list(self):
            return self.getTypedRuleContext(CSharpParser.Statement_listContext, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_block

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterBlock"):
                listener.enterBlock(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitBlock"):
                listener.exitBlock(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitBlock"):
                return visitor.visitBlock(self)
            else:
                return visitor.visitChildren(self)

    def block(self):

        localctx = CSharpParser.BlockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 172, self.RULE_block)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1422
            self.match(CSharpParser.OPEN_BRACE)
            self.state = 1424
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & (
                    (1 << CSharpParser.ADD) | (1 << CSharpParser.ALIAS) | (1 << CSharpParser.ARGLIST) | (
                    1 << CSharpParser.ASCENDING) | (1 << CSharpParser.ASYNC) | (1 << CSharpParser.AWAIT) | (
                            1 << CSharpParser.BASE) | (1 << CSharpParser.BOOL) | (1 << CSharpParser.BREAK) | (
                            1 << CSharpParser.BY) | (1 << CSharpParser.BYTE) | (1 << CSharpParser.CHAR) | (
                            1 << CSharpParser.CHECKED) | (1 << CSharpParser.CONST) | (1 << CSharpParser.CONTINUE) | (
                            1 << CSharpParser.DECIMAL) | (1 << CSharpParser.DEFAULT) | (1 << CSharpParser.DELEGATE) | (
                            1 << CSharpParser.DESCENDING) | (1 << CSharpParser.DO) | (1 << CSharpParser.DOUBLE) | (
                            1 << CSharpParser.DYNAMIC) | (1 << CSharpParser.EQUALS) | (1 << CSharpParser.FALSE) | (
                            1 << CSharpParser.FIXED) | (1 << CSharpParser.FLOAT) | (1 << CSharpParser.FOR) | (
                            1 << CSharpParser.FOREACH) | (1 << CSharpParser.FROM) | (1 << CSharpParser.GET) | (
                            1 << CSharpParser.GOTO) | (1 << CSharpParser.GROUP) | (1 << CSharpParser.IF) | (
                            1 << CSharpParser.INT) | (1 << CSharpParser.INTO) | (1 << CSharpParser.JOIN) | (
                            1 << CSharpParser.LET) | (1 << CSharpParser.LOCK) | (1 << CSharpParser.LONG))) != 0) or (
                    (((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & (
                    (1 << (CSharpParser.NAMEOF - 64)) | (1 << (CSharpParser.NEW - 64)) | (
                    1 << (CSharpParser.NULL_ - 64)) | (1 << (CSharpParser.OBJECT - 64)) | (
                            1 << (CSharpParser.ON - 64)) | (1 << (CSharpParser.ORDERBY - 64)) | (
                            1 << (CSharpParser.PARTIAL - 64)) | (1 << (CSharpParser.REF - 64)) | (
                            1 << (CSharpParser.REMOVE - 64)) | (1 << (CSharpParser.RETURN - 64)) | (
                            1 << (CSharpParser.SBYTE - 64)) | (1 << (CSharpParser.SELECT - 64)) | (
                            1 << (CSharpParser.SET - 64)) | (1 << (CSharpParser.SHORT - 64)) | (
                            1 << (CSharpParser.SIZEOF - 64)) | (1 << (CSharpParser.STATIC - 64)) | (
                            1 << (CSharpParser.STRING - 64)) | (1 << (CSharpParser.SWITCH - 64)) | (
                            1 << (CSharpParser.THIS - 64)) | (1 << (CSharpParser.THROW - 64)) | (
                            1 << (CSharpParser.TRUE - 64)) | (1 << (CSharpParser.TRY - 64)) | (
                            1 << (CSharpParser.TYPEOF - 64)) | (1 << (CSharpParser.UINT - 64)) | (
                            1 << (CSharpParser.ULONG - 64)) | (1 << (CSharpParser.UNCHECKED - 64)) | (
                            1 << (CSharpParser.UNMANAGED - 64)) | (1 << (CSharpParser.UNSAFE - 64)) | (
                            1 << (CSharpParser.USHORT - 64)) | (1 << (CSharpParser.USING - 64)) | (
                            1 << (CSharpParser.VAR - 64)) | (1 << (CSharpParser.VOID - 64)) | (
                            1 << (CSharpParser.WHEN - 64)) | (1 << (CSharpParser.WHERE - 64)) | (
                            1 << (CSharpParser.WHILE - 64)) | (1 << (CSharpParser.YIELD - 64)) | (
                            1 << (CSharpParser.IDENTIFIER - 64)) | (1 << (CSharpParser.LITERAL_ACCESS - 64)) | (
                            1 << (CSharpParser.INTEGER_LITERAL - 64)) | (
                            1 << (CSharpParser.HEX_INTEGER_LITERAL - 64)) | (
                            1 << (CSharpParser.BIN_INTEGER_LITERAL - 64)) | (1 << (CSharpParser.REAL_LITERAL - 64)) | (
                            1 << (CSharpParser.CHARACTER_LITERAL - 64)) | (1 << (CSharpParser.REGULAR_STRING - 64)) | (
                            1 << (CSharpParser.VERBATIUM_STRING - 64)) | (
                            1 << (CSharpParser.INTERPOLATED_REGULAR_STRING_START - 64)) | (
                            1 << (CSharpParser.INTERPOLATED_VERBATIUM_STRING_START - 64)) | (
                            1 << (CSharpParser.OPEN_BRACE - 64)))) != 0) or ((((_la - 129)) & ~0x3f) == 0 and (
                    (1 << (_la - 129)) & (
                    (1 << (CSharpParser.OPEN_PARENS - 129)) | (1 << (CSharpParser.SEMICOLON - 129)) | (
                    1 << (CSharpParser.PLUS - 129)) | (1 << (CSharpParser.MINUS - 129)) | (
                            1 << (CSharpParser.STAR - 129)) | (1 << (CSharpParser.AMP - 129)) | (
                            1 << (CSharpParser.CARET - 129)) | (1 << (CSharpParser.BANG - 129)) | (
                            1 << (CSharpParser.TILDE - 129)) | (1 << (CSharpParser.OP_INC - 129)) | (
                            1 << (CSharpParser.OP_DEC - 129)) | (1 << (CSharpParser.OP_RANGE - 129)))) != 0):
                self.state = 1423
                self.statement_list()

            self.state = 1426
            self.match(CSharpParser.CLOSE_BRACE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Local_variable_declarationContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def local_variable_type(self):
            return self.getTypedRuleContext(CSharpParser.Local_variable_typeContext, 0)

        def local_variable_declarator(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(CSharpParser.Local_variable_declaratorContext)
            else:
                return self.getTypedRuleContext(CSharpParser.Local_variable_declaratorContext, i)

        def USING(self):
            return self.getToken(CSharpParser.USING, 0)

        def REF(self):
            return self.getToken(CSharpParser.REF, 0)

        def READONLY(self):
            return self.getToken(CSharpParser.READONLY, 0)

        def COMMA(self, i: int = None):
            if i is None:
                return self.getTokens(CSharpParser.COMMA)
            else:
                return self.getToken(CSharpParser.COMMA, i)

        def FIXED(self):
            return self.getToken(CSharpParser.FIXED, 0)

        def pointer_type(self):
            return self.getTypedRuleContext(CSharpParser.Pointer_typeContext, 0)

        def fixed_pointer_declarators(self):
            return self.getTypedRuleContext(CSharpParser.Fixed_pointer_declaratorsContext, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_local_variable_declaration

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterLocal_variable_declaration"):
                listener.enterLocal_variable_declaration(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitLocal_variable_declaration"):
                listener.exitLocal_variable_declaration(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitLocal_variable_declaration"):
                return visitor.visitLocal_variable_declaration(self)
            else:
                return visitor.visitChildren(self)

    def local_variable_declaration(self):

        localctx = CSharpParser.Local_variable_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 174, self.RULE_local_variable_declaration)
        self._la = 0  # Token type
        try:
            self.state = 1449
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [CSharpParser.ADD, CSharpParser.ALIAS, CSharpParser.ARGLIST, CSharpParser.ASCENDING,
                         CSharpParser.ASYNC, CSharpParser.AWAIT, CSharpParser.BOOL, CSharpParser.BY, CSharpParser.BYTE,
                         CSharpParser.CHAR, CSharpParser.DECIMAL, CSharpParser.DESCENDING, CSharpParser.DOUBLE,
                         CSharpParser.DYNAMIC, CSharpParser.EQUALS, CSharpParser.FLOAT, CSharpParser.FROM,
                         CSharpParser.GET, CSharpParser.GROUP, CSharpParser.INT, CSharpParser.INTO, CSharpParser.JOIN,
                         CSharpParser.LET, CSharpParser.LONG, CSharpParser.NAMEOF, CSharpParser.OBJECT, CSharpParser.ON,
                         CSharpParser.ORDERBY, CSharpParser.PARTIAL, CSharpParser.REF, CSharpParser.REMOVE,
                         CSharpParser.SBYTE, CSharpParser.SELECT, CSharpParser.SET, CSharpParser.SHORT,
                         CSharpParser.STRING, CSharpParser.UINT, CSharpParser.ULONG, CSharpParser.UNMANAGED,
                         CSharpParser.USHORT, CSharpParser.USING, CSharpParser.VAR, CSharpParser.VOID,
                         CSharpParser.WHEN, CSharpParser.WHERE, CSharpParser.YIELD, CSharpParser.IDENTIFIER,
                         CSharpParser.OPEN_PARENS]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1432
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input, 146, self._ctx)
                if la_ == 1:
                    self.state = 1428
                    self.match(CSharpParser.USING)

                elif la_ == 2:
                    self.state = 1429
                    self.match(CSharpParser.REF)

                elif la_ == 3:
                    self.state = 1430
                    self.match(CSharpParser.REF)
                    self.state = 1431
                    self.match(CSharpParser.READONLY)

                self.state = 1434
                self.local_variable_type()
                self.state = 1435
                self.local_variable_declarator()
                self.state = 1442
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la == CSharpParser.COMMA:
                    self.state = 1436
                    self.match(CSharpParser.COMMA)
                    self.state = 1437
                    self.local_variable_declarator()
                    self.state = 1438
                    if not self.IsLocalVariableDeclaration():
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, " self.IsLocalVariableDeclaration() ")
                    self.state = 1444
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass
            elif token in [CSharpParser.FIXED]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1445
                self.match(CSharpParser.FIXED)
                self.state = 1446
                self.pointer_type()
                self.state = 1447
                self.fixed_pointer_declarators()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Local_variable_typeContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def VAR(self):
            return self.getToken(CSharpParser.VAR, 0)

        def type_(self):
            return self.getTypedRuleContext(CSharpParser.Type_Context, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_local_variable_type

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterLocal_variable_type"):
                listener.enterLocal_variable_type(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitLocal_variable_type"):
                listener.exitLocal_variable_type(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitLocal_variable_type"):
                return visitor.visitLocal_variable_type(self)
            else:
                return visitor.visitChildren(self)

    def local_variable_type(self):

        localctx = CSharpParser.Local_variable_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 176, self.RULE_local_variable_type)
        try:
            self.state = 1453
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 149, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1451
                self.match(CSharpParser.VAR)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1452
                self.type_()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Local_variable_declaratorContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(CSharpParser.IdentifierContext, 0)

        def ASSIGNMENT(self):
            return self.getToken(CSharpParser.ASSIGNMENT, 0)

        def local_variable_initializer(self):
            return self.getTypedRuleContext(CSharpParser.Local_variable_initializerContext, 0)

        def REF(self):
            return self.getToken(CSharpParser.REF, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_local_variable_declarator

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterLocal_variable_declarator"):
                listener.enterLocal_variable_declarator(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitLocal_variable_declarator"):
                listener.exitLocal_variable_declarator(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitLocal_variable_declarator"):
                return visitor.visitLocal_variable_declarator(self)
            else:
                return visitor.visitChildren(self)

    def local_variable_declarator(self):

        localctx = CSharpParser.Local_variable_declaratorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 178, self.RULE_local_variable_declarator)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1455
            self.identifier()
            self.state = 1461
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 151, self._ctx)
            if la_ == 1:
                self.state = 1456
                self.match(CSharpParser.ASSIGNMENT)
                self.state = 1458
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input, 150, self._ctx)
                if la_ == 1:
                    self.state = 1457
                    self.match(CSharpParser.REF)

                self.state = 1460
                self.local_variable_initializer()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Local_variable_initializerContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(CSharpParser.ExpressionContext, 0)

        def array_initializer(self):
            return self.getTypedRuleContext(CSharpParser.Array_initializerContext, 0)

        def stackalloc_initializer(self):
            return self.getTypedRuleContext(CSharpParser.Stackalloc_initializerContext, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_local_variable_initializer

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterLocal_variable_initializer"):
                listener.enterLocal_variable_initializer(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitLocal_variable_initializer"):
                listener.exitLocal_variable_initializer(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitLocal_variable_initializer"):
                return visitor.visitLocal_variable_initializer(self)
            else:
                return visitor.visitChildren(self)

    def local_variable_initializer(self):

        localctx = CSharpParser.Local_variable_initializerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 180, self.RULE_local_variable_initializer)
        try:
            self.state = 1466
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [CSharpParser.ADD, CSharpParser.ALIAS, CSharpParser.ARGLIST, CSharpParser.ASCENDING,
                         CSharpParser.ASYNC, CSharpParser.AWAIT, CSharpParser.BASE, CSharpParser.BOOL, CSharpParser.BY,
                         CSharpParser.BYTE, CSharpParser.CHAR, CSharpParser.CHECKED, CSharpParser.DECIMAL,
                         CSharpParser.DEFAULT, CSharpParser.DELEGATE, CSharpParser.DESCENDING, CSharpParser.DOUBLE,
                         CSharpParser.DYNAMIC, CSharpParser.EQUALS, CSharpParser.FALSE, CSharpParser.FLOAT,
                         CSharpParser.FROM, CSharpParser.GET, CSharpParser.GROUP, CSharpParser.INT, CSharpParser.INTO,
                         CSharpParser.JOIN, CSharpParser.LET, CSharpParser.LONG, CSharpParser.NAMEOF, CSharpParser.NEW,
                         CSharpParser.NULL_, CSharpParser.OBJECT, CSharpParser.ON, CSharpParser.ORDERBY,
                         CSharpParser.PARTIAL, CSharpParser.REF, CSharpParser.REMOVE, CSharpParser.SBYTE,
                         CSharpParser.SELECT, CSharpParser.SET, CSharpParser.SHORT, CSharpParser.SIZEOF,
                         CSharpParser.STRING, CSharpParser.THIS, CSharpParser.TRUE, CSharpParser.TYPEOF,
                         CSharpParser.UINT, CSharpParser.ULONG, CSharpParser.UNCHECKED, CSharpParser.UNMANAGED,
                         CSharpParser.USHORT, CSharpParser.VAR, CSharpParser.WHEN, CSharpParser.WHERE,
                         CSharpParser.YIELD, CSharpParser.IDENTIFIER, CSharpParser.LITERAL_ACCESS,
                         CSharpParser.INTEGER_LITERAL, CSharpParser.HEX_INTEGER_LITERAL,
                         CSharpParser.BIN_INTEGER_LITERAL, CSharpParser.REAL_LITERAL, CSharpParser.CHARACTER_LITERAL,
                         CSharpParser.REGULAR_STRING, CSharpParser.VERBATIUM_STRING,
                         CSharpParser.INTERPOLATED_REGULAR_STRING_START,
                         CSharpParser.INTERPOLATED_VERBATIUM_STRING_START, CSharpParser.OPEN_PARENS, CSharpParser.PLUS,
                         CSharpParser.MINUS, CSharpParser.STAR, CSharpParser.AMP, CSharpParser.CARET, CSharpParser.BANG,
                         CSharpParser.TILDE, CSharpParser.OP_INC, CSharpParser.OP_DEC, CSharpParser.OP_RANGE]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1463
                self.expression()
                pass
            elif token in [CSharpParser.OPEN_BRACE]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1464
                self.array_initializer()
                pass
            elif token in [CSharpParser.STACKALLOC]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1465
                self.stackalloc_initializer()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Local_constant_declarationContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CONST(self):
            return self.getToken(CSharpParser.CONST, 0)

        def type_(self):
            return self.getTypedRuleContext(CSharpParser.Type_Context, 0)

        def constant_declarators(self):
            return self.getTypedRuleContext(CSharpParser.Constant_declaratorsContext, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_local_constant_declaration

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterLocal_constant_declaration"):
                listener.enterLocal_constant_declaration(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitLocal_constant_declaration"):
                listener.exitLocal_constant_declaration(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitLocal_constant_declaration"):
                return visitor.visitLocal_constant_declaration(self)
            else:
                return visitor.visitChildren(self)

    def local_constant_declaration(self):

        localctx = CSharpParser.Local_constant_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 182, self.RULE_local_constant_declaration)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1468
            self.match(CSharpParser.CONST)
            self.state = 1469
            self.type_()
            self.state = 1470
            self.constant_declarators()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class If_bodyContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def block(self):
            return self.getTypedRuleContext(CSharpParser.BlockContext, 0)

        def simple_embedded_statement(self):
            return self.getTypedRuleContext(CSharpParser.Simple_embedded_statementContext, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_if_body

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterIf_body"):
                listener.enterIf_body(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitIf_body"):
                listener.exitIf_body(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitIf_body"):
                return visitor.visitIf_body(self)
            else:
                return visitor.visitChildren(self)

    def if_body(self):

        localctx = CSharpParser.If_bodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 184, self.RULE_if_body)
        try:
            self.state = 1474
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [CSharpParser.OPEN_BRACE]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1472
                self.block()
                pass
            elif token in [CSharpParser.ADD, CSharpParser.ALIAS, CSharpParser.ARGLIST, CSharpParser.ASCENDING,
                           CSharpParser.ASYNC, CSharpParser.AWAIT, CSharpParser.BASE, CSharpParser.BOOL,
                           CSharpParser.BREAK, CSharpParser.BY, CSharpParser.BYTE, CSharpParser.CHAR,
                           CSharpParser.CHECKED, CSharpParser.CONTINUE, CSharpParser.DECIMAL, CSharpParser.DEFAULT,
                           CSharpParser.DELEGATE, CSharpParser.DESCENDING, CSharpParser.DO, CSharpParser.DOUBLE,
                           CSharpParser.DYNAMIC, CSharpParser.EQUALS, CSharpParser.FALSE, CSharpParser.FIXED,
                           CSharpParser.FLOAT, CSharpParser.FOR, CSharpParser.FOREACH, CSharpParser.FROM,
                           CSharpParser.GET, CSharpParser.GOTO, CSharpParser.GROUP, CSharpParser.IF, CSharpParser.INT,
                           CSharpParser.INTO, CSharpParser.JOIN, CSharpParser.LET, CSharpParser.LOCK, CSharpParser.LONG,
                           CSharpParser.NAMEOF, CSharpParser.NEW, CSharpParser.NULL_, CSharpParser.OBJECT,
                           CSharpParser.ON, CSharpParser.ORDERBY, CSharpParser.PARTIAL, CSharpParser.REF,
                           CSharpParser.REMOVE, CSharpParser.RETURN, CSharpParser.SBYTE, CSharpParser.SELECT,
                           CSharpParser.SET, CSharpParser.SHORT, CSharpParser.SIZEOF, CSharpParser.STRING,
                           CSharpParser.SWITCH, CSharpParser.THIS, CSharpParser.THROW, CSharpParser.TRUE,
                           CSharpParser.TRY, CSharpParser.TYPEOF, CSharpParser.UINT, CSharpParser.ULONG,
                           CSharpParser.UNCHECKED, CSharpParser.UNMANAGED, CSharpParser.UNSAFE, CSharpParser.USHORT,
                           CSharpParser.USING, CSharpParser.VAR, CSharpParser.WHEN, CSharpParser.WHERE,
                           CSharpParser.WHILE, CSharpParser.YIELD, CSharpParser.IDENTIFIER, CSharpParser.LITERAL_ACCESS,
                           CSharpParser.INTEGER_LITERAL, CSharpParser.HEX_INTEGER_LITERAL,
                           CSharpParser.BIN_INTEGER_LITERAL, CSharpParser.REAL_LITERAL, CSharpParser.CHARACTER_LITERAL,
                           CSharpParser.REGULAR_STRING, CSharpParser.VERBATIUM_STRING,
                           CSharpParser.INTERPOLATED_REGULAR_STRING_START,
                           CSharpParser.INTERPOLATED_VERBATIUM_STRING_START, CSharpParser.OPEN_PARENS,
                           CSharpParser.SEMICOLON, CSharpParser.PLUS, CSharpParser.MINUS, CSharpParser.STAR,
                           CSharpParser.AMP, CSharpParser.CARET, CSharpParser.BANG, CSharpParser.TILDE,
                           CSharpParser.OP_INC, CSharpParser.OP_DEC, CSharpParser.OP_RANGE]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1473
                self.simple_embedded_statement()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Switch_sectionContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def statement_list(self):
            return self.getTypedRuleContext(CSharpParser.Statement_listContext, 0)

        def switch_label(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(CSharpParser.Switch_labelContext)
            else:
                return self.getTypedRuleContext(CSharpParser.Switch_labelContext, i)

        def getRuleIndex(self):
            return CSharpParser.RULE_switch_section

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterSwitch_section"):
                listener.enterSwitch_section(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitSwitch_section"):
                listener.exitSwitch_section(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitSwitch_section"):
                return visitor.visitSwitch_section(self)
            else:
                return visitor.visitChildren(self)

    def switch_section(self):

        localctx = CSharpParser.Switch_sectionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 186, self.RULE_switch_section)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1477
            self._errHandler.sync(self)
            _alt = 1
            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 1476
                    self.switch_label()

                else:
                    raise NoViableAltException(self)
                self.state = 1479
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 154, self._ctx)

            self.state = 1481
            self.statement_list()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Switch_labelContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CASE(self):
            return self.getToken(CSharpParser.CASE, 0)

        def expression(self):
            return self.getTypedRuleContext(CSharpParser.ExpressionContext, 0)

        def COLON(self):
            return self.getToken(CSharpParser.COLON, 0)

        def case_guard(self):
            return self.getTypedRuleContext(CSharpParser.Case_guardContext, 0)

        def DEFAULT(self):
            return self.getToken(CSharpParser.DEFAULT, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_switch_label

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterSwitch_label"):
                listener.enterSwitch_label(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitSwitch_label"):
                listener.exitSwitch_label(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitSwitch_label"):
                return visitor.visitSwitch_label(self)
            else:
                return visitor.visitChildren(self)

    def switch_label(self):

        localctx = CSharpParser.Switch_labelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 188, self.RULE_switch_label)
        self._la = 0  # Token type
        try:
            self.state = 1492
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [CSharpParser.CASE]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1483
                self.match(CSharpParser.CASE)
                self.state = 1484
                self.expression()
                self.state = 1486
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == CSharpParser.WHEN:
                    self.state = 1485
                    self.case_guard()

                self.state = 1488
                self.match(CSharpParser.COLON)
                pass
            elif token in [CSharpParser.DEFAULT]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1490
                self.match(CSharpParser.DEFAULT)
                self.state = 1491
                self.match(CSharpParser.COLON)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Case_guardContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WHEN(self):
            return self.getToken(CSharpParser.WHEN, 0)

        def expression(self):
            return self.getTypedRuleContext(CSharpParser.ExpressionContext, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_case_guard

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterCase_guard"):
                listener.enterCase_guard(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitCase_guard"):
                listener.exitCase_guard(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitCase_guard"):
                return visitor.visitCase_guard(self)
            else:
                return visitor.visitChildren(self)

    def case_guard(self):

        localctx = CSharpParser.Case_guardContext(self, self._ctx, self.state)
        self.enterRule(localctx, 190, self.RULE_case_guard)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1494
            self.match(CSharpParser.WHEN)
            self.state = 1495
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Statement_listContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def statement(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(CSharpParser.StatementContext)
            else:
                return self.getTypedRuleContext(CSharpParser.StatementContext, i)

        def getRuleIndex(self):
            return CSharpParser.RULE_statement_list

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterStatement_list"):
                listener.enterStatement_list(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitStatement_list"):
                listener.exitStatement_list(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitStatement_list"):
                return visitor.visitStatement_list(self)
            else:
                return visitor.visitChildren(self)

    def statement_list(self):

        localctx = CSharpParser.Statement_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 192, self.RULE_statement_list)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1498
            self._errHandler.sync(self)
            _alt = 1
            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 1497
                    self.statement()

                else:
                    raise NoViableAltException(self)
                self.state = 1500
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 157, self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class For_initializerContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def local_variable_declaration(self):
            return self.getTypedRuleContext(CSharpParser.Local_variable_declarationContext, 0)

        def expression(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(CSharpParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(CSharpParser.ExpressionContext, i)

        def COMMA(self, i: int = None):
            if i is None:
                return self.getTokens(CSharpParser.COMMA)
            else:
                return self.getToken(CSharpParser.COMMA, i)

        def getRuleIndex(self):
            return CSharpParser.RULE_for_initializer

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterFor_initializer"):
                listener.enterFor_initializer(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitFor_initializer"):
                listener.exitFor_initializer(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitFor_initializer"):
                return visitor.visitFor_initializer(self)
            else:
                return visitor.visitChildren(self)

    def for_initializer(self):

        localctx = CSharpParser.For_initializerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 194, self.RULE_for_initializer)
        self._la = 0  # Token type
        try:
            self.state = 1511
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 159, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1502
                self.local_variable_declaration()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1503
                self.expression()
                self.state = 1508
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la == CSharpParser.COMMA:
                    self.state = 1504
                    self.match(CSharpParser.COMMA)
                    self.state = 1505
                    self.expression()
                    self.state = 1510
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class For_iteratorContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(CSharpParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(CSharpParser.ExpressionContext, i)

        def COMMA(self, i: int = None):
            if i is None:
                return self.getTokens(CSharpParser.COMMA)
            else:
                return self.getToken(CSharpParser.COMMA, i)

        def getRuleIndex(self):
            return CSharpParser.RULE_for_iterator

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterFor_iterator"):
                listener.enterFor_iterator(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitFor_iterator"):
                listener.exitFor_iterator(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitFor_iterator"):
                return visitor.visitFor_iterator(self)
            else:
                return visitor.visitChildren(self)

    def for_iterator(self):

        localctx = CSharpParser.For_iteratorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 196, self.RULE_for_iterator)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1513
            self.expression()
            self.state = 1518
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == CSharpParser.COMMA:
                self.state = 1514
                self.match(CSharpParser.COMMA)
                self.state = 1515
                self.expression()
                self.state = 1520
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Catch_clausesContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def specific_catch_clause(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(CSharpParser.Specific_catch_clauseContext)
            else:
                return self.getTypedRuleContext(CSharpParser.Specific_catch_clauseContext, i)

        def general_catch_clause(self):
            return self.getTypedRuleContext(CSharpParser.General_catch_clauseContext, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_catch_clauses

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterCatch_clauses"):
                listener.enterCatch_clauses(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitCatch_clauses"):
                listener.exitCatch_clauses(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitCatch_clauses"):
                return visitor.visitCatch_clauses(self)
            else:
                return visitor.visitChildren(self)

    def catch_clauses(self):

        localctx = CSharpParser.Catch_clausesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 198, self.RULE_catch_clauses)
        self._la = 0  # Token type
        try:
            self.state = 1532
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 163, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1521
                self.specific_catch_clause()
                self.state = 1525
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 161, self._ctx)
                while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 1522
                        self.specific_catch_clause()
                    self.state = 1527
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input, 161, self._ctx)

                self.state = 1529
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == CSharpParser.CATCH:
                    self.state = 1528
                    self.general_catch_clause()

                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1531
                self.general_catch_clause()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Specific_catch_clauseContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CATCH(self):
            return self.getToken(CSharpParser.CATCH, 0)

        def OPEN_PARENS(self):
            return self.getToken(CSharpParser.OPEN_PARENS, 0)

        def class_type(self):
            return self.getTypedRuleContext(CSharpParser.Class_typeContext, 0)

        def CLOSE_PARENS(self):
            return self.getToken(CSharpParser.CLOSE_PARENS, 0)

        def block(self):
            return self.getTypedRuleContext(CSharpParser.BlockContext, 0)

        def identifier(self):
            return self.getTypedRuleContext(CSharpParser.IdentifierContext, 0)

        def exception_filter(self):
            return self.getTypedRuleContext(CSharpParser.Exception_filterContext, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_specific_catch_clause

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterSpecific_catch_clause"):
                listener.enterSpecific_catch_clause(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitSpecific_catch_clause"):
                listener.exitSpecific_catch_clause(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitSpecific_catch_clause"):
                return visitor.visitSpecific_catch_clause(self)
            else:
                return visitor.visitChildren(self)

    def specific_catch_clause(self):

        localctx = CSharpParser.Specific_catch_clauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 200, self.RULE_specific_catch_clause)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1534
            self.match(CSharpParser.CATCH)
            self.state = 1535
            self.match(CSharpParser.OPEN_PARENS)
            self.state = 1536
            self.class_type()
            self.state = 1538
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & (
                    (1 << CSharpParser.ADD) | (1 << CSharpParser.ALIAS) | (1 << CSharpParser.ARGLIST) | (
                    1 << CSharpParser.ASCENDING) | (1 << CSharpParser.ASYNC) | (1 << CSharpParser.AWAIT) | (
                            1 << CSharpParser.BY) | (1 << CSharpParser.DESCENDING) | (1 << CSharpParser.DYNAMIC) | (
                            1 << CSharpParser.EQUALS) | (1 << CSharpParser.FROM) | (1 << CSharpParser.GET) | (
                            1 << CSharpParser.GROUP) | (1 << CSharpParser.INTO) | (1 << CSharpParser.JOIN) | (
                            1 << CSharpParser.LET))) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & (
                    (1 << (CSharpParser.NAMEOF - 64)) | (1 << (CSharpParser.ON - 64)) | (
                    1 << (CSharpParser.ORDERBY - 64)) | (1 << (CSharpParser.PARTIAL - 64)) | (
                            1 << (CSharpParser.REMOVE - 64)) | (1 << (CSharpParser.SELECT - 64)) | (
                            1 << (CSharpParser.SET - 64)) | (1 << (CSharpParser.UNMANAGED - 64)) | (
                            1 << (CSharpParser.VAR - 64)) | (1 << (CSharpParser.WHEN - 64)) | (
                            1 << (CSharpParser.WHERE - 64)) | (1 << (CSharpParser.YIELD - 64)) | (
                            1 << (CSharpParser.IDENTIFIER - 64)))) != 0):
                self.state = 1537
                self.identifier()

            self.state = 1540
            self.match(CSharpParser.CLOSE_PARENS)
            self.state = 1542
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == CSharpParser.WHEN:
                self.state = 1541
                self.exception_filter()

            self.state = 1544
            self.block()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class General_catch_clauseContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CATCH(self):
            return self.getToken(CSharpParser.CATCH, 0)

        def block(self):
            return self.getTypedRuleContext(CSharpParser.BlockContext, 0)

        def exception_filter(self):
            return self.getTypedRuleContext(CSharpParser.Exception_filterContext, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_general_catch_clause

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterGeneral_catch_clause"):
                listener.enterGeneral_catch_clause(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitGeneral_catch_clause"):
                listener.exitGeneral_catch_clause(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitGeneral_catch_clause"):
                return visitor.visitGeneral_catch_clause(self)
            else:
                return visitor.visitChildren(self)

    def general_catch_clause(self):

        localctx = CSharpParser.General_catch_clauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 202, self.RULE_general_catch_clause)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1546
            self.match(CSharpParser.CATCH)
            self.state = 1548
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == CSharpParser.WHEN:
                self.state = 1547
                self.exception_filter()

            self.state = 1550
            self.block()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Exception_filterContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WHEN(self):
            return self.getToken(CSharpParser.WHEN, 0)

        def OPEN_PARENS(self):
            return self.getToken(CSharpParser.OPEN_PARENS, 0)

        def expression(self):
            return self.getTypedRuleContext(CSharpParser.ExpressionContext, 0)

        def CLOSE_PARENS(self):
            return self.getToken(CSharpParser.CLOSE_PARENS, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_exception_filter

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterException_filter"):
                listener.enterException_filter(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitException_filter"):
                listener.exitException_filter(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitException_filter"):
                return visitor.visitException_filter(self)
            else:
                return visitor.visitChildren(self)

    def exception_filter(self):

        localctx = CSharpParser.Exception_filterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 204, self.RULE_exception_filter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1552
            self.match(CSharpParser.WHEN)
            self.state = 1553
            self.match(CSharpParser.OPEN_PARENS)
            self.state = 1554
            self.expression()
            self.state = 1555
            self.match(CSharpParser.CLOSE_PARENS)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Finally_clauseContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FINALLY(self):
            return self.getToken(CSharpParser.FINALLY, 0)

        def block(self):
            return self.getTypedRuleContext(CSharpParser.BlockContext, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_finally_clause

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterFinally_clause"):
                listener.enterFinally_clause(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitFinally_clause"):
                listener.exitFinally_clause(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitFinally_clause"):
                return visitor.visitFinally_clause(self)
            else:
                return visitor.visitChildren(self)

    def finally_clause(self):

        localctx = CSharpParser.Finally_clauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 206, self.RULE_finally_clause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1557
            self.match(CSharpParser.FINALLY)
            self.state = 1558
            self.block()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Resource_acquisitionContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def local_variable_declaration(self):
            return self.getTypedRuleContext(CSharpParser.Local_variable_declarationContext, 0)

        def expression(self):
            return self.getTypedRuleContext(CSharpParser.ExpressionContext, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_resource_acquisition

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterResource_acquisition"):
                listener.enterResource_acquisition(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitResource_acquisition"):
                listener.exitResource_acquisition(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitResource_acquisition"):
                return visitor.visitResource_acquisition(self)
            else:
                return visitor.visitChildren(self)

    def resource_acquisition(self):

        localctx = CSharpParser.Resource_acquisitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 208, self.RULE_resource_acquisition)
        try:
            self.state = 1562
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 167, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1560
                self.local_variable_declaration()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1561
                self.expression()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Namespace_declarationContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.qi = None  # Qualified_identifierContext

        def NAMESPACE(self):
            return self.getToken(CSharpParser.NAMESPACE, 0)

        def namespace_body(self):
            return self.getTypedRuleContext(CSharpParser.Namespace_bodyContext, 0)

        def qualified_identifier(self):
            return self.getTypedRuleContext(CSharpParser.Qualified_identifierContext, 0)

        def SEMICOLON(self):
            return self.getToken(CSharpParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_namespace_declaration

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterNamespace_declaration"):
                listener.enterNamespace_declaration(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitNamespace_declaration"):
                listener.exitNamespace_declaration(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitNamespace_declaration"):
                return visitor.visitNamespace_declaration(self)
            else:
                return visitor.visitChildren(self)

    def namespace_declaration(self):

        localctx = CSharpParser.Namespace_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 210, self.RULE_namespace_declaration)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1564
            self.match(CSharpParser.NAMESPACE)
            self.state = 1565
            localctx.qi = self.qualified_identifier()
            self.state = 1566
            self.namespace_body()
            self.state = 1568
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == CSharpParser.SEMICOLON:
                self.state = 1567
                self.match(CSharpParser.SEMICOLON)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Qualified_identifierContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(CSharpParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(CSharpParser.IdentifierContext, i)

        def DOT(self, i: int = None):
            if i is None:
                return self.getTokens(CSharpParser.DOT)
            else:
                return self.getToken(CSharpParser.DOT, i)

        def getRuleIndex(self):
            return CSharpParser.RULE_qualified_identifier

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterQualified_identifier"):
                listener.enterQualified_identifier(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitQualified_identifier"):
                listener.exitQualified_identifier(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitQualified_identifier"):
                return visitor.visitQualified_identifier(self)
            else:
                return visitor.visitChildren(self)

    def qualified_identifier(self):

        localctx = CSharpParser.Qualified_identifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 212, self.RULE_qualified_identifier)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1570
            self.identifier()
            self.state = 1575
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == CSharpParser.DOT:
                self.state = 1571
                self.match(CSharpParser.DOT)
                self.state = 1572
                self.identifier()
                self.state = 1577
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Namespace_bodyContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPEN_BRACE(self):
            return self.getToken(CSharpParser.OPEN_BRACE, 0)

        def CLOSE_BRACE(self):
            return self.getToken(CSharpParser.CLOSE_BRACE, 0)

        def extern_alias_directives(self):
            return self.getTypedRuleContext(CSharpParser.Extern_alias_directivesContext, 0)

        def using_directives(self):
            return self.getTypedRuleContext(CSharpParser.Using_directivesContext, 0)

        def namespace_member_declarations(self):
            return self.getTypedRuleContext(CSharpParser.Namespace_member_declarationsContext, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_namespace_body

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterNamespace_body"):
                listener.enterNamespace_body(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitNamespace_body"):
                listener.exitNamespace_body(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitNamespace_body"):
                return visitor.visitNamespace_body(self)
            else:
                return visitor.visitChildren(self)

    def namespace_body(self):

        localctx = CSharpParser.Namespace_bodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 214, self.RULE_namespace_body)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1578
            self.match(CSharpParser.OPEN_BRACE)
            self.state = 1580
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 170, self._ctx)
            if la_ == 1:
                self.state = 1579
                self.extern_alias_directives()

            self.state = 1583
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == CSharpParser.USING:
                self.state = 1582
                self.using_directives()

            self.state = 1586
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & (
                    (1 << CSharpParser.ABSTRACT) | (1 << CSharpParser.ASYNC) | (1 << CSharpParser.CLASS) | (
                    1 << CSharpParser.DELEGATE) | (1 << CSharpParser.ENUM) | (1 << CSharpParser.EXTERN) | (
                            1 << CSharpParser.INTERFACE) | (1 << CSharpParser.INTERNAL))) != 0) or (
                    (((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & (
                    (1 << (CSharpParser.NAMESPACE - 65)) | (1 << (CSharpParser.NEW - 65)) | (
                    1 << (CSharpParser.OVERRIDE - 65)) | (1 << (CSharpParser.PARTIAL - 65)) | (
                            1 << (CSharpParser.PRIVATE - 65)) | (1 << (CSharpParser.PROTECTED - 65)) | (
                            1 << (CSharpParser.PUBLIC - 65)) | (1 << (CSharpParser.READONLY - 65)) | (
                            1 << (CSharpParser.REF - 65)) | (1 << (CSharpParser.SEALED - 65)) | (
                            1 << (CSharpParser.STATIC - 65)) | (1 << (CSharpParser.STRUCT - 65)) | (
                            1 << (CSharpParser.UNSAFE - 65)) | (1 << (CSharpParser.VIRTUAL - 65)) | (
                            1 << (CSharpParser.VOLATILE - 65)) | (1 << (CSharpParser.OPEN_BRACKET - 65)))) != 0):
                self.state = 1585
                self.namespace_member_declarations()

            self.state = 1588
            self.match(CSharpParser.CLOSE_BRACE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Extern_alias_directivesContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def extern_alias_directive(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(CSharpParser.Extern_alias_directiveContext)
            else:
                return self.getTypedRuleContext(CSharpParser.Extern_alias_directiveContext, i)

        def getRuleIndex(self):
            return CSharpParser.RULE_extern_alias_directives

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterExtern_alias_directives"):
                listener.enterExtern_alias_directives(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitExtern_alias_directives"):
                listener.exitExtern_alias_directives(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitExtern_alias_directives"):
                return visitor.visitExtern_alias_directives(self)
            else:
                return visitor.visitChildren(self)

    def extern_alias_directives(self):

        localctx = CSharpParser.Extern_alias_directivesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 216, self.RULE_extern_alias_directives)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1591
            self._errHandler.sync(self)
            _alt = 1
            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 1590
                    self.extern_alias_directive()

                else:
                    raise NoViableAltException(self)
                self.state = 1593
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 173, self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Extern_alias_directiveContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EXTERN(self):
            return self.getToken(CSharpParser.EXTERN, 0)

        def ALIAS(self):
            return self.getToken(CSharpParser.ALIAS, 0)

        def identifier(self):
            return self.getTypedRuleContext(CSharpParser.IdentifierContext, 0)

        def SEMICOLON(self):
            return self.getToken(CSharpParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_extern_alias_directive

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterExtern_alias_directive"):
                listener.enterExtern_alias_directive(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitExtern_alias_directive"):
                listener.exitExtern_alias_directive(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitExtern_alias_directive"):
                return visitor.visitExtern_alias_directive(self)
            else:
                return visitor.visitChildren(self)

    def extern_alias_directive(self):

        localctx = CSharpParser.Extern_alias_directiveContext(self, self._ctx, self.state)
        self.enterRule(localctx, 218, self.RULE_extern_alias_directive)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1595
            self.match(CSharpParser.EXTERN)
            self.state = 1596
            self.match(CSharpParser.ALIAS)
            self.state = 1597
            self.identifier()
            self.state = 1598
            self.match(CSharpParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Using_directivesContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def using_directive(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(CSharpParser.Using_directiveContext)
            else:
                return self.getTypedRuleContext(CSharpParser.Using_directiveContext, i)

        def getRuleIndex(self):
            return CSharpParser.RULE_using_directives

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterUsing_directives"):
                listener.enterUsing_directives(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitUsing_directives"):
                listener.exitUsing_directives(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitUsing_directives"):
                return visitor.visitUsing_directives(self)
            else:
                return visitor.visitChildren(self)

    def using_directives(self):

        localctx = CSharpParser.Using_directivesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 220, self.RULE_using_directives)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1601
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 1600
                self.using_directive()
                self.state = 1603
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la == CSharpParser.USING):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Using_directiveContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def getRuleIndex(self):
            return CSharpParser.RULE_using_directive

        def copyFrom(self, ctx: ParserRuleContext):
            super().copyFrom(ctx)

    class UsingAliasDirectiveContext(Using_directiveContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a CSharpParser.Using_directiveContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def USING(self):
            return self.getToken(CSharpParser.USING, 0)

        def identifier(self):
            return self.getTypedRuleContext(CSharpParser.IdentifierContext, 0)

        def ASSIGNMENT(self):
            return self.getToken(CSharpParser.ASSIGNMENT, 0)

        def namespace_or_type_name(self):
            return self.getTypedRuleContext(CSharpParser.Namespace_or_type_nameContext, 0)

        def SEMICOLON(self):
            return self.getToken(CSharpParser.SEMICOLON, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterUsingAliasDirective"):
                listener.enterUsingAliasDirective(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitUsingAliasDirective"):
                listener.exitUsingAliasDirective(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitUsingAliasDirective"):
                return visitor.visitUsingAliasDirective(self)
            else:
                return visitor.visitChildren(self)

    class UsingNamespaceDirectiveContext(Using_directiveContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a CSharpParser.Using_directiveContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def USING(self):
            return self.getToken(CSharpParser.USING, 0)

        def namespace_or_type_name(self):
            return self.getTypedRuleContext(CSharpParser.Namespace_or_type_nameContext, 0)

        def SEMICOLON(self):
            return self.getToken(CSharpParser.SEMICOLON, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterUsingNamespaceDirective"):
                listener.enterUsingNamespaceDirective(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitUsingNamespaceDirective"):
                listener.exitUsingNamespaceDirective(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitUsingNamespaceDirective"):
                return visitor.visitUsingNamespaceDirective(self)
            else:
                return visitor.visitChildren(self)

    class UsingStaticDirectiveContext(Using_directiveContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a CSharpParser.Using_directiveContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def USING(self):
            return self.getToken(CSharpParser.USING, 0)

        def STATIC(self):
            return self.getToken(CSharpParser.STATIC, 0)

        def namespace_or_type_name(self):
            return self.getTypedRuleContext(CSharpParser.Namespace_or_type_nameContext, 0)

        def SEMICOLON(self):
            return self.getToken(CSharpParser.SEMICOLON, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterUsingStaticDirective"):
                listener.enterUsingStaticDirective(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitUsingStaticDirective"):
                listener.exitUsingStaticDirective(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitUsingStaticDirective"):
                return visitor.visitUsingStaticDirective(self)
            else:
                return visitor.visitChildren(self)

    def using_directive(self):

        localctx = CSharpParser.Using_directiveContext(self, self._ctx, self.state)
        self.enterRule(localctx, 222, self.RULE_using_directive)
        try:
            self.state = 1620
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 175, self._ctx)
            if la_ == 1:
                localctx = CSharpParser.UsingAliasDirectiveContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1605
                self.match(CSharpParser.USING)
                self.state = 1606
                self.identifier()
                self.state = 1607
                self.match(CSharpParser.ASSIGNMENT)
                self.state = 1608
                self.namespace_or_type_name()
                self.state = 1609
                self.match(CSharpParser.SEMICOLON)
                pass

            elif la_ == 2:
                localctx = CSharpParser.UsingNamespaceDirectiveContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1611
                self.match(CSharpParser.USING)
                self.state = 1612
                self.namespace_or_type_name()
                self.state = 1613
                self.match(CSharpParser.SEMICOLON)
                pass

            elif la_ == 3:
                localctx = CSharpParser.UsingStaticDirectiveContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 1615
                self.match(CSharpParser.USING)
                self.state = 1616
                self.match(CSharpParser.STATIC)
                self.state = 1617
                self.namespace_or_type_name()
                self.state = 1618
                self.match(CSharpParser.SEMICOLON)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Namespace_member_declarationsContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def namespace_member_declaration(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(CSharpParser.Namespace_member_declarationContext)
            else:
                return self.getTypedRuleContext(CSharpParser.Namespace_member_declarationContext, i)

        def getRuleIndex(self):
            return CSharpParser.RULE_namespace_member_declarations

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterNamespace_member_declarations"):
                listener.enterNamespace_member_declarations(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitNamespace_member_declarations"):
                listener.exitNamespace_member_declarations(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitNamespace_member_declarations"):
                return visitor.visitNamespace_member_declarations(self)
            else:
                return visitor.visitChildren(self)

    def namespace_member_declarations(self):

        localctx = CSharpParser.Namespace_member_declarationsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 224, self.RULE_namespace_member_declarations)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1623
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 1622
                self.namespace_member_declaration()
                self.state = 1625
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & (
                        (1 << CSharpParser.ABSTRACT) | (1 << CSharpParser.ASYNC) | (1 << CSharpParser.CLASS) | (
                        1 << CSharpParser.DELEGATE) | (1 << CSharpParser.ENUM) | (1 << CSharpParser.EXTERN) | (
                                1 << CSharpParser.INTERFACE) | (1 << CSharpParser.INTERNAL))) != 0) or (
                                (((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & (
                                (1 << (CSharpParser.NAMESPACE - 65)) | (1 << (CSharpParser.NEW - 65)) | (
                                1 << (CSharpParser.OVERRIDE - 65)) | (1 << (CSharpParser.PARTIAL - 65)) | (
                                        1 << (CSharpParser.PRIVATE - 65)) | (1 << (CSharpParser.PROTECTED - 65)) | (
                                        1 << (CSharpParser.PUBLIC - 65)) | (1 << (CSharpParser.READONLY - 65)) | (
                                        1 << (CSharpParser.REF - 65)) | (1 << (CSharpParser.SEALED - 65)) | (
                                        1 << (CSharpParser.STATIC - 65)) | (1 << (CSharpParser.STRUCT - 65)) | (
                                        1 << (CSharpParser.UNSAFE - 65)) | (1 << (CSharpParser.VIRTUAL - 65)) | (
                                        1 << (CSharpParser.VOLATILE - 65)) | (
                                        1 << (CSharpParser.OPEN_BRACKET - 65)))) != 0)):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Namespace_member_declarationContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def namespace_declaration(self):
            return self.getTypedRuleContext(CSharpParser.Namespace_declarationContext, 0)

        def type_declaration(self):
            return self.getTypedRuleContext(CSharpParser.Type_declarationContext, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_namespace_member_declaration

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterNamespace_member_declaration"):
                listener.enterNamespace_member_declaration(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitNamespace_member_declaration"):
                listener.exitNamespace_member_declaration(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitNamespace_member_declaration"):
                return visitor.visitNamespace_member_declaration(self)
            else:
                return visitor.visitChildren(self)

    def namespace_member_declaration(self):

        localctx = CSharpParser.Namespace_member_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 226, self.RULE_namespace_member_declaration)
        try:
            self.state = 1629
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [CSharpParser.NAMESPACE]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1627
                self.namespace_declaration()
                pass
            elif token in [CSharpParser.ABSTRACT, CSharpParser.ASYNC, CSharpParser.CLASS, CSharpParser.DELEGATE,
                           CSharpParser.ENUM, CSharpParser.EXTERN, CSharpParser.INTERFACE, CSharpParser.INTERNAL,
                           CSharpParser.NEW, CSharpParser.OVERRIDE, CSharpParser.PARTIAL, CSharpParser.PRIVATE,
                           CSharpParser.PROTECTED, CSharpParser.PUBLIC, CSharpParser.READONLY, CSharpParser.REF,
                           CSharpParser.SEALED, CSharpParser.STATIC, CSharpParser.STRUCT, CSharpParser.UNSAFE,
                           CSharpParser.VIRTUAL, CSharpParser.VOLATILE, CSharpParser.OPEN_BRACKET]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1628
                self.type_declaration()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Type_declarationContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def class_definition(self):
            return self.getTypedRuleContext(CSharpParser.Class_definitionContext, 0)

        def struct_definition(self):
            return self.getTypedRuleContext(CSharpParser.Struct_definitionContext, 0)

        def interface_definition(self):
            return self.getTypedRuleContext(CSharpParser.Interface_definitionContext, 0)

        def enum_definition(self):
            return self.getTypedRuleContext(CSharpParser.Enum_definitionContext, 0)

        def delegate_definition(self):
            return self.getTypedRuleContext(CSharpParser.Delegate_definitionContext, 0)

        def attributes(self):
            return self.getTypedRuleContext(CSharpParser.AttributesContext, 0)

        def all_member_modifiers(self):
            return self.getTypedRuleContext(CSharpParser.All_member_modifiersContext, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_type_declaration

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterType_declaration"):
                listener.enterType_declaration(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitType_declaration"):
                listener.exitType_declaration(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitType_declaration"):
                return visitor.visitType_declaration(self)
            else:
                return visitor.visitChildren(self)

    def type_declaration(self):

        localctx = CSharpParser.Type_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 228, self.RULE_type_declaration)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1632
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == CSharpParser.OPEN_BRACKET:
                self.state = 1631
                self.attributes()

            self.state = 1635
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 179, self._ctx)
            if la_ == 1:
                self.state = 1634
                self.all_member_modifiers()

            self.state = 1642
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [CSharpParser.CLASS]:
                self.state = 1637
                self.class_definition()
                pass
            elif token in [CSharpParser.READONLY, CSharpParser.REF, CSharpParser.STRUCT]:
                self.state = 1638
                self.struct_definition()
                pass
            elif token in [CSharpParser.INTERFACE]:
                self.state = 1639
                self.interface_definition()
                pass
            elif token in [CSharpParser.ENUM]:
                self.state = 1640
                self.enum_definition()
                pass
            elif token in [CSharpParser.DELEGATE]:
                self.state = 1641
                self.delegate_definition()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Qualified_alias_memberContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(CSharpParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(CSharpParser.IdentifierContext, i)

        def DOUBLE_COLON(self):
            return self.getToken(CSharpParser.DOUBLE_COLON, 0)

        def type_argument_list(self):
            return self.getTypedRuleContext(CSharpParser.Type_argument_listContext, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_qualified_alias_member

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterQualified_alias_member"):
                listener.enterQualified_alias_member(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitQualified_alias_member"):
                listener.exitQualified_alias_member(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitQualified_alias_member"):
                return visitor.visitQualified_alias_member(self)
            else:
                return visitor.visitChildren(self)

    def qualified_alias_member(self):

        localctx = CSharpParser.Qualified_alias_memberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 230, self.RULE_qualified_alias_member)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1644
            self.identifier()
            self.state = 1645
            self.match(CSharpParser.DOUBLE_COLON)
            self.state = 1646
            self.identifier()
            self.state = 1648
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 181, self._ctx)
            if la_ == 1:
                self.state = 1647
                self.type_argument_list()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Type_parameter_listContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LT(self):
            return self.getToken(CSharpParser.LT, 0)

        def type_parameter(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(CSharpParser.Type_parameterContext)
            else:
                return self.getTypedRuleContext(CSharpParser.Type_parameterContext, i)

        def GT(self):
            return self.getToken(CSharpParser.GT, 0)

        def COMMA(self, i: int = None):
            if i is None:
                return self.getTokens(CSharpParser.COMMA)
            else:
                return self.getToken(CSharpParser.COMMA, i)

        def getRuleIndex(self):
            return CSharpParser.RULE_type_parameter_list

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterType_parameter_list"):
                listener.enterType_parameter_list(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitType_parameter_list"):
                listener.exitType_parameter_list(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitType_parameter_list"):
                return visitor.visitType_parameter_list(self)
            else:
                return visitor.visitChildren(self)

    def type_parameter_list(self):

        localctx = CSharpParser.Type_parameter_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 232, self.RULE_type_parameter_list)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1650
            self.match(CSharpParser.LT)
            self.state = 1651
            self.type_parameter()
            self.state = 1656
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == CSharpParser.COMMA:
                self.state = 1652
                self.match(CSharpParser.COMMA)
                self.state = 1653
                self.type_parameter()
                self.state = 1658
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1659
            self.match(CSharpParser.GT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Type_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(CSharpParser.IdentifierContext, 0)

        def attributes(self):
            return self.getTypedRuleContext(CSharpParser.AttributesContext, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_type_parameter

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterType_parameter"):
                listener.enterType_parameter(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitType_parameter"):
                listener.exitType_parameter(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitType_parameter"):
                return visitor.visitType_parameter(self)
            else:
                return visitor.visitChildren(self)

    def type_parameter(self):

        localctx = CSharpParser.Type_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 234, self.RULE_type_parameter)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1662
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == CSharpParser.OPEN_BRACKET:
                self.state = 1661
                self.attributes()

            self.state = 1664
            self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Class_baseContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COLON(self):
            return self.getToken(CSharpParser.COLON, 0)

        def class_type(self):
            return self.getTypedRuleContext(CSharpParser.Class_typeContext, 0)

        def COMMA(self, i: int = None):
            if i is None:
                return self.getTokens(CSharpParser.COMMA)
            else:
                return self.getToken(CSharpParser.COMMA, i)

        def namespace_or_type_name(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(CSharpParser.Namespace_or_type_nameContext)
            else:
                return self.getTypedRuleContext(CSharpParser.Namespace_or_type_nameContext, i)

        def getRuleIndex(self):
            return CSharpParser.RULE_class_base

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterClass_base"):
                listener.enterClass_base(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitClass_base"):
                listener.exitClass_base(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitClass_base"):
                return visitor.visitClass_base(self)
            else:
                return visitor.visitChildren(self)

    def class_base(self):

        localctx = CSharpParser.Class_baseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 236, self.RULE_class_base)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1666
            self.match(CSharpParser.COLON)
            self.state = 1667
            self.class_type()
            self.state = 1672
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == CSharpParser.COMMA:
                self.state = 1668
                self.match(CSharpParser.COMMA)
                self.state = 1669
                self.namespace_or_type_name()
                self.state = 1674
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Interface_type_listContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def namespace_or_type_name(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(CSharpParser.Namespace_or_type_nameContext)
            else:
                return self.getTypedRuleContext(CSharpParser.Namespace_or_type_nameContext, i)

        def COMMA(self, i: int = None):
            if i is None:
                return self.getTokens(CSharpParser.COMMA)
            else:
                return self.getToken(CSharpParser.COMMA, i)

        def getRuleIndex(self):
            return CSharpParser.RULE_interface_type_list

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterInterface_type_list"):
                listener.enterInterface_type_list(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitInterface_type_list"):
                listener.exitInterface_type_list(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitInterface_type_list"):
                return visitor.visitInterface_type_list(self)
            else:
                return visitor.visitChildren(self)

    def interface_type_list(self):

        localctx = CSharpParser.Interface_type_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 238, self.RULE_interface_type_list)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1675
            self.namespace_or_type_name()
            self.state = 1680
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == CSharpParser.COMMA:
                self.state = 1676
                self.match(CSharpParser.COMMA)
                self.state = 1677
                self.namespace_or_type_name()
                self.state = 1682
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Type_parameter_constraints_clausesContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def type_parameter_constraints_clause(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(CSharpParser.Type_parameter_constraints_clauseContext)
            else:
                return self.getTypedRuleContext(CSharpParser.Type_parameter_constraints_clauseContext, i)

        def getRuleIndex(self):
            return CSharpParser.RULE_type_parameter_constraints_clauses

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterType_parameter_constraints_clauses"):
                listener.enterType_parameter_constraints_clauses(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitType_parameter_constraints_clauses"):
                listener.exitType_parameter_constraints_clauses(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitType_parameter_constraints_clauses"):
                return visitor.visitType_parameter_constraints_clauses(self)
            else:
                return visitor.visitChildren(self)

    def type_parameter_constraints_clauses(self):

        localctx = CSharpParser.Type_parameter_constraints_clausesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 240, self.RULE_type_parameter_constraints_clauses)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1684
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 1683
                self.type_parameter_constraints_clause()
                self.state = 1686
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la == CSharpParser.WHERE):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Type_parameter_constraints_clauseContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WHERE(self):
            return self.getToken(CSharpParser.WHERE, 0)

        def identifier(self):
            return self.getTypedRuleContext(CSharpParser.IdentifierContext, 0)

        def COLON(self):
            return self.getToken(CSharpParser.COLON, 0)

        def type_parameter_constraints(self):
            return self.getTypedRuleContext(CSharpParser.Type_parameter_constraintsContext, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_type_parameter_constraints_clause

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterType_parameter_constraints_clause"):
                listener.enterType_parameter_constraints_clause(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitType_parameter_constraints_clause"):
                listener.exitType_parameter_constraints_clause(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitType_parameter_constraints_clause"):
                return visitor.visitType_parameter_constraints_clause(self)
            else:
                return visitor.visitChildren(self)

    def type_parameter_constraints_clause(self):

        localctx = CSharpParser.Type_parameter_constraints_clauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 242, self.RULE_type_parameter_constraints_clause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1688
            self.match(CSharpParser.WHERE)
            self.state = 1689
            self.identifier()
            self.state = 1690
            self.match(CSharpParser.COLON)
            self.state = 1691
            self.type_parameter_constraints()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Type_parameter_constraintsContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def constructor_constraint(self):
            return self.getTypedRuleContext(CSharpParser.Constructor_constraintContext, 0)

        def primary_constraint(self):
            return self.getTypedRuleContext(CSharpParser.Primary_constraintContext, 0)

        def COMMA(self, i: int = None):
            if i is None:
                return self.getTokens(CSharpParser.COMMA)
            else:
                return self.getToken(CSharpParser.COMMA, i)

        def secondary_constraints(self):
            return self.getTypedRuleContext(CSharpParser.Secondary_constraintsContext, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_type_parameter_constraints

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterType_parameter_constraints"):
                listener.enterType_parameter_constraints(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitType_parameter_constraints"):
                listener.exitType_parameter_constraints(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitType_parameter_constraints"):
                return visitor.visitType_parameter_constraints(self)
            else:
                return visitor.visitChildren(self)

    def type_parameter_constraints(self):

        localctx = CSharpParser.Type_parameter_constraintsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 244, self.RULE_type_parameter_constraints)
        self._la = 0  # Token type
        try:
            self.state = 1703
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [CSharpParser.NEW]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1693
                self.constructor_constraint()
                pass
            elif token in [CSharpParser.ADD, CSharpParser.ALIAS, CSharpParser.ARGLIST, CSharpParser.ASCENDING,
                           CSharpParser.ASYNC, CSharpParser.AWAIT, CSharpParser.BY, CSharpParser.CLASS,
                           CSharpParser.DESCENDING, CSharpParser.DYNAMIC, CSharpParser.EQUALS, CSharpParser.FROM,
                           CSharpParser.GET, CSharpParser.GROUP, CSharpParser.INTO, CSharpParser.JOIN, CSharpParser.LET,
                           CSharpParser.NAMEOF, CSharpParser.OBJECT, CSharpParser.ON, CSharpParser.ORDERBY,
                           CSharpParser.PARTIAL, CSharpParser.REMOVE, CSharpParser.SELECT, CSharpParser.SET,
                           CSharpParser.STRING, CSharpParser.STRUCT, CSharpParser.UNMANAGED, CSharpParser.VAR,
                           CSharpParser.WHEN, CSharpParser.WHERE, CSharpParser.YIELD, CSharpParser.IDENTIFIER]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1694
                self.primary_constraint()
                self.state = 1697
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input, 187, self._ctx)
                if la_ == 1:
                    self.state = 1695
                    self.match(CSharpParser.COMMA)
                    self.state = 1696
                    self.secondary_constraints()

                self.state = 1701
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == CSharpParser.COMMA:
                    self.state = 1699
                    self.match(CSharpParser.COMMA)
                    self.state = 1700
                    self.constructor_constraint()

                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Primary_constraintContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def class_type(self):
            return self.getTypedRuleContext(CSharpParser.Class_typeContext, 0)

        def CLASS(self):
            return self.getToken(CSharpParser.CLASS, 0)

        def INTERR(self):
            return self.getToken(CSharpParser.INTERR, 0)

        def STRUCT(self):
            return self.getToken(CSharpParser.STRUCT, 0)

        def UNMANAGED(self):
            return self.getToken(CSharpParser.UNMANAGED, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_primary_constraint

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterPrimary_constraint"):
                listener.enterPrimary_constraint(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitPrimary_constraint"):
                listener.exitPrimary_constraint(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitPrimary_constraint"):
                return visitor.visitPrimary_constraint(self)
            else:
                return visitor.visitChildren(self)

    def primary_constraint(self):

        localctx = CSharpParser.Primary_constraintContext(self, self._ctx, self.state)
        self.enterRule(localctx, 246, self.RULE_primary_constraint)
        self._la = 0  # Token type
        try:
            self.state = 1712
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 191, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1705
                self.class_type()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1706
                self.match(CSharpParser.CLASS)
                self.state = 1708
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == CSharpParser.INTERR:
                    self.state = 1707
                    self.match(CSharpParser.INTERR)

                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1710
                self.match(CSharpParser.STRUCT)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1711
                self.match(CSharpParser.UNMANAGED)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Secondary_constraintsContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def namespace_or_type_name(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(CSharpParser.Namespace_or_type_nameContext)
            else:
                return self.getTypedRuleContext(CSharpParser.Namespace_or_type_nameContext, i)

        def COMMA(self, i: int = None):
            if i is None:
                return self.getTokens(CSharpParser.COMMA)
            else:
                return self.getToken(CSharpParser.COMMA, i)

        def getRuleIndex(self):
            return CSharpParser.RULE_secondary_constraints

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterSecondary_constraints"):
                listener.enterSecondary_constraints(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitSecondary_constraints"):
                listener.exitSecondary_constraints(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitSecondary_constraints"):
                return visitor.visitSecondary_constraints(self)
            else:
                return visitor.visitChildren(self)

    def secondary_constraints(self):

        localctx = CSharpParser.Secondary_constraintsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 248, self.RULE_secondary_constraints)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1714
            self.namespace_or_type_name()
            self.state = 1719
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input, 192, self._ctx)
            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 1715
                    self.match(CSharpParser.COMMA)
                    self.state = 1716
                    self.namespace_or_type_name()
                self.state = 1721
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 192, self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Constructor_constraintContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NEW(self):
            return self.getToken(CSharpParser.NEW, 0)

        def OPEN_PARENS(self):
            return self.getToken(CSharpParser.OPEN_PARENS, 0)

        def CLOSE_PARENS(self):
            return self.getToken(CSharpParser.CLOSE_PARENS, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_constructor_constraint

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterConstructor_constraint"):
                listener.enterConstructor_constraint(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitConstructor_constraint"):
                listener.exitConstructor_constraint(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitConstructor_constraint"):
                return visitor.visitConstructor_constraint(self)
            else:
                return visitor.visitChildren(self)

    def constructor_constraint(self):

        localctx = CSharpParser.Constructor_constraintContext(self, self._ctx, self.state)
        self.enterRule(localctx, 250, self.RULE_constructor_constraint)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1722
            self.match(CSharpParser.NEW)
            self.state = 1723
            self.match(CSharpParser.OPEN_PARENS)
            self.state = 1724
            self.match(CSharpParser.CLOSE_PARENS)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Class_bodyContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPEN_BRACE(self):
            return self.getToken(CSharpParser.OPEN_BRACE, 0)

        def CLOSE_BRACE(self):
            return self.getToken(CSharpParser.CLOSE_BRACE, 0)

        def class_member_declarations(self):
            return self.getTypedRuleContext(CSharpParser.Class_member_declarationsContext, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_class_body

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterClass_body"):
                listener.enterClass_body(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitClass_body"):
                listener.exitClass_body(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitClass_body"):
                return visitor.visitClass_body(self)
            else:
                return visitor.visitChildren(self)

    def class_body(self):

        localctx = CSharpParser.Class_bodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 252, self.RULE_class_body)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1726
            self.match(CSharpParser.OPEN_BRACE)
            self.state = 1728
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & (
                    (1 << CSharpParser.ABSTRACT) | (1 << CSharpParser.ADD) | (1 << CSharpParser.ALIAS) | (
                    1 << CSharpParser.ARGLIST) | (1 << CSharpParser.ASCENDING) | (1 << CSharpParser.ASYNC) | (
                            1 << CSharpParser.AWAIT) | (1 << CSharpParser.BOOL) | (1 << CSharpParser.BY) | (
                            1 << CSharpParser.BYTE) | (1 << CSharpParser.CHAR) | (1 << CSharpParser.CLASS) | (
                            1 << CSharpParser.CONST) | (1 << CSharpParser.DECIMAL) | (1 << CSharpParser.DELEGATE) | (
                            1 << CSharpParser.DESCENDING) | (1 << CSharpParser.DOUBLE) | (1 << CSharpParser.DYNAMIC) | (
                            1 << CSharpParser.ENUM) | (1 << CSharpParser.EQUALS) | (1 << CSharpParser.EVENT) | (
                            1 << CSharpParser.EXPLICIT) | (1 << CSharpParser.EXTERN) | (1 << CSharpParser.FLOAT) | (
                            1 << CSharpParser.FROM) | (1 << CSharpParser.GET) | (1 << CSharpParser.GROUP) | (
                            1 << CSharpParser.IMPLICIT) | (1 << CSharpParser.INT) | (1 << CSharpParser.INTERFACE) | (
                            1 << CSharpParser.INTERNAL) | (1 << CSharpParser.INTO) | (1 << CSharpParser.JOIN) | (
                            1 << CSharpParser.LET) | (1 << CSharpParser.LONG))) != 0) or (
                    (((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & (
                    (1 << (CSharpParser.NAMEOF - 64)) | (1 << (CSharpParser.NEW - 64)) | (
                    1 << (CSharpParser.OBJECT - 64)) | (1 << (CSharpParser.ON - 64)) | (
                            1 << (CSharpParser.ORDERBY - 64)) | (1 << (CSharpParser.OVERRIDE - 64)) | (
                            1 << (CSharpParser.PARTIAL - 64)) | (1 << (CSharpParser.PRIVATE - 64)) | (
                            1 << (CSharpParser.PROTECTED - 64)) | (1 << (CSharpParser.PUBLIC - 64)) | (
                            1 << (CSharpParser.READONLY - 64)) | (1 << (CSharpParser.REF - 64)) | (
                            1 << (CSharpParser.REMOVE - 64)) | (1 << (CSharpParser.SBYTE - 64)) | (
                            1 << (CSharpParser.SEALED - 64)) | (1 << (CSharpParser.SELECT - 64)) | (
                            1 << (CSharpParser.SET - 64)) | (1 << (CSharpParser.SHORT - 64)) | (
                            1 << (CSharpParser.STATIC - 64)) | (1 << (CSharpParser.STRING - 64)) | (
                            1 << (CSharpParser.STRUCT - 64)) | (1 << (CSharpParser.UINT - 64)) | (
                            1 << (CSharpParser.ULONG - 64)) | (1 << (CSharpParser.UNMANAGED - 64)) | (
                            1 << (CSharpParser.UNSAFE - 64)) | (1 << (CSharpParser.USHORT - 64)) | (
                            1 << (CSharpParser.VAR - 64)) | (1 << (CSharpParser.VIRTUAL - 64)) | (
                            1 << (CSharpParser.VOID - 64)) | (1 << (CSharpParser.VOLATILE - 64)) | (
                            1 << (CSharpParser.WHEN - 64)) | (1 << (CSharpParser.WHERE - 64)) | (
                            1 << (CSharpParser.YIELD - 64)) | (1 << (CSharpParser.IDENTIFIER - 64)) | (1 << (
                    CSharpParser.OPEN_BRACKET - 64)))) != 0) or _la == CSharpParser.OPEN_PARENS or _la == CSharpParser.TILDE:
                self.state = 1727
                self.class_member_declarations()

            self.state = 1730
            self.match(CSharpParser.CLOSE_BRACE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Class_member_declarationsContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def class_member_declaration(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(CSharpParser.Class_member_declarationContext)
            else:
                return self.getTypedRuleContext(CSharpParser.Class_member_declarationContext, i)

        def getRuleIndex(self):
            return CSharpParser.RULE_class_member_declarations

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterClass_member_declarations"):
                listener.enterClass_member_declarations(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitClass_member_declarations"):
                listener.exitClass_member_declarations(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitClass_member_declarations"):
                return visitor.visitClass_member_declarations(self)
            else:
                return visitor.visitChildren(self)

    def class_member_declarations(self):

        localctx = CSharpParser.Class_member_declarationsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 254, self.RULE_class_member_declarations)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1733
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 1732
                self.class_member_declaration()
                self.state = 1735
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & (
                        (1 << CSharpParser.ABSTRACT) | (1 << CSharpParser.ADD) | (1 << CSharpParser.ALIAS) | (
                        1 << CSharpParser.ARGLIST) | (1 << CSharpParser.ASCENDING) | (1 << CSharpParser.ASYNC) | (
                                1 << CSharpParser.AWAIT) | (1 << CSharpParser.BOOL) | (1 << CSharpParser.BY) | (
                                1 << CSharpParser.BYTE) | (1 << CSharpParser.CHAR) | (1 << CSharpParser.CLASS) | (
                                1 << CSharpParser.CONST) | (1 << CSharpParser.DECIMAL) | (
                                1 << CSharpParser.DELEGATE) | (1 << CSharpParser.DESCENDING) | (
                                1 << CSharpParser.DOUBLE) | (1 << CSharpParser.DYNAMIC) | (1 << CSharpParser.ENUM) | (
                                1 << CSharpParser.EQUALS) | (1 << CSharpParser.EVENT) | (1 << CSharpParser.EXPLICIT) | (
                                1 << CSharpParser.EXTERN) | (1 << CSharpParser.FLOAT) | (1 << CSharpParser.FROM) | (
                                1 << CSharpParser.GET) | (1 << CSharpParser.GROUP) | (1 << CSharpParser.IMPLICIT) | (
                                1 << CSharpParser.INT) | (1 << CSharpParser.INTERFACE) | (
                                1 << CSharpParser.INTERNAL) | (1 << CSharpParser.INTO) | (1 << CSharpParser.JOIN) | (
                                1 << CSharpParser.LET) | (1 << CSharpParser.LONG))) != 0) or (
                                (((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & (
                                (1 << (CSharpParser.NAMEOF - 64)) | (1 << (CSharpParser.NEW - 64)) | (
                                1 << (CSharpParser.OBJECT - 64)) | (1 << (CSharpParser.ON - 64)) | (
                                        1 << (CSharpParser.ORDERBY - 64)) | (1 << (CSharpParser.OVERRIDE - 64)) | (
                                        1 << (CSharpParser.PARTIAL - 64)) | (1 << (CSharpParser.PRIVATE - 64)) | (
                                        1 << (CSharpParser.PROTECTED - 64)) | (1 << (CSharpParser.PUBLIC - 64)) | (
                                        1 << (CSharpParser.READONLY - 64)) | (1 << (CSharpParser.REF - 64)) | (
                                        1 << (CSharpParser.REMOVE - 64)) | (1 << (CSharpParser.SBYTE - 64)) | (
                                        1 << (CSharpParser.SEALED - 64)) | (1 << (CSharpParser.SELECT - 64)) | (
                                        1 << (CSharpParser.SET - 64)) | (1 << (CSharpParser.SHORT - 64)) | (
                                        1 << (CSharpParser.STATIC - 64)) | (1 << (CSharpParser.STRING - 64)) | (
                                        1 << (CSharpParser.STRUCT - 64)) | (1 << (CSharpParser.UINT - 64)) | (
                                        1 << (CSharpParser.ULONG - 64)) | (1 << (CSharpParser.UNMANAGED - 64)) | (
                                        1 << (CSharpParser.UNSAFE - 64)) | (1 << (CSharpParser.USHORT - 64)) | (
                                        1 << (CSharpParser.VAR - 64)) | (1 << (CSharpParser.VIRTUAL - 64)) | (
                                        1 << (CSharpParser.VOID - 64)) | (1 << (CSharpParser.VOLATILE - 64)) | (
                                        1 << (CSharpParser.WHEN - 64)) | (1 << (CSharpParser.WHERE - 64)) | (
                                        1 << (CSharpParser.YIELD - 64)) | (1 << (CSharpParser.IDENTIFIER - 64)) | (
                                        1 << (
                                        CSharpParser.OPEN_BRACKET - 64)))) != 0) or _la == CSharpParser.OPEN_PARENS or _la == CSharpParser.TILDE):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Class_member_declarationContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def common_member_declaration(self):
            return self.getTypedRuleContext(CSharpParser.Common_member_declarationContext, 0)

        def destructor_definition(self):
            return self.getTypedRuleContext(CSharpParser.Destructor_definitionContext, 0)

        def attributes(self):
            return self.getTypedRuleContext(CSharpParser.AttributesContext, 0)

        def all_member_modifiers(self):
            return self.getTypedRuleContext(CSharpParser.All_member_modifiersContext, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_class_member_declaration

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterClass_member_declaration"):
                listener.enterClass_member_declaration(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitClass_member_declaration"):
                listener.exitClass_member_declaration(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitClass_member_declaration"):
                return visitor.visitClass_member_declaration(self)
            else:
                return visitor.visitChildren(self)

    def class_member_declaration(self):

        localctx = CSharpParser.Class_member_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 256, self.RULE_class_member_declaration)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1738
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == CSharpParser.OPEN_BRACKET:
                self.state = 1737
                self.attributes()

            self.state = 1741
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 196, self._ctx)
            if la_ == 1:
                self.state = 1740
                self.all_member_modifiers()

            self.state = 1745
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [CSharpParser.ADD, CSharpParser.ALIAS, CSharpParser.ARGLIST, CSharpParser.ASCENDING,
                         CSharpParser.ASYNC, CSharpParser.AWAIT, CSharpParser.BOOL, CSharpParser.BY, CSharpParser.BYTE,
                         CSharpParser.CHAR, CSharpParser.CLASS, CSharpParser.CONST, CSharpParser.DECIMAL,
                         CSharpParser.DELEGATE, CSharpParser.DESCENDING, CSharpParser.DOUBLE, CSharpParser.DYNAMIC,
                         CSharpParser.ENUM, CSharpParser.EQUALS, CSharpParser.EVENT, CSharpParser.EXPLICIT,
                         CSharpParser.FLOAT, CSharpParser.FROM, CSharpParser.GET, CSharpParser.GROUP,
                         CSharpParser.IMPLICIT, CSharpParser.INT, CSharpParser.INTERFACE, CSharpParser.INTO,
                         CSharpParser.JOIN, CSharpParser.LET, CSharpParser.LONG, CSharpParser.NAMEOF,
                         CSharpParser.OBJECT, CSharpParser.ON, CSharpParser.ORDERBY, CSharpParser.PARTIAL,
                         CSharpParser.READONLY, CSharpParser.REF, CSharpParser.REMOVE, CSharpParser.SBYTE,
                         CSharpParser.SELECT, CSharpParser.SET, CSharpParser.SHORT, CSharpParser.STRING,
                         CSharpParser.STRUCT, CSharpParser.UINT, CSharpParser.ULONG, CSharpParser.UNMANAGED,
                         CSharpParser.USHORT, CSharpParser.VAR, CSharpParser.VOID, CSharpParser.WHEN,
                         CSharpParser.WHERE, CSharpParser.YIELD, CSharpParser.IDENTIFIER, CSharpParser.OPEN_PARENS]:
                self.state = 1743
                self.common_member_declaration()
                pass
            elif token in [CSharpParser.TILDE]:
                self.state = 1744
                self.destructor_definition()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class All_member_modifiersContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def all_member_modifier(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(CSharpParser.All_member_modifierContext)
            else:
                return self.getTypedRuleContext(CSharpParser.All_member_modifierContext, i)

        def getRuleIndex(self):
            return CSharpParser.RULE_all_member_modifiers

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterAll_member_modifiers"):
                listener.enterAll_member_modifiers(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitAll_member_modifiers"):
                listener.exitAll_member_modifiers(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitAll_member_modifiers"):
                return visitor.visitAll_member_modifiers(self)
            else:
                return visitor.visitChildren(self)

    def all_member_modifiers(self):

        localctx = CSharpParser.All_member_modifiersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 258, self.RULE_all_member_modifiers)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1748
            self._errHandler.sync(self)
            _alt = 1
            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 1747
                    self.all_member_modifier()

                else:
                    raise NoViableAltException(self)
                self.state = 1750
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 198, self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class All_member_modifierContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NEW(self):
            return self.getToken(CSharpParser.NEW, 0)

        def PUBLIC(self):
            return self.getToken(CSharpParser.PUBLIC, 0)

        def PROTECTED(self):
            return self.getToken(CSharpParser.PROTECTED, 0)

        def INTERNAL(self):
            return self.getToken(CSharpParser.INTERNAL, 0)

        def PRIVATE(self):
            return self.getToken(CSharpParser.PRIVATE, 0)

        def READONLY(self):
            return self.getToken(CSharpParser.READONLY, 0)

        def VOLATILE(self):
            return self.getToken(CSharpParser.VOLATILE, 0)

        def VIRTUAL(self):
            return self.getToken(CSharpParser.VIRTUAL, 0)

        def SEALED(self):
            return self.getToken(CSharpParser.SEALED, 0)

        def OVERRIDE(self):
            return self.getToken(CSharpParser.OVERRIDE, 0)

        def ABSTRACT(self):
            return self.getToken(CSharpParser.ABSTRACT, 0)

        def STATIC(self):
            return self.getToken(CSharpParser.STATIC, 0)

        def UNSAFE(self):
            return self.getToken(CSharpParser.UNSAFE, 0)

        def EXTERN(self):
            return self.getToken(CSharpParser.EXTERN, 0)

        def PARTIAL(self):
            return self.getToken(CSharpParser.PARTIAL, 0)

        def ASYNC(self):
            return self.getToken(CSharpParser.ASYNC, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_all_member_modifier

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterAll_member_modifier"):
                listener.enterAll_member_modifier(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitAll_member_modifier"):
                listener.exitAll_member_modifier(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitAll_member_modifier"):
                return visitor.visitAll_member_modifier(self)
            else:
                return visitor.visitChildren(self)

    def all_member_modifier(self):

        localctx = CSharpParser.All_member_modifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 260, self.RULE_all_member_modifier)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1752
            _la = self._input.LA(1)
            if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & (
                    (1 << CSharpParser.ABSTRACT) | (1 << CSharpParser.ASYNC) | (1 << CSharpParser.EXTERN) | (
                    1 << CSharpParser.INTERNAL))) != 0) or ((((_la - 66)) & ~0x3f) == 0 and ((1 << (_la - 66)) & (
                    (1 << (CSharpParser.NEW - 66)) | (1 << (CSharpParser.OVERRIDE - 66)) | (
                    1 << (CSharpParser.PARTIAL - 66)) | (1 << (CSharpParser.PRIVATE - 66)) | (
                            1 << (CSharpParser.PROTECTED - 66)) | (1 << (CSharpParser.PUBLIC - 66)) | (
                            1 << (CSharpParser.READONLY - 66)) | (1 << (CSharpParser.SEALED - 66)) | (
                            1 << (CSharpParser.STATIC - 66)) | (1 << (CSharpParser.UNSAFE - 66)) | (
                            1 << (CSharpParser.VIRTUAL - 66)) | (1 << (CSharpParser.VOLATILE - 66)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Common_member_declarationContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def constant_declaration(self):
            return self.getTypedRuleContext(CSharpParser.Constant_declarationContext, 0)

        def typed_member_declaration(self):
            return self.getTypedRuleContext(CSharpParser.Typed_member_declarationContext, 0)

        def event_declaration(self):
            return self.getTypedRuleContext(CSharpParser.Event_declarationContext, 0)

        def conversion_operator_declarator(self):
            return self.getTypedRuleContext(CSharpParser.Conversion_operator_declaratorContext, 0)

        def body(self):
            return self.getTypedRuleContext(CSharpParser.BodyContext, 0)

        def right_arrow(self):
            return self.getTypedRuleContext(CSharpParser.Right_arrowContext, 0)

        def throwable_expression(self):
            return self.getTypedRuleContext(CSharpParser.Throwable_expressionContext, 0)

        def SEMICOLON(self):
            return self.getToken(CSharpParser.SEMICOLON, 0)

        def constructor_declaration(self):
            return self.getTypedRuleContext(CSharpParser.Constructor_declarationContext, 0)

        def VOID(self):
            return self.getToken(CSharpParser.VOID, 0)

        def method_declaration(self):
            return self.getTypedRuleContext(CSharpParser.Method_declarationContext, 0)

        def class_definition(self):
            return self.getTypedRuleContext(CSharpParser.Class_definitionContext, 0)

        def struct_definition(self):
            return self.getTypedRuleContext(CSharpParser.Struct_definitionContext, 0)

        def interface_definition(self):
            return self.getTypedRuleContext(CSharpParser.Interface_definitionContext, 0)

        def enum_definition(self):
            return self.getTypedRuleContext(CSharpParser.Enum_definitionContext, 0)

        def delegate_definition(self):
            return self.getTypedRuleContext(CSharpParser.Delegate_definitionContext, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_common_member_declaration

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterCommon_member_declaration"):
                listener.enterCommon_member_declaration(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitCommon_member_declaration"):
                listener.exitCommon_member_declaration(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitCommon_member_declaration"):
                return visitor.visitCommon_member_declaration(self)
            else:
                return visitor.visitChildren(self)

    def common_member_declaration(self):

        localctx = CSharpParser.Common_member_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 262, self.RULE_common_member_declaration)
        try:
            self.state = 1773
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 200, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1754
                self.constant_declaration()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1755
                self.typed_member_declaration()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1756
                self.event_declaration()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1757
                self.conversion_operator_declarator()
                self.state = 1763
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [CSharpParser.OPEN_BRACE, CSharpParser.SEMICOLON]:
                    self.state = 1758
                    self.body()
                    pass
                elif token in [CSharpParser.ASSIGNMENT]:
                    self.state = 1759
                    self.right_arrow()
                    self.state = 1760
                    self.throwable_expression()
                    self.state = 1761
                    self.match(CSharpParser.SEMICOLON)
                    pass
                else:
                    raise NoViableAltException(self)

                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 1765
                self.constructor_declaration()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 1766
                self.match(CSharpParser.VOID)
                self.state = 1767
                self.method_declaration()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 1768
                self.class_definition()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 1769
                self.struct_definition()
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 1770
                self.interface_definition()
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 1771
                self.enum_definition()
                pass

            elif la_ == 11:
                self.enterOuterAlt(localctx, 11)
                self.state = 1772
                self.delegate_definition()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Typed_member_declarationContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def type_(self):
            return self.getTypedRuleContext(CSharpParser.Type_Context, 0)

        def namespace_or_type_name(self):
            return self.getTypedRuleContext(CSharpParser.Namespace_or_type_nameContext, 0)

        def DOT(self):
            return self.getToken(CSharpParser.DOT, 0)

        def indexer_declaration(self):
            return self.getTypedRuleContext(CSharpParser.Indexer_declarationContext, 0)

        def method_declaration(self):
            return self.getTypedRuleContext(CSharpParser.Method_declarationContext, 0)

        def property_declaration(self):
            return self.getTypedRuleContext(CSharpParser.Property_declarationContext, 0)

        def operator_declaration(self):
            return self.getTypedRuleContext(CSharpParser.Operator_declarationContext, 0)

        def field_declaration(self):
            return self.getTypedRuleContext(CSharpParser.Field_declarationContext, 0)

        def REF(self):
            return self.getToken(CSharpParser.REF, 0)

        def READONLY(self):
            return self.getToken(CSharpParser.READONLY, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_typed_member_declaration

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterTyped_member_declaration"):
                listener.enterTyped_member_declaration(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitTyped_member_declaration"):
                listener.exitTyped_member_declaration(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitTyped_member_declaration"):
                return visitor.visitTyped_member_declaration(self)
            else:
                return visitor.visitChildren(self)

    def typed_member_declaration(self):

        localctx = CSharpParser.Typed_member_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 264, self.RULE_typed_member_declaration)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1780
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 201, self._ctx)
            if la_ == 1:
                self.state = 1775
                self.match(CSharpParser.REF)

            elif la_ == 2:
                self.state = 1776
                self.match(CSharpParser.READONLY)
                self.state = 1777
                self.match(CSharpParser.REF)

            elif la_ == 3:
                self.state = 1778
                self.match(CSharpParser.REF)
                self.state = 1779
                self.match(CSharpParser.READONLY)

            self.state = 1782
            self.type_()
            self.state = 1792
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 202, self._ctx)
            if la_ == 1:
                self.state = 1783
                self.namespace_or_type_name()
                self.state = 1784
                self.match(CSharpParser.DOT)
                self.state = 1785
                self.indexer_declaration()
                pass

            elif la_ == 2:
                self.state = 1787
                self.method_declaration()
                pass

            elif la_ == 3:
                self.state = 1788
                self.property_declaration()
                pass

            elif la_ == 4:
                self.state = 1789
                self.indexer_declaration()
                pass

            elif la_ == 5:
                self.state = 1790
                self.operator_declaration()
                pass

            elif la_ == 6:
                self.state = 1791
                self.field_declaration()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Constant_declaratorsContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def constant_declarator(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(CSharpParser.Constant_declaratorContext)
            else:
                return self.getTypedRuleContext(CSharpParser.Constant_declaratorContext, i)

        def COMMA(self, i: int = None):
            if i is None:
                return self.getTokens(CSharpParser.COMMA)
            else:
                return self.getToken(CSharpParser.COMMA, i)

        def getRuleIndex(self):
            return CSharpParser.RULE_constant_declarators

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterConstant_declarators"):
                listener.enterConstant_declarators(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitConstant_declarators"):
                listener.exitConstant_declarators(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitConstant_declarators"):
                return visitor.visitConstant_declarators(self)
            else:
                return visitor.visitChildren(self)

    def constant_declarators(self):

        localctx = CSharpParser.Constant_declaratorsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 266, self.RULE_constant_declarators)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1794
            self.constant_declarator()
            self.state = 1799
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == CSharpParser.COMMA:
                self.state = 1795
                self.match(CSharpParser.COMMA)
                self.state = 1796
                self.constant_declarator()
                self.state = 1801
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Constant_declaratorContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(CSharpParser.IdentifierContext, 0)

        def ASSIGNMENT(self):
            return self.getToken(CSharpParser.ASSIGNMENT, 0)

        def expression(self):
            return self.getTypedRuleContext(CSharpParser.ExpressionContext, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_constant_declarator

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterConstant_declarator"):
                listener.enterConstant_declarator(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitConstant_declarator"):
                listener.exitConstant_declarator(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitConstant_declarator"):
                return visitor.visitConstant_declarator(self)
            else:
                return visitor.visitChildren(self)

    def constant_declarator(self):

        localctx = CSharpParser.Constant_declaratorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 268, self.RULE_constant_declarator)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1802
            self.identifier()
            self.state = 1803
            self.match(CSharpParser.ASSIGNMENT)
            self.state = 1804
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Variable_declaratorsContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variable_declarator(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(CSharpParser.Variable_declaratorContext)
            else:
                return self.getTypedRuleContext(CSharpParser.Variable_declaratorContext, i)

        def COMMA(self, i: int = None):
            if i is None:
                return self.getTokens(CSharpParser.COMMA)
            else:
                return self.getToken(CSharpParser.COMMA, i)

        def getRuleIndex(self):
            return CSharpParser.RULE_variable_declarators

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterVariable_declarators"):
                listener.enterVariable_declarators(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitVariable_declarators"):
                listener.exitVariable_declarators(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitVariable_declarators"):
                return visitor.visitVariable_declarators(self)
            else:
                return visitor.visitChildren(self)

    def variable_declarators(self):

        localctx = CSharpParser.Variable_declaratorsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 270, self.RULE_variable_declarators)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1806
            self.variable_declarator()
            self.state = 1811
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == CSharpParser.COMMA:
                self.state = 1807
                self.match(CSharpParser.COMMA)
                self.state = 1808
                self.variable_declarator()
                self.state = 1813
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Variable_declaratorContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(CSharpParser.IdentifierContext, 0)

        def ASSIGNMENT(self):
            return self.getToken(CSharpParser.ASSIGNMENT, 0)

        def variable_initializer(self):
            return self.getTypedRuleContext(CSharpParser.Variable_initializerContext, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_variable_declarator

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterVariable_declarator"):
                listener.enterVariable_declarator(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitVariable_declarator"):
                listener.exitVariable_declarator(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitVariable_declarator"):
                return visitor.visitVariable_declarator(self)
            else:
                return visitor.visitChildren(self)

    def variable_declarator(self):

        localctx = CSharpParser.Variable_declaratorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 272, self.RULE_variable_declarator)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1814
            self.identifier()
            self.state = 1817
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == CSharpParser.ASSIGNMENT:
                self.state = 1815
                self.match(CSharpParser.ASSIGNMENT)
                self.state = 1816
                self.variable_initializer()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Variable_initializerContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(CSharpParser.ExpressionContext, 0)

        def array_initializer(self):
            return self.getTypedRuleContext(CSharpParser.Array_initializerContext, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_variable_initializer

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterVariable_initializer"):
                listener.enterVariable_initializer(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitVariable_initializer"):
                listener.exitVariable_initializer(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitVariable_initializer"):
                return visitor.visitVariable_initializer(self)
            else:
                return visitor.visitChildren(self)

    def variable_initializer(self):

        localctx = CSharpParser.Variable_initializerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 274, self.RULE_variable_initializer)
        try:
            self.state = 1821
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [CSharpParser.ADD, CSharpParser.ALIAS, CSharpParser.ARGLIST, CSharpParser.ASCENDING,
                         CSharpParser.ASYNC, CSharpParser.AWAIT, CSharpParser.BASE, CSharpParser.BOOL, CSharpParser.BY,
                         CSharpParser.BYTE, CSharpParser.CHAR, CSharpParser.CHECKED, CSharpParser.DECIMAL,
                         CSharpParser.DEFAULT, CSharpParser.DELEGATE, CSharpParser.DESCENDING, CSharpParser.DOUBLE,
                         CSharpParser.DYNAMIC, CSharpParser.EQUALS, CSharpParser.FALSE, CSharpParser.FLOAT,
                         CSharpParser.FROM, CSharpParser.GET, CSharpParser.GROUP, CSharpParser.INT, CSharpParser.INTO,
                         CSharpParser.JOIN, CSharpParser.LET, CSharpParser.LONG, CSharpParser.NAMEOF, CSharpParser.NEW,
                         CSharpParser.NULL_, CSharpParser.OBJECT, CSharpParser.ON, CSharpParser.ORDERBY,
                         CSharpParser.PARTIAL, CSharpParser.REF, CSharpParser.REMOVE, CSharpParser.SBYTE,
                         CSharpParser.SELECT, CSharpParser.SET, CSharpParser.SHORT, CSharpParser.SIZEOF,
                         CSharpParser.STRING, CSharpParser.THIS, CSharpParser.TRUE, CSharpParser.TYPEOF,
                         CSharpParser.UINT, CSharpParser.ULONG, CSharpParser.UNCHECKED, CSharpParser.UNMANAGED,
                         CSharpParser.USHORT, CSharpParser.VAR, CSharpParser.WHEN, CSharpParser.WHERE,
                         CSharpParser.YIELD, CSharpParser.IDENTIFIER, CSharpParser.LITERAL_ACCESS,
                         CSharpParser.INTEGER_LITERAL, CSharpParser.HEX_INTEGER_LITERAL,
                         CSharpParser.BIN_INTEGER_LITERAL, CSharpParser.REAL_LITERAL, CSharpParser.CHARACTER_LITERAL,
                         CSharpParser.REGULAR_STRING, CSharpParser.VERBATIUM_STRING,
                         CSharpParser.INTERPOLATED_REGULAR_STRING_START,
                         CSharpParser.INTERPOLATED_VERBATIUM_STRING_START, CSharpParser.OPEN_PARENS, CSharpParser.PLUS,
                         CSharpParser.MINUS, CSharpParser.STAR, CSharpParser.AMP, CSharpParser.CARET, CSharpParser.BANG,
                         CSharpParser.TILDE, CSharpParser.OP_INC, CSharpParser.OP_DEC, CSharpParser.OP_RANGE]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1819
                self.expression()
                pass
            elif token in [CSharpParser.OPEN_BRACE]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1820
                self.array_initializer()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Return_typeContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def type_(self):
            return self.getTypedRuleContext(CSharpParser.Type_Context, 0)

        def VOID(self):
            return self.getToken(CSharpParser.VOID, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_return_type

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterReturn_type"):
                listener.enterReturn_type(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitReturn_type"):
                listener.exitReturn_type(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitReturn_type"):
                return visitor.visitReturn_type(self)
            else:
                return visitor.visitChildren(self)

    def return_type(self):

        localctx = CSharpParser.Return_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 276, self.RULE_return_type)
        try:
            self.state = 1825
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 207, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1823
                self.type_()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1824
                self.match(CSharpParser.VOID)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Member_nameContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def namespace_or_type_name(self):
            return self.getTypedRuleContext(CSharpParser.Namespace_or_type_nameContext, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_member_name

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterMember_name"):
                listener.enterMember_name(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitMember_name"):
                listener.exitMember_name(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitMember_name"):
                return visitor.visitMember_name(self)
            else:
                return visitor.visitChildren(self)

    def member_name(self):

        localctx = CSharpParser.Member_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 278, self.RULE_member_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1827
            self.namespace_or_type_name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Method_bodyContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def block(self):
            return self.getTypedRuleContext(CSharpParser.BlockContext, 0)

        def SEMICOLON(self):
            return self.getToken(CSharpParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_method_body

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterMethod_body"):
                listener.enterMethod_body(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitMethod_body"):
                listener.exitMethod_body(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitMethod_body"):
                return visitor.visitMethod_body(self)
            else:
                return visitor.visitChildren(self)

    def method_body(self):

        localctx = CSharpParser.Method_bodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 280, self.RULE_method_body)
        try:
            self.state = 1831
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [CSharpParser.OPEN_BRACE]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1829
                self.block()
                pass
            elif token in [CSharpParser.SEMICOLON]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1830
                self.match(CSharpParser.SEMICOLON)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Formal_parameter_listContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def parameter_array(self):
            return self.getTypedRuleContext(CSharpParser.Parameter_arrayContext, 0)

        def fixed_parameters(self):
            return self.getTypedRuleContext(CSharpParser.Fixed_parametersContext, 0)

        def COMMA(self):
            return self.getToken(CSharpParser.COMMA, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_formal_parameter_list

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterFormal_parameter_list"):
                listener.enterFormal_parameter_list(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitFormal_parameter_list"):
                listener.exitFormal_parameter_list(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitFormal_parameter_list"):
                return visitor.visitFormal_parameter_list(self)
            else:
                return visitor.visitChildren(self)

    def formal_parameter_list(self):

        localctx = CSharpParser.Formal_parameter_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 282, self.RULE_formal_parameter_list)
        self._la = 0  # Token type
        try:
            self.state = 1839
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 210, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1833
                self.parameter_array()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1834
                self.fixed_parameters()
                self.state = 1837
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == CSharpParser.COMMA:
                    self.state = 1835
                    self.match(CSharpParser.COMMA)
                    self.state = 1836
                    self.parameter_array()

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Fixed_parametersContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fixed_parameter(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(CSharpParser.Fixed_parameterContext)
            else:
                return self.getTypedRuleContext(CSharpParser.Fixed_parameterContext, i)

        def COMMA(self, i: int = None):
            if i is None:
                return self.getTokens(CSharpParser.COMMA)
            else:
                return self.getToken(CSharpParser.COMMA, i)

        def getRuleIndex(self):
            return CSharpParser.RULE_fixed_parameters

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterFixed_parameters"):
                listener.enterFixed_parameters(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitFixed_parameters"):
                listener.exitFixed_parameters(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitFixed_parameters"):
                return visitor.visitFixed_parameters(self)
            else:
                return visitor.visitChildren(self)

    def fixed_parameters(self):

        localctx = CSharpParser.Fixed_parametersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 284, self.RULE_fixed_parameters)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1841
            self.fixed_parameter()
            self.state = 1846
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input, 211, self._ctx)
            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 1842
                    self.match(CSharpParser.COMMA)
                    self.state = 1843
                    self.fixed_parameter()
                self.state = 1848
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 211, self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Fixed_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def arg_declaration(self):
            return self.getTypedRuleContext(CSharpParser.Arg_declarationContext, 0)

        def attributes(self):
            return self.getTypedRuleContext(CSharpParser.AttributesContext, 0)

        def parameter_modifier(self):
            return self.getTypedRuleContext(CSharpParser.Parameter_modifierContext, 0)

        def ARGLIST(self):
            return self.getToken(CSharpParser.ARGLIST, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_fixed_parameter

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterFixed_parameter"):
                listener.enterFixed_parameter(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitFixed_parameter"):
                listener.exitFixed_parameter(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitFixed_parameter"):
                return visitor.visitFixed_parameter(self)
            else:
                return visitor.visitChildren(self)

    def fixed_parameter(self):

        localctx = CSharpParser.Fixed_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 286, self.RULE_fixed_parameter)
        self._la = 0  # Token type
        try:
            self.state = 1857
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 214, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1850
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == CSharpParser.OPEN_BRACKET:
                    self.state = 1849
                    self.attributes()

                self.state = 1853
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 54)) & ~0x3f) == 0 and ((1 << (_la - 54)) & (
                        (1 << (CSharpParser.IN - 54)) | (1 << (CSharpParser.OUT - 54)) | (
                        1 << (CSharpParser.REF - 54)) | (1 << (CSharpParser.THIS - 54)))) != 0):
                    self.state = 1852
                    self.parameter_modifier()

                self.state = 1855
                self.arg_declaration()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1856
                self.match(CSharpParser.ARGLIST)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Parameter_modifierContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def REF(self):
            return self.getToken(CSharpParser.REF, 0)

        def OUT(self):
            return self.getToken(CSharpParser.OUT, 0)

        def IN(self):
            return self.getToken(CSharpParser.IN, 0)

        def THIS(self):
            return self.getToken(CSharpParser.THIS, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_parameter_modifier

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterParameter_modifier"):
                listener.enterParameter_modifier(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitParameter_modifier"):
                listener.exitParameter_modifier(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitParameter_modifier"):
                return visitor.visitParameter_modifier(self)
            else:
                return visitor.visitChildren(self)

    def parameter_modifier(self):

        localctx = CSharpParser.Parameter_modifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 288, self.RULE_parameter_modifier)
        try:
            self.state = 1867
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 215, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1859
                self.match(CSharpParser.REF)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1860
                self.match(CSharpParser.OUT)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1861
                self.match(CSharpParser.IN)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1862
                self.match(CSharpParser.REF)
                self.state = 1863
                self.match(CSharpParser.THIS)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 1864
                self.match(CSharpParser.IN)
                self.state = 1865
                self.match(CSharpParser.THIS)
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 1866
                self.match(CSharpParser.THIS)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Parameter_arrayContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PARAMS(self):
            return self.getToken(CSharpParser.PARAMS, 0)

        def array_type(self):
            return self.getTypedRuleContext(CSharpParser.Array_typeContext, 0)

        def identifier(self):
            return self.getTypedRuleContext(CSharpParser.IdentifierContext, 0)

        def attributes(self):
            return self.getTypedRuleContext(CSharpParser.AttributesContext, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_parameter_array

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterParameter_array"):
                listener.enterParameter_array(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitParameter_array"):
                listener.exitParameter_array(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitParameter_array"):
                return visitor.visitParameter_array(self)
            else:
                return visitor.visitChildren(self)

    def parameter_array(self):

        localctx = CSharpParser.Parameter_arrayContext(self, self._ctx, self.state)
        self.enterRule(localctx, 290, self.RULE_parameter_array)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1870
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == CSharpParser.OPEN_BRACKET:
                self.state = 1869
                self.attributes()

            self.state = 1872
            self.match(CSharpParser.PARAMS)
            self.state = 1873
            self.array_type()
            self.state = 1874
            self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Accessor_declarationsContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.attrs = None  # AttributesContext
            self.mods = None  # Accessor_modifierContext

        def GET(self):
            return self.getToken(CSharpParser.GET, 0)

        def accessor_body(self):
            return self.getTypedRuleContext(CSharpParser.Accessor_bodyContext, 0)

        def SET(self):
            return self.getToken(CSharpParser.SET, 0)

        def attributes(self):
            return self.getTypedRuleContext(CSharpParser.AttributesContext, 0)

        def accessor_modifier(self):
            return self.getTypedRuleContext(CSharpParser.Accessor_modifierContext, 0)

        def set_accessor_declaration(self):
            return self.getTypedRuleContext(CSharpParser.Set_accessor_declarationContext, 0)

        def get_accessor_declaration(self):
            return self.getTypedRuleContext(CSharpParser.Get_accessor_declarationContext, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_accessor_declarations

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterAccessor_declarations"):
                listener.enterAccessor_declarations(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitAccessor_declarations"):
                listener.exitAccessor_declarations(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitAccessor_declarations"):
                return visitor.visitAccessor_declarations(self)
            else:
                return visitor.visitChildren(self)

    def accessor_declarations(self):

        localctx = CSharpParser.Accessor_declarationsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 292, self.RULE_accessor_declarations)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1877
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == CSharpParser.OPEN_BRACKET:
                self.state = 1876
                localctx.attrs = self.attributes()

            self.state = 1880
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 57)) & ~0x3f) == 0 and ((1 << (_la - 57)) & (
                    (1 << (CSharpParser.INTERNAL - 57)) | (1 << (CSharpParser.PRIVATE - 57)) | (
                    1 << (CSharpParser.PROTECTED - 57)))) != 0):
                self.state = 1879
                localctx.mods = self.accessor_modifier()

            self.state = 1892
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [CSharpParser.GET]:
                self.state = 1882
                self.match(CSharpParser.GET)
                self.state = 1883
                self.accessor_body()
                self.state = 1885
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == CSharpParser.INTERNAL or ((((_la - 76)) & ~0x3f) == 0 and ((1 << (_la - 76)) & (
                        (1 << (CSharpParser.PRIVATE - 76)) | (1 << (CSharpParser.PROTECTED - 76)) | (
                        1 << (CSharpParser.SET - 76)) | (1 << (CSharpParser.OPEN_BRACKET - 76)))) != 0):
                    self.state = 1884
                    self.set_accessor_declaration()

                pass
            elif token in [CSharpParser.SET]:
                self.state = 1887
                self.match(CSharpParser.SET)
                self.state = 1888
                self.accessor_body()
                self.state = 1890
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == CSharpParser.GET or _la == CSharpParser.INTERNAL or ((((_la - 76)) & ~0x3f) == 0 and (
                        (1 << (_la - 76)) & (
                        (1 << (CSharpParser.PRIVATE - 76)) | (1 << (CSharpParser.PROTECTED - 76)) | (
                        1 << (CSharpParser.OPEN_BRACKET - 76)))) != 0):
                    self.state = 1889
                    self.get_accessor_declaration()

                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Get_accessor_declarationContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GET(self):
            return self.getToken(CSharpParser.GET, 0)

        def accessor_body(self):
            return self.getTypedRuleContext(CSharpParser.Accessor_bodyContext, 0)

        def attributes(self):
            return self.getTypedRuleContext(CSharpParser.AttributesContext, 0)

        def accessor_modifier(self):
            return self.getTypedRuleContext(CSharpParser.Accessor_modifierContext, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_get_accessor_declaration

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterGet_accessor_declaration"):
                listener.enterGet_accessor_declaration(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitGet_accessor_declaration"):
                listener.exitGet_accessor_declaration(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitGet_accessor_declaration"):
                return visitor.visitGet_accessor_declaration(self)
            else:
                return visitor.visitChildren(self)

    def get_accessor_declaration(self):

        localctx = CSharpParser.Get_accessor_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 294, self.RULE_get_accessor_declaration)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1895
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == CSharpParser.OPEN_BRACKET:
                self.state = 1894
                self.attributes()

            self.state = 1898
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 57)) & ~0x3f) == 0 and ((1 << (_la - 57)) & (
                    (1 << (CSharpParser.INTERNAL - 57)) | (1 << (CSharpParser.PRIVATE - 57)) | (
                    1 << (CSharpParser.PROTECTED - 57)))) != 0):
                self.state = 1897
                self.accessor_modifier()

            self.state = 1900
            self.match(CSharpParser.GET)
            self.state = 1901
            self.accessor_body()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Set_accessor_declarationContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SET(self):
            return self.getToken(CSharpParser.SET, 0)

        def accessor_body(self):
            return self.getTypedRuleContext(CSharpParser.Accessor_bodyContext, 0)

        def attributes(self):
            return self.getTypedRuleContext(CSharpParser.AttributesContext, 0)

        def accessor_modifier(self):
            return self.getTypedRuleContext(CSharpParser.Accessor_modifierContext, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_set_accessor_declaration

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterSet_accessor_declaration"):
                listener.enterSet_accessor_declaration(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitSet_accessor_declaration"):
                listener.exitSet_accessor_declaration(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitSet_accessor_declaration"):
                return visitor.visitSet_accessor_declaration(self)
            else:
                return visitor.visitChildren(self)

    def set_accessor_declaration(self):

        localctx = CSharpParser.Set_accessor_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 296, self.RULE_set_accessor_declaration)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1904
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == CSharpParser.OPEN_BRACKET:
                self.state = 1903
                self.attributes()

            self.state = 1907
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 57)) & ~0x3f) == 0 and ((1 << (_la - 57)) & (
                    (1 << (CSharpParser.INTERNAL - 57)) | (1 << (CSharpParser.PRIVATE - 57)) | (
                    1 << (CSharpParser.PROTECTED - 57)))) != 0):
                self.state = 1906
                self.accessor_modifier()

            self.state = 1909
            self.match(CSharpParser.SET)
            self.state = 1910
            self.accessor_body()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Accessor_modifierContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PROTECTED(self):
            return self.getToken(CSharpParser.PROTECTED, 0)

        def INTERNAL(self):
            return self.getToken(CSharpParser.INTERNAL, 0)

        def PRIVATE(self):
            return self.getToken(CSharpParser.PRIVATE, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_accessor_modifier

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterAccessor_modifier"):
                listener.enterAccessor_modifier(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitAccessor_modifier"):
                listener.exitAccessor_modifier(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitAccessor_modifier"):
                return visitor.visitAccessor_modifier(self)
            else:
                return visitor.visitChildren(self)

    def accessor_modifier(self):

        localctx = CSharpParser.Accessor_modifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 298, self.RULE_accessor_modifier)
        try:
            self.state = 1919
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 226, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1912
                self.match(CSharpParser.PROTECTED)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1913
                self.match(CSharpParser.INTERNAL)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1914
                self.match(CSharpParser.PRIVATE)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1915
                self.match(CSharpParser.PROTECTED)
                self.state = 1916
                self.match(CSharpParser.INTERNAL)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 1917
                self.match(CSharpParser.INTERNAL)
                self.state = 1918
                self.match(CSharpParser.PROTECTED)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Accessor_bodyContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def block(self):
            return self.getTypedRuleContext(CSharpParser.BlockContext, 0)

        def SEMICOLON(self):
            return self.getToken(CSharpParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_accessor_body

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterAccessor_body"):
                listener.enterAccessor_body(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitAccessor_body"):
                listener.exitAccessor_body(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitAccessor_body"):
                return visitor.visitAccessor_body(self)
            else:
                return visitor.visitChildren(self)

    def accessor_body(self):

        localctx = CSharpParser.Accessor_bodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 300, self.RULE_accessor_body)
        try:
            self.state = 1923
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [CSharpParser.OPEN_BRACE]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1921
                self.block()
                pass
            elif token in [CSharpParser.SEMICOLON]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1922
                self.match(CSharpParser.SEMICOLON)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Event_accessor_declarationsContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ADD(self):
            return self.getToken(CSharpParser.ADD, 0)

        def block(self):
            return self.getTypedRuleContext(CSharpParser.BlockContext, 0)

        def remove_accessor_declaration(self):
            return self.getTypedRuleContext(CSharpParser.Remove_accessor_declarationContext, 0)

        def REMOVE(self):
            return self.getToken(CSharpParser.REMOVE, 0)

        def add_accessor_declaration(self):
            return self.getTypedRuleContext(CSharpParser.Add_accessor_declarationContext, 0)

        def attributes(self):
            return self.getTypedRuleContext(CSharpParser.AttributesContext, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_event_accessor_declarations

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterEvent_accessor_declarations"):
                listener.enterEvent_accessor_declarations(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitEvent_accessor_declarations"):
                listener.exitEvent_accessor_declarations(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitEvent_accessor_declarations"):
                return visitor.visitEvent_accessor_declarations(self)
            else:
                return visitor.visitChildren(self)

    def event_accessor_declarations(self):

        localctx = CSharpParser.Event_accessor_declarationsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 302, self.RULE_event_accessor_declarations)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1926
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == CSharpParser.OPEN_BRACKET:
                self.state = 1925
                self.attributes()

            self.state = 1936
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [CSharpParser.ADD]:
                self.state = 1928
                self.match(CSharpParser.ADD)
                self.state = 1929
                self.block()
                self.state = 1930
                self.remove_accessor_declaration()
                pass
            elif token in [CSharpParser.REMOVE]:
                self.state = 1932
                self.match(CSharpParser.REMOVE)
                self.state = 1933
                self.block()
                self.state = 1934
                self.add_accessor_declaration()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Add_accessor_declarationContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ADD(self):
            return self.getToken(CSharpParser.ADD, 0)

        def block(self):
            return self.getTypedRuleContext(CSharpParser.BlockContext, 0)

        def attributes(self):
            return self.getTypedRuleContext(CSharpParser.AttributesContext, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_add_accessor_declaration

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterAdd_accessor_declaration"):
                listener.enterAdd_accessor_declaration(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitAdd_accessor_declaration"):
                listener.exitAdd_accessor_declaration(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitAdd_accessor_declaration"):
                return visitor.visitAdd_accessor_declaration(self)
            else:
                return visitor.visitChildren(self)

    def add_accessor_declaration(self):

        localctx = CSharpParser.Add_accessor_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 304, self.RULE_add_accessor_declaration)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1939
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == CSharpParser.OPEN_BRACKET:
                self.state = 1938
                self.attributes()

            self.state = 1941
            self.match(CSharpParser.ADD)
            self.state = 1942
            self.block()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Remove_accessor_declarationContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def REMOVE(self):
            return self.getToken(CSharpParser.REMOVE, 0)

        def block(self):
            return self.getTypedRuleContext(CSharpParser.BlockContext, 0)

        def attributes(self):
            return self.getTypedRuleContext(CSharpParser.AttributesContext, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_remove_accessor_declaration

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterRemove_accessor_declaration"):
                listener.enterRemove_accessor_declaration(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitRemove_accessor_declaration"):
                listener.exitRemove_accessor_declaration(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitRemove_accessor_declaration"):
                return visitor.visitRemove_accessor_declaration(self)
            else:
                return visitor.visitChildren(self)

    def remove_accessor_declaration(self):

        localctx = CSharpParser.Remove_accessor_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 306, self.RULE_remove_accessor_declaration)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1945
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == CSharpParser.OPEN_BRACKET:
                self.state = 1944
                self.attributes()

            self.state = 1947
            self.match(CSharpParser.REMOVE)
            self.state = 1948
            self.block()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Overloadable_operatorContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PLUS(self):
            return self.getToken(CSharpParser.PLUS, 0)

        def MINUS(self):
            return self.getToken(CSharpParser.MINUS, 0)

        def BANG(self):
            return self.getToken(CSharpParser.BANG, 0)

        def TILDE(self):
            return self.getToken(CSharpParser.TILDE, 0)

        def OP_INC(self):
            return self.getToken(CSharpParser.OP_INC, 0)

        def OP_DEC(self):
            return self.getToken(CSharpParser.OP_DEC, 0)

        def TRUE(self):
            return self.getToken(CSharpParser.TRUE, 0)

        def FALSE(self):
            return self.getToken(CSharpParser.FALSE, 0)

        def STAR(self):
            return self.getToken(CSharpParser.STAR, 0)

        def DIV(self):
            return self.getToken(CSharpParser.DIV, 0)

        def PERCENT(self):
            return self.getToken(CSharpParser.PERCENT, 0)

        def AMP(self):
            return self.getToken(CSharpParser.AMP, 0)

        def BITWISE_OR(self):
            return self.getToken(CSharpParser.BITWISE_OR, 0)

        def CARET(self):
            return self.getToken(CSharpParser.CARET, 0)

        def OP_LEFT_SHIFT(self):
            return self.getToken(CSharpParser.OP_LEFT_SHIFT, 0)

        def right_shift(self):
            return self.getTypedRuleContext(CSharpParser.Right_shiftContext, 0)

        def OP_EQ(self):
            return self.getToken(CSharpParser.OP_EQ, 0)

        def OP_NE(self):
            return self.getToken(CSharpParser.OP_NE, 0)

        def GT(self):
            return self.getToken(CSharpParser.GT, 0)

        def LT(self):
            return self.getToken(CSharpParser.LT, 0)

        def OP_GE(self):
            return self.getToken(CSharpParser.OP_GE, 0)

        def OP_LE(self):
            return self.getToken(CSharpParser.OP_LE, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_overloadable_operator

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterOverloadable_operator"):
                listener.enterOverloadable_operator(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitOverloadable_operator"):
                listener.exitOverloadable_operator(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitOverloadable_operator"):
                return visitor.visitOverloadable_operator(self)
            else:
                return visitor.visitChildren(self)

    def overloadable_operator(self):

        localctx = CSharpParser.Overloadable_operatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 308, self.RULE_overloadable_operator)
        try:
            self.state = 1972
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 232, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1950
                self.match(CSharpParser.PLUS)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1951
                self.match(CSharpParser.MINUS)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1952
                self.match(CSharpParser.BANG)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1953
                self.match(CSharpParser.TILDE)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 1954
                self.match(CSharpParser.OP_INC)
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 1955
                self.match(CSharpParser.OP_DEC)
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 1956
                self.match(CSharpParser.TRUE)
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 1957
                self.match(CSharpParser.FALSE)
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 1958
                self.match(CSharpParser.STAR)
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 1959
                self.match(CSharpParser.DIV)
                pass

            elif la_ == 11:
                self.enterOuterAlt(localctx, 11)
                self.state = 1960
                self.match(CSharpParser.PERCENT)
                pass

            elif la_ == 12:
                self.enterOuterAlt(localctx, 12)
                self.state = 1961
                self.match(CSharpParser.AMP)
                pass

            elif la_ == 13:
                self.enterOuterAlt(localctx, 13)
                self.state = 1962
                self.match(CSharpParser.BITWISE_OR)
                pass

            elif la_ == 14:
                self.enterOuterAlt(localctx, 14)
                self.state = 1963
                self.match(CSharpParser.CARET)
                pass

            elif la_ == 15:
                self.enterOuterAlt(localctx, 15)
                self.state = 1964
                self.match(CSharpParser.OP_LEFT_SHIFT)
                pass

            elif la_ == 16:
                self.enterOuterAlt(localctx, 16)
                self.state = 1965
                self.right_shift()
                pass

            elif la_ == 17:
                self.enterOuterAlt(localctx, 17)
                self.state = 1966
                self.match(CSharpParser.OP_EQ)
                pass

            elif la_ == 18:
                self.enterOuterAlt(localctx, 18)
                self.state = 1967
                self.match(CSharpParser.OP_NE)
                pass

            elif la_ == 19:
                self.enterOuterAlt(localctx, 19)
                self.state = 1968
                self.match(CSharpParser.GT)
                pass

            elif la_ == 20:
                self.enterOuterAlt(localctx, 20)
                self.state = 1969
                self.match(CSharpParser.LT)
                pass

            elif la_ == 21:
                self.enterOuterAlt(localctx, 21)
                self.state = 1970
                self.match(CSharpParser.OP_GE)
                pass

            elif la_ == 22:
                self.enterOuterAlt(localctx, 22)
                self.state = 1971
                self.match(CSharpParser.OP_LE)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Conversion_operator_declaratorContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPERATOR(self):
            return self.getToken(CSharpParser.OPERATOR, 0)

        def type_(self):
            return self.getTypedRuleContext(CSharpParser.Type_Context, 0)

        def OPEN_PARENS(self):
            return self.getToken(CSharpParser.OPEN_PARENS, 0)

        def arg_declaration(self):
            return self.getTypedRuleContext(CSharpParser.Arg_declarationContext, 0)

        def CLOSE_PARENS(self):
            return self.getToken(CSharpParser.CLOSE_PARENS, 0)

        def IMPLICIT(self):
            return self.getToken(CSharpParser.IMPLICIT, 0)

        def EXPLICIT(self):
            return self.getToken(CSharpParser.EXPLICIT, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_conversion_operator_declarator

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterConversion_operator_declarator"):
                listener.enterConversion_operator_declarator(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitConversion_operator_declarator"):
                listener.exitConversion_operator_declarator(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitConversion_operator_declarator"):
                return visitor.visitConversion_operator_declarator(self)
            else:
                return visitor.visitChildren(self)

    def conversion_operator_declarator(self):

        localctx = CSharpParser.Conversion_operator_declaratorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 310, self.RULE_conversion_operator_declarator)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1974
            _la = self._input.LA(1)
            if not (_la == CSharpParser.EXPLICIT or _la == CSharpParser.IMPLICIT):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 1975
            self.match(CSharpParser.OPERATOR)
            self.state = 1976
            self.type_()
            self.state = 1977
            self.match(CSharpParser.OPEN_PARENS)
            self.state = 1978
            self.arg_declaration()
            self.state = 1979
            self.match(CSharpParser.CLOSE_PARENS)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Constructor_initializerContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COLON(self):
            return self.getToken(CSharpParser.COLON, 0)

        def OPEN_PARENS(self):
            return self.getToken(CSharpParser.OPEN_PARENS, 0)

        def CLOSE_PARENS(self):
            return self.getToken(CSharpParser.CLOSE_PARENS, 0)

        def BASE(self):
            return self.getToken(CSharpParser.BASE, 0)

        def THIS(self):
            return self.getToken(CSharpParser.THIS, 0)

        def argument_list(self):
            return self.getTypedRuleContext(CSharpParser.Argument_listContext, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_constructor_initializer

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterConstructor_initializer"):
                listener.enterConstructor_initializer(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitConstructor_initializer"):
                listener.exitConstructor_initializer(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitConstructor_initializer"):
                return visitor.visitConstructor_initializer(self)
            else:
                return visitor.visitChildren(self)

    def constructor_initializer(self):

        localctx = CSharpParser.Constructor_initializerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 312, self.RULE_constructor_initializer)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1981
            self.match(CSharpParser.COLON)
            self.state = 1982
            _la = self._input.LA(1)
            if not (_la == CSharpParser.BASE or _la == CSharpParser.THIS):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 1983
            self.match(CSharpParser.OPEN_PARENS)
            self.state = 1985
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & (
                    (1 << CSharpParser.ADD) | (1 << CSharpParser.ALIAS) | (1 << CSharpParser.ARGLIST) | (
                    1 << CSharpParser.ASCENDING) | (1 << CSharpParser.ASYNC) | (1 << CSharpParser.AWAIT) | (
                            1 << CSharpParser.BASE) | (1 << CSharpParser.BOOL) | (1 << CSharpParser.BY) | (
                            1 << CSharpParser.BYTE) | (1 << CSharpParser.CHAR) | (1 << CSharpParser.CHECKED) | (
                            1 << CSharpParser.DECIMAL) | (1 << CSharpParser.DEFAULT) | (1 << CSharpParser.DELEGATE) | (
                            1 << CSharpParser.DESCENDING) | (1 << CSharpParser.DOUBLE) | (1 << CSharpParser.DYNAMIC) | (
                            1 << CSharpParser.EQUALS) | (1 << CSharpParser.FALSE) | (1 << CSharpParser.FLOAT) | (
                            1 << CSharpParser.FROM) | (1 << CSharpParser.GET) | (1 << CSharpParser.GROUP) | (
                            1 << CSharpParser.IN) | (1 << CSharpParser.INT) | (1 << CSharpParser.INTO) | (
                            1 << CSharpParser.JOIN) | (1 << CSharpParser.LET) | (1 << CSharpParser.LONG))) != 0) or (
                    (((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & (
                    (1 << (CSharpParser.NAMEOF - 64)) | (1 << (CSharpParser.NEW - 64)) | (
                    1 << (CSharpParser.NULL_ - 64)) | (1 << (CSharpParser.OBJECT - 64)) | (
                            1 << (CSharpParser.ON - 64)) | (1 << (CSharpParser.ORDERBY - 64)) | (
                            1 << (CSharpParser.OUT - 64)) | (1 << (CSharpParser.PARTIAL - 64)) | (
                            1 << (CSharpParser.REF - 64)) | (1 << (CSharpParser.REMOVE - 64)) | (
                            1 << (CSharpParser.SBYTE - 64)) | (1 << (CSharpParser.SELECT - 64)) | (
                            1 << (CSharpParser.SET - 64)) | (1 << (CSharpParser.SHORT - 64)) | (
                            1 << (CSharpParser.SIZEOF - 64)) | (1 << (CSharpParser.STRING - 64)) | (
                            1 << (CSharpParser.THIS - 64)) | (1 << (CSharpParser.TRUE - 64)) | (
                            1 << (CSharpParser.TYPEOF - 64)) | (1 << (CSharpParser.UINT - 64)) | (
                            1 << (CSharpParser.ULONG - 64)) | (1 << (CSharpParser.UNCHECKED - 64)) | (
                            1 << (CSharpParser.UNMANAGED - 64)) | (1 << (CSharpParser.USHORT - 64)) | (
                            1 << (CSharpParser.VAR - 64)) | (1 << (CSharpParser.VOID - 64)) | (
                            1 << (CSharpParser.WHEN - 64)) | (1 << (CSharpParser.WHERE - 64)) | (
                            1 << (CSharpParser.YIELD - 64)) | (1 << (CSharpParser.IDENTIFIER - 64)) | (
                            1 << (CSharpParser.LITERAL_ACCESS - 64)) | (1 << (CSharpParser.INTEGER_LITERAL - 64)) | (
                            1 << (CSharpParser.HEX_INTEGER_LITERAL - 64)) | (
                            1 << (CSharpParser.BIN_INTEGER_LITERAL - 64)) | (1 << (CSharpParser.REAL_LITERAL - 64)) | (
                            1 << (CSharpParser.CHARACTER_LITERAL - 64)) | (1 << (CSharpParser.REGULAR_STRING - 64)) | (
                            1 << (CSharpParser.VERBATIUM_STRING - 64)) | (
                            1 << (CSharpParser.INTERPOLATED_REGULAR_STRING_START - 64)) | (
                            1 << (CSharpParser.INTERPOLATED_VERBATIUM_STRING_START - 64)))) != 0) or (
                    (((_la - 129)) & ~0x3f) == 0 and ((1 << (_la - 129)) & (
                    (1 << (CSharpParser.OPEN_PARENS - 129)) | (1 << (CSharpParser.PLUS - 129)) | (
                    1 << (CSharpParser.MINUS - 129)) | (1 << (CSharpParser.STAR - 129)) | (
                            1 << (CSharpParser.AMP - 129)) | (1 << (CSharpParser.CARET - 129)) | (
                            1 << (CSharpParser.BANG - 129)) | (1 << (CSharpParser.TILDE - 129)) | (
                            1 << (CSharpParser.OP_INC - 129)) | (1 << (CSharpParser.OP_DEC - 129)) | (
                            1 << (CSharpParser.OP_RANGE - 129)))) != 0):
                self.state = 1984
                self.argument_list()

            self.state = 1987
            self.match(CSharpParser.CLOSE_PARENS)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class BodyContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def block(self):
            return self.getTypedRuleContext(CSharpParser.BlockContext, 0)

        def SEMICOLON(self):
            return self.getToken(CSharpParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_body

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterBody"):
                listener.enterBody(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitBody"):
                listener.exitBody(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitBody"):
                return visitor.visitBody(self)
            else:
                return visitor.visitChildren(self)

    def body(self):

        localctx = CSharpParser.BodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 314, self.RULE_body)
        try:
            self.state = 1991
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [CSharpParser.OPEN_BRACE]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1989
                self.block()
                pass
            elif token in [CSharpParser.SEMICOLON]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1990
                self.match(CSharpParser.SEMICOLON)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Struct_interfacesContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COLON(self):
            return self.getToken(CSharpParser.COLON, 0)

        def interface_type_list(self):
            return self.getTypedRuleContext(CSharpParser.Interface_type_listContext, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_struct_interfaces

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterStruct_interfaces"):
                listener.enterStruct_interfaces(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitStruct_interfaces"):
                listener.exitStruct_interfaces(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitStruct_interfaces"):
                return visitor.visitStruct_interfaces(self)
            else:
                return visitor.visitChildren(self)

    def struct_interfaces(self):

        localctx = CSharpParser.Struct_interfacesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 316, self.RULE_struct_interfaces)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1993
            self.match(CSharpParser.COLON)
            self.state = 1994
            self.interface_type_list()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Struct_bodyContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPEN_BRACE(self):
            return self.getToken(CSharpParser.OPEN_BRACE, 0)

        def CLOSE_BRACE(self):
            return self.getToken(CSharpParser.CLOSE_BRACE, 0)

        def struct_member_declaration(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(CSharpParser.Struct_member_declarationContext)
            else:
                return self.getTypedRuleContext(CSharpParser.Struct_member_declarationContext, i)

        def getRuleIndex(self):
            return CSharpParser.RULE_struct_body

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterStruct_body"):
                listener.enterStruct_body(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitStruct_body"):
                listener.exitStruct_body(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitStruct_body"):
                return visitor.visitStruct_body(self)
            else:
                return visitor.visitChildren(self)

    def struct_body(self):

        localctx = CSharpParser.Struct_bodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 318, self.RULE_struct_body)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1996
            self.match(CSharpParser.OPEN_BRACE)
            self.state = 2000
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 9)) & ~0x3f) == 0 and ((1 << (_la - 9)) & (
                    (1 << (CSharpParser.ABSTRACT - 9)) | (1 << (CSharpParser.ADD - 9)) | (
                    1 << (CSharpParser.ALIAS - 9)) | (1 << (CSharpParser.ARGLIST - 9)) | (
                            1 << (CSharpParser.ASCENDING - 9)) | (1 << (CSharpParser.ASYNC - 9)) | (
                            1 << (CSharpParser.AWAIT - 9)) | (1 << (CSharpParser.BOOL - 9)) | (
                            1 << (CSharpParser.BY - 9)) | (1 << (CSharpParser.BYTE - 9)) | (
                            1 << (CSharpParser.CHAR - 9)) | (1 << (CSharpParser.CLASS - 9)) | (
                            1 << (CSharpParser.CONST - 9)) | (1 << (CSharpParser.DECIMAL - 9)) | (
                            1 << (CSharpParser.DELEGATE - 9)) | (1 << (CSharpParser.DESCENDING - 9)) | (
                            1 << (CSharpParser.DOUBLE - 9)) | (1 << (CSharpParser.DYNAMIC - 9)) | (
                            1 << (CSharpParser.ENUM - 9)) | (1 << (CSharpParser.EQUALS - 9)) | (
                            1 << (CSharpParser.EVENT - 9)) | (1 << (CSharpParser.EXPLICIT - 9)) | (
                            1 << (CSharpParser.EXTERN - 9)) | (1 << (CSharpParser.FIXED - 9)) | (
                            1 << (CSharpParser.FLOAT - 9)) | (1 << (CSharpParser.FROM - 9)) | (
                            1 << (CSharpParser.GET - 9)) | (1 << (CSharpParser.GROUP - 9)) | (
                            1 << (CSharpParser.IMPLICIT - 9)) | (1 << (CSharpParser.INT - 9)) | (
                            1 << (CSharpParser.INTERFACE - 9)) | (1 << (CSharpParser.INTERNAL - 9)) | (
                            1 << (CSharpParser.INTO - 9)) | (1 << (CSharpParser.JOIN - 9)) | (
                            1 << (CSharpParser.LET - 9)) | (1 << (CSharpParser.LONG - 9)) | (
                            1 << (CSharpParser.NAMEOF - 9)) | (1 << (CSharpParser.NEW - 9)) | (
                            1 << (CSharpParser.OBJECT - 9)) | (1 << (CSharpParser.ON - 9)) | (
                            1 << (CSharpParser.ORDERBY - 9)))) != 0) or ((((_la - 73)) & ~0x3f) == 0 and (
                    (1 << (_la - 73)) & ((1 << (CSharpParser.OVERRIDE - 73)) | (1 << (CSharpParser.PARTIAL - 73)) | (
                    1 << (CSharpParser.PRIVATE - 73)) | (1 << (CSharpParser.PROTECTED - 73)) | (
                                                 1 << (CSharpParser.PUBLIC - 73)) | (
                                                 1 << (CSharpParser.READONLY - 73)) | (1 << (CSharpParser.REF - 73)) | (
                                                 1 << (CSharpParser.REMOVE - 73)) | (1 << (CSharpParser.SBYTE - 73)) | (
                                                 1 << (CSharpParser.SEALED - 73)) | (
                                                 1 << (CSharpParser.SELECT - 73)) | (1 << (CSharpParser.SET - 73)) | (
                                                 1 << (CSharpParser.SHORT - 73)) | (1 << (CSharpParser.STATIC - 73)) | (
                                                 1 << (CSharpParser.STRING - 73)) | (
                                                 1 << (CSharpParser.STRUCT - 73)) | (1 << (CSharpParser.UINT - 73)) | (
                                                 1 << (CSharpParser.ULONG - 73)) | (
                                                 1 << (CSharpParser.UNMANAGED - 73)) | (
                                                 1 << (CSharpParser.UNSAFE - 73)) | (
                                                 1 << (CSharpParser.USHORT - 73)) | (1 << (CSharpParser.VAR - 73)) | (
                                                 1 << (CSharpParser.VIRTUAL - 73)) | (1 << (CSharpParser.VOID - 73)) | (
                                                 1 << (CSharpParser.VOLATILE - 73)) | (
                                                 1 << (CSharpParser.WHEN - 73)) | (1 << (CSharpParser.WHERE - 73)) | (
                                                 1 << (CSharpParser.YIELD - 73)) | (
                                                 1 << (CSharpParser.IDENTIFIER - 73)) | (
                                                 1 << (CSharpParser.OPEN_BRACKET - 73)) | (
                                                 1 << (CSharpParser.OPEN_PARENS - 73)))) != 0):
                self.state = 1997
                self.struct_member_declaration()
                self.state = 2002
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 2003
            self.match(CSharpParser.CLOSE_BRACE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Struct_member_declarationContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def common_member_declaration(self):
            return self.getTypedRuleContext(CSharpParser.Common_member_declarationContext, 0)

        def FIXED(self):
            return self.getToken(CSharpParser.FIXED, 0)

        def type_(self):
            return self.getTypedRuleContext(CSharpParser.Type_Context, 0)

        def SEMICOLON(self):
            return self.getToken(CSharpParser.SEMICOLON, 0)

        def attributes(self):
            return self.getTypedRuleContext(CSharpParser.AttributesContext, 0)

        def all_member_modifiers(self):
            return self.getTypedRuleContext(CSharpParser.All_member_modifiersContext, 0)

        def fixed_size_buffer_declarator(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(CSharpParser.Fixed_size_buffer_declaratorContext)
            else:
                return self.getTypedRuleContext(CSharpParser.Fixed_size_buffer_declaratorContext, i)

        def getRuleIndex(self):
            return CSharpParser.RULE_struct_member_declaration

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterStruct_member_declaration"):
                listener.enterStruct_member_declaration(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitStruct_member_declaration"):
                listener.exitStruct_member_declaration(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitStruct_member_declaration"):
                return visitor.visitStruct_member_declaration(self)
            else:
                return visitor.visitChildren(self)

    def struct_member_declaration(self):

        localctx = CSharpParser.Struct_member_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 320, self.RULE_struct_member_declaration)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2006
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == CSharpParser.OPEN_BRACKET:
                self.state = 2005
                self.attributes()

            self.state = 2009
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 237, self._ctx)
            if la_ == 1:
                self.state = 2008
                self.all_member_modifiers()

            self.state = 2021
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [CSharpParser.ADD, CSharpParser.ALIAS, CSharpParser.ARGLIST, CSharpParser.ASCENDING,
                         CSharpParser.ASYNC, CSharpParser.AWAIT, CSharpParser.BOOL, CSharpParser.BY, CSharpParser.BYTE,
                         CSharpParser.CHAR, CSharpParser.CLASS, CSharpParser.CONST, CSharpParser.DECIMAL,
                         CSharpParser.DELEGATE, CSharpParser.DESCENDING, CSharpParser.DOUBLE, CSharpParser.DYNAMIC,
                         CSharpParser.ENUM, CSharpParser.EQUALS, CSharpParser.EVENT, CSharpParser.EXPLICIT,
                         CSharpParser.FLOAT, CSharpParser.FROM, CSharpParser.GET, CSharpParser.GROUP,
                         CSharpParser.IMPLICIT, CSharpParser.INT, CSharpParser.INTERFACE, CSharpParser.INTO,
                         CSharpParser.JOIN, CSharpParser.LET, CSharpParser.LONG, CSharpParser.NAMEOF,
                         CSharpParser.OBJECT, CSharpParser.ON, CSharpParser.ORDERBY, CSharpParser.PARTIAL,
                         CSharpParser.READONLY, CSharpParser.REF, CSharpParser.REMOVE, CSharpParser.SBYTE,
                         CSharpParser.SELECT, CSharpParser.SET, CSharpParser.SHORT, CSharpParser.STRING,
                         CSharpParser.STRUCT, CSharpParser.UINT, CSharpParser.ULONG, CSharpParser.UNMANAGED,
                         CSharpParser.USHORT, CSharpParser.VAR, CSharpParser.VOID, CSharpParser.WHEN,
                         CSharpParser.WHERE, CSharpParser.YIELD, CSharpParser.IDENTIFIER, CSharpParser.OPEN_PARENS]:
                self.state = 2011
                self.common_member_declaration()
                pass
            elif token in [CSharpParser.FIXED]:
                self.state = 2012
                self.match(CSharpParser.FIXED)
                self.state = 2013
                self.type_()
                self.state = 2015
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 2014
                    self.fixed_size_buffer_declarator()
                    self.state = 2017
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & (
                            (1 << CSharpParser.ADD) | (1 << CSharpParser.ALIAS) | (1 << CSharpParser.ARGLIST) | (
                            1 << CSharpParser.ASCENDING) | (1 << CSharpParser.ASYNC) | (1 << CSharpParser.AWAIT) | (
                                    1 << CSharpParser.BY) | (1 << CSharpParser.DESCENDING) | (
                                    1 << CSharpParser.DYNAMIC) | (1 << CSharpParser.EQUALS) | (
                                    1 << CSharpParser.FROM) | (1 << CSharpParser.GET) | (1 << CSharpParser.GROUP) | (
                                    1 << CSharpParser.INTO) | (1 << CSharpParser.JOIN) | (
                                    1 << CSharpParser.LET))) != 0) or ((((_la - 64)) & ~0x3f) == 0 and (
                            (1 << (_la - 64)) & ((1 << (CSharpParser.NAMEOF - 64)) | (1 << (CSharpParser.ON - 64)) | (
                            1 << (CSharpParser.ORDERBY - 64)) | (1 << (CSharpParser.PARTIAL - 64)) | (
                                                         1 << (CSharpParser.REMOVE - 64)) | (
                                                         1 << (CSharpParser.SELECT - 64)) | (
                                                         1 << (CSharpParser.SET - 64)) | (
                                                         1 << (CSharpParser.UNMANAGED - 64)) | (
                                                         1 << (CSharpParser.VAR - 64)) | (
                                                         1 << (CSharpParser.WHEN - 64)) | (
                                                         1 << (CSharpParser.WHERE - 64)) | (
                                                         1 << (CSharpParser.YIELD - 64)) | (
                                                         1 << (CSharpParser.IDENTIFIER - 64)))) != 0)):
                        break

                self.state = 2019
                self.match(CSharpParser.SEMICOLON)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Array_typeContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def base_type(self):
            return self.getTypedRuleContext(CSharpParser.Base_typeContext, 0)

        def rank_specifier(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(CSharpParser.Rank_specifierContext)
            else:
                return self.getTypedRuleContext(CSharpParser.Rank_specifierContext, i)

        def STAR(self, i: int = None):
            if i is None:
                return self.getTokens(CSharpParser.STAR)
            else:
                return self.getToken(CSharpParser.STAR, i)

        def INTERR(self, i: int = None):
            if i is None:
                return self.getTokens(CSharpParser.INTERR)
            else:
                return self.getToken(CSharpParser.INTERR, i)

        def getRuleIndex(self):
            return CSharpParser.RULE_array_type

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterArray_type"):
                listener.enterArray_type(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitArray_type"):
                listener.exitArray_type(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitArray_type"):
                return visitor.visitArray_type(self)
            else:
                return visitor.visitChildren(self)

    def array_type(self):

        localctx = CSharpParser.Array_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 322, self.RULE_array_type)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2023
            self.base_type()
            self.state = 2031
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 2027
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la == CSharpParser.STAR or _la == CSharpParser.INTERR:
                    self.state = 2024
                    _la = self._input.LA(1)
                    if not (_la == CSharpParser.STAR or _la == CSharpParser.INTERR):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 2029
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 2030
                self.rank_specifier()
                self.state = 2033
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (((((_la - 127)) & ~0x3f) == 0 and ((1 << (_la - 127)) & (
                        (1 << (CSharpParser.OPEN_BRACKET - 127)) | (1 << (CSharpParser.STAR - 127)) | (
                        1 << (CSharpParser.INTERR - 127)))) != 0)):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Rank_specifierContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPEN_BRACKET(self):
            return self.getToken(CSharpParser.OPEN_BRACKET, 0)

        def CLOSE_BRACKET(self):
            return self.getToken(CSharpParser.CLOSE_BRACKET, 0)

        def COMMA(self, i: int = None):
            if i is None:
                return self.getTokens(CSharpParser.COMMA)
            else:
                return self.getToken(CSharpParser.COMMA, i)

        def getRuleIndex(self):
            return CSharpParser.RULE_rank_specifier

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterRank_specifier"):
                listener.enterRank_specifier(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitRank_specifier"):
                listener.exitRank_specifier(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitRank_specifier"):
                return visitor.visitRank_specifier(self)
            else:
                return visitor.visitChildren(self)

    def rank_specifier(self):

        localctx = CSharpParser.Rank_specifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 324, self.RULE_rank_specifier)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2035
            self.match(CSharpParser.OPEN_BRACKET)
            self.state = 2039
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == CSharpParser.COMMA:
                self.state = 2036
                self.match(CSharpParser.COMMA)
                self.state = 2041
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 2042
            self.match(CSharpParser.CLOSE_BRACKET)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Array_initializerContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPEN_BRACE(self):
            return self.getToken(CSharpParser.OPEN_BRACE, 0)

        def CLOSE_BRACE(self):
            return self.getToken(CSharpParser.CLOSE_BRACE, 0)

        def variable_initializer(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(CSharpParser.Variable_initializerContext)
            else:
                return self.getTypedRuleContext(CSharpParser.Variable_initializerContext, i)

        def COMMA(self, i: int = None):
            if i is None:
                return self.getTokens(CSharpParser.COMMA)
            else:
                return self.getToken(CSharpParser.COMMA, i)

        def getRuleIndex(self):
            return CSharpParser.RULE_array_initializer

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterArray_initializer"):
                listener.enterArray_initializer(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitArray_initializer"):
                listener.exitArray_initializer(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitArray_initializer"):
                return visitor.visitArray_initializer(self)
            else:
                return visitor.visitChildren(self)

    def array_initializer(self):

        localctx = CSharpParser.Array_initializerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 326, self.RULE_array_initializer)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2044
            self.match(CSharpParser.OPEN_BRACE)
            self.state = 2056
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & (
                    (1 << CSharpParser.ADD) | (1 << CSharpParser.ALIAS) | (1 << CSharpParser.ARGLIST) | (
                    1 << CSharpParser.ASCENDING) | (1 << CSharpParser.ASYNC) | (1 << CSharpParser.AWAIT) | (
                            1 << CSharpParser.BASE) | (1 << CSharpParser.BOOL) | (1 << CSharpParser.BY) | (
                            1 << CSharpParser.BYTE) | (1 << CSharpParser.CHAR) | (1 << CSharpParser.CHECKED) | (
                            1 << CSharpParser.DECIMAL) | (1 << CSharpParser.DEFAULT) | (1 << CSharpParser.DELEGATE) | (
                            1 << CSharpParser.DESCENDING) | (1 << CSharpParser.DOUBLE) | (1 << CSharpParser.DYNAMIC) | (
                            1 << CSharpParser.EQUALS) | (1 << CSharpParser.FALSE) | (1 << CSharpParser.FLOAT) | (
                            1 << CSharpParser.FROM) | (1 << CSharpParser.GET) | (1 << CSharpParser.GROUP) | (
                            1 << CSharpParser.INT) | (1 << CSharpParser.INTO) | (1 << CSharpParser.JOIN) | (
                            1 << CSharpParser.LET) | (1 << CSharpParser.LONG))) != 0) or (
                    (((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & (
                    (1 << (CSharpParser.NAMEOF - 64)) | (1 << (CSharpParser.NEW - 64)) | (
                    1 << (CSharpParser.NULL_ - 64)) | (1 << (CSharpParser.OBJECT - 64)) | (
                            1 << (CSharpParser.ON - 64)) | (1 << (CSharpParser.ORDERBY - 64)) | (
                            1 << (CSharpParser.PARTIAL - 64)) | (1 << (CSharpParser.REF - 64)) | (
                            1 << (CSharpParser.REMOVE - 64)) | (1 << (CSharpParser.SBYTE - 64)) | (
                            1 << (CSharpParser.SELECT - 64)) | (1 << (CSharpParser.SET - 64)) | (
                            1 << (CSharpParser.SHORT - 64)) | (1 << (CSharpParser.SIZEOF - 64)) | (
                            1 << (CSharpParser.STRING - 64)) | (1 << (CSharpParser.THIS - 64)) | (
                            1 << (CSharpParser.TRUE - 64)) | (1 << (CSharpParser.TYPEOF - 64)) | (
                            1 << (CSharpParser.UINT - 64)) | (1 << (CSharpParser.ULONG - 64)) | (
                            1 << (CSharpParser.UNCHECKED - 64)) | (1 << (CSharpParser.UNMANAGED - 64)) | (
                            1 << (CSharpParser.USHORT - 64)) | (1 << (CSharpParser.VAR - 64)) | (
                            1 << (CSharpParser.WHEN - 64)) | (1 << (CSharpParser.WHERE - 64)) | (
                            1 << (CSharpParser.YIELD - 64)) | (1 << (CSharpParser.IDENTIFIER - 64)) | (
                            1 << (CSharpParser.LITERAL_ACCESS - 64)) | (1 << (CSharpParser.INTEGER_LITERAL - 64)) | (
                            1 << (CSharpParser.HEX_INTEGER_LITERAL - 64)) | (
                            1 << (CSharpParser.BIN_INTEGER_LITERAL - 64)) | (1 << (CSharpParser.REAL_LITERAL - 64)) | (
                            1 << (CSharpParser.CHARACTER_LITERAL - 64)) | (1 << (CSharpParser.REGULAR_STRING - 64)) | (
                            1 << (CSharpParser.VERBATIUM_STRING - 64)) | (
                            1 << (CSharpParser.INTERPOLATED_REGULAR_STRING_START - 64)) | (
                            1 << (CSharpParser.INTERPOLATED_VERBATIUM_STRING_START - 64)) | (
                            1 << (CSharpParser.OPEN_BRACE - 64)))) != 0) or ((((_la - 129)) & ~0x3f) == 0 and (
                    (1 << (_la - 129)) & ((1 << (CSharpParser.OPEN_PARENS - 129)) | (1 << (CSharpParser.PLUS - 129)) | (
                    1 << (CSharpParser.MINUS - 129)) | (1 << (CSharpParser.STAR - 129)) | (
                                                  1 << (CSharpParser.AMP - 129)) | (1 << (CSharpParser.CARET - 129)) | (
                                                  1 << (CSharpParser.BANG - 129)) | (
                                                  1 << (CSharpParser.TILDE - 129)) | (
                                                  1 << (CSharpParser.OP_INC - 129)) | (
                                                  1 << (CSharpParser.OP_DEC - 129)) | (
                                                  1 << (CSharpParser.OP_RANGE - 129)))) != 0):
                self.state = 2045
                self.variable_initializer()
                self.state = 2050
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 243, self._ctx)
                while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 2046
                        self.match(CSharpParser.COMMA)
                        self.state = 2047
                        self.variable_initializer()
                    self.state = 2052
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input, 243, self._ctx)

                self.state = 2054
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == CSharpParser.COMMA:
                    self.state = 2053
                    self.match(CSharpParser.COMMA)

            self.state = 2058
            self.match(CSharpParser.CLOSE_BRACE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Variant_type_parameter_listContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LT(self):
            return self.getToken(CSharpParser.LT, 0)

        def variant_type_parameter(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(CSharpParser.Variant_type_parameterContext)
            else:
                return self.getTypedRuleContext(CSharpParser.Variant_type_parameterContext, i)

        def GT(self):
            return self.getToken(CSharpParser.GT, 0)

        def COMMA(self, i: int = None):
            if i is None:
                return self.getTokens(CSharpParser.COMMA)
            else:
                return self.getToken(CSharpParser.COMMA, i)

        def getRuleIndex(self):
            return CSharpParser.RULE_variant_type_parameter_list

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterVariant_type_parameter_list"):
                listener.enterVariant_type_parameter_list(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitVariant_type_parameter_list"):
                listener.exitVariant_type_parameter_list(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitVariant_type_parameter_list"):
                return visitor.visitVariant_type_parameter_list(self)
            else:
                return visitor.visitChildren(self)

    def variant_type_parameter_list(self):

        localctx = CSharpParser.Variant_type_parameter_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 328, self.RULE_variant_type_parameter_list)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2060
            self.match(CSharpParser.LT)
            self.state = 2061
            self.variant_type_parameter()
            self.state = 2066
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == CSharpParser.COMMA:
                self.state = 2062
                self.match(CSharpParser.COMMA)
                self.state = 2063
                self.variant_type_parameter()
                self.state = 2068
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 2069
            self.match(CSharpParser.GT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Variant_type_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(CSharpParser.IdentifierContext, 0)

        def attributes(self):
            return self.getTypedRuleContext(CSharpParser.AttributesContext, 0)

        def variance_annotation(self):
            return self.getTypedRuleContext(CSharpParser.Variance_annotationContext, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_variant_type_parameter

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterVariant_type_parameter"):
                listener.enterVariant_type_parameter(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitVariant_type_parameter"):
                listener.exitVariant_type_parameter(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitVariant_type_parameter"):
                return visitor.visitVariant_type_parameter(self)
            else:
                return visitor.visitChildren(self)

    def variant_type_parameter(self):

        localctx = CSharpParser.Variant_type_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 330, self.RULE_variant_type_parameter)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2072
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == CSharpParser.OPEN_BRACKET:
                self.state = 2071
                self.attributes()

            self.state = 2075
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == CSharpParser.IN or _la == CSharpParser.OUT:
                self.state = 2074
                self.variance_annotation()

            self.state = 2077
            self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Variance_annotationContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IN(self):
            return self.getToken(CSharpParser.IN, 0)

        def OUT(self):
            return self.getToken(CSharpParser.OUT, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_variance_annotation

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterVariance_annotation"):
                listener.enterVariance_annotation(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitVariance_annotation"):
                listener.exitVariance_annotation(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitVariance_annotation"):
                return visitor.visitVariance_annotation(self)
            else:
                return visitor.visitChildren(self)

    def variance_annotation(self):

        localctx = CSharpParser.Variance_annotationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 332, self.RULE_variance_annotation)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2079
            _la = self._input.LA(1)
            if not (_la == CSharpParser.IN or _la == CSharpParser.OUT):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Interface_baseContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COLON(self):
            return self.getToken(CSharpParser.COLON, 0)

        def interface_type_list(self):
            return self.getTypedRuleContext(CSharpParser.Interface_type_listContext, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_interface_base

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterInterface_base"):
                listener.enterInterface_base(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitInterface_base"):
                listener.exitInterface_base(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitInterface_base"):
                return visitor.visitInterface_base(self)
            else:
                return visitor.visitChildren(self)

    def interface_base(self):

        localctx = CSharpParser.Interface_baseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 334, self.RULE_interface_base)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2081
            self.match(CSharpParser.COLON)
            self.state = 2082
            self.interface_type_list()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Interface_bodyContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPEN_BRACE(self):
            return self.getToken(CSharpParser.OPEN_BRACE, 0)

        def CLOSE_BRACE(self):
            return self.getToken(CSharpParser.CLOSE_BRACE, 0)

        def interface_member_declaration(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(CSharpParser.Interface_member_declarationContext)
            else:
                return self.getTypedRuleContext(CSharpParser.Interface_member_declarationContext, i)

        def getRuleIndex(self):
            return CSharpParser.RULE_interface_body

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterInterface_body"):
                listener.enterInterface_body(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitInterface_body"):
                listener.exitInterface_body(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitInterface_body"):
                return visitor.visitInterface_body(self)
            else:
                return visitor.visitChildren(self)

    def interface_body(self):

        localctx = CSharpParser.Interface_bodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 336, self.RULE_interface_body)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2084
            self.match(CSharpParser.OPEN_BRACE)
            self.state = 2088
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 10)) & ~0x3f) == 0 and ((1 << (_la - 10)) & (
                    (1 << (CSharpParser.ADD - 10)) | (1 << (CSharpParser.ALIAS - 10)) | (
                    1 << (CSharpParser.ARGLIST - 10)) | (1 << (CSharpParser.ASCENDING - 10)) | (
                            1 << (CSharpParser.ASYNC - 10)) | (1 << (CSharpParser.AWAIT - 10)) | (
                            1 << (CSharpParser.BOOL - 10)) | (1 << (CSharpParser.BY - 10)) | (
                            1 << (CSharpParser.BYTE - 10)) | (1 << (CSharpParser.CHAR - 10)) | (
                            1 << (CSharpParser.DECIMAL - 10)) | (1 << (CSharpParser.DESCENDING - 10)) | (
                            1 << (CSharpParser.DOUBLE - 10)) | (1 << (CSharpParser.DYNAMIC - 10)) | (
                            1 << (CSharpParser.EQUALS - 10)) | (1 << (CSharpParser.EVENT - 10)) | (
                            1 << (CSharpParser.FLOAT - 10)) | (1 << (CSharpParser.FROM - 10)) | (
                            1 << (CSharpParser.GET - 10)) | (1 << (CSharpParser.GROUP - 10)) | (
                            1 << (CSharpParser.INT - 10)) | (1 << (CSharpParser.INTO - 10)) | (
                            1 << (CSharpParser.JOIN - 10)) | (1 << (CSharpParser.LET - 10)) | (
                            1 << (CSharpParser.LONG - 10)) | (1 << (CSharpParser.NAMEOF - 10)) | (
                            1 << (CSharpParser.NEW - 10)) | (1 << (CSharpParser.OBJECT - 10)) | (
                            1 << (CSharpParser.ON - 10)) | (1 << (CSharpParser.ORDERBY - 10)))) != 0) or (
                    (((_la - 75)) & ~0x3f) == 0 and ((1 << (_la - 75)) & (
                    (1 << (CSharpParser.PARTIAL - 75)) | (1 << (CSharpParser.READONLY - 75)) | (
                    1 << (CSharpParser.REF - 75)) | (1 << (CSharpParser.REMOVE - 75)) | (
                            1 << (CSharpParser.SBYTE - 75)) | (1 << (CSharpParser.SELECT - 75)) | (
                            1 << (CSharpParser.SET - 75)) | (1 << (CSharpParser.SHORT - 75)) | (
                            1 << (CSharpParser.STRING - 75)) | (1 << (CSharpParser.UINT - 75)) | (
                            1 << (CSharpParser.ULONG - 75)) | (1 << (CSharpParser.UNMANAGED - 75)) | (
                            1 << (CSharpParser.UNSAFE - 75)) | (1 << (CSharpParser.USHORT - 75)) | (
                            1 << (CSharpParser.VAR - 75)) | (1 << (CSharpParser.VOID - 75)) | (
                            1 << (CSharpParser.WHEN - 75)) | (1 << (CSharpParser.WHERE - 75)) | (
                            1 << (CSharpParser.YIELD - 75)) | (1 << (CSharpParser.IDENTIFIER - 75)) | (
                            1 << (CSharpParser.OPEN_BRACKET - 75)) | (1 << (CSharpParser.OPEN_PARENS - 75)))) != 0):
                self.state = 2085
                self.interface_member_declaration()
                self.state = 2090
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 2091
            self.match(CSharpParser.CLOSE_BRACE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Interface_member_declarationContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def type_(self):
            return self.getTypedRuleContext(CSharpParser.Type_Context, 0)

        def VOID(self):
            return self.getToken(CSharpParser.VOID, 0)

        def identifier(self):
            return self.getTypedRuleContext(CSharpParser.IdentifierContext, 0)

        def OPEN_PARENS(self):
            return self.getToken(CSharpParser.OPEN_PARENS, 0)

        def CLOSE_PARENS(self):
            return self.getToken(CSharpParser.CLOSE_PARENS, 0)

        def SEMICOLON(self):
            return self.getToken(CSharpParser.SEMICOLON, 0)

        def EVENT(self):
            return self.getToken(CSharpParser.EVENT, 0)

        def attributes(self):
            return self.getTypedRuleContext(CSharpParser.AttributesContext, 0)

        def NEW(self):
            return self.getToken(CSharpParser.NEW, 0)

        def OPEN_BRACE(self):
            return self.getToken(CSharpParser.OPEN_BRACE, 0)

        def interface_accessors(self):
            return self.getTypedRuleContext(CSharpParser.Interface_accessorsContext, 0)

        def CLOSE_BRACE(self):
            return self.getToken(CSharpParser.CLOSE_BRACE, 0)

        def THIS(self):
            return self.getToken(CSharpParser.THIS, 0)

        def OPEN_BRACKET(self):
            return self.getToken(CSharpParser.OPEN_BRACKET, 0)

        def formal_parameter_list(self):
            return self.getTypedRuleContext(CSharpParser.Formal_parameter_listContext, 0)

        def CLOSE_BRACKET(self):
            return self.getToken(CSharpParser.CLOSE_BRACKET, 0)

        def UNSAFE(self):
            return self.getToken(CSharpParser.UNSAFE, 0)

        def REF(self):
            return self.getToken(CSharpParser.REF, 0)

        def READONLY(self):
            return self.getToken(CSharpParser.READONLY, 0)

        def type_parameter_list(self):
            return self.getTypedRuleContext(CSharpParser.Type_parameter_listContext, 0)

        def type_parameter_constraints_clauses(self):
            return self.getTypedRuleContext(CSharpParser.Type_parameter_constraints_clausesContext, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_interface_member_declaration

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterInterface_member_declaration"):
                listener.enterInterface_member_declaration(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitInterface_member_declaration"):
                listener.exitInterface_member_declaration(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitInterface_member_declaration"):
                return visitor.visitInterface_member_declaration(self)
            else:
                return visitor.visitChildren(self)

    def interface_member_declaration(self):

        localctx = CSharpParser.Interface_member_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 338, self.RULE_interface_member_declaration)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2094
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == CSharpParser.OPEN_BRACKET:
                self.state = 2093
                self.attributes()

            self.state = 2097
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == CSharpParser.NEW:
                self.state = 2096
                self.match(CSharpParser.NEW)

            self.state = 2162
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 262, self._ctx)
            if la_ == 1:
                self.state = 2100
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == CSharpParser.UNSAFE:
                    self.state = 2099
                    self.match(CSharpParser.UNSAFE)

                self.state = 2107
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input, 253, self._ctx)
                if la_ == 1:
                    self.state = 2102
                    self.match(CSharpParser.REF)

                elif la_ == 2:
                    self.state = 2103
                    self.match(CSharpParser.REF)
                    self.state = 2104
                    self.match(CSharpParser.READONLY)

                elif la_ == 3:
                    self.state = 2105
                    self.match(CSharpParser.READONLY)
                    self.state = 2106
                    self.match(CSharpParser.REF)

                self.state = 2109
                self.type_()
                self.state = 2137
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input, 257, self._ctx)
                if la_ == 1:
                    self.state = 2110
                    self.identifier()
                    self.state = 2112
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la == CSharpParser.LT:
                        self.state = 2111
                        self.type_parameter_list()

                    self.state = 2114
                    self.match(CSharpParser.OPEN_PARENS)
                    self.state = 2116
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if ((((_la - 10)) & ~0x3f) == 0 and ((1 << (_la - 10)) & (
                            (1 << (CSharpParser.ADD - 10)) | (1 << (CSharpParser.ALIAS - 10)) | (
                            1 << (CSharpParser.ARGLIST - 10)) | (1 << (CSharpParser.ASCENDING - 10)) | (
                                    1 << (CSharpParser.ASYNC - 10)) | (1 << (CSharpParser.AWAIT - 10)) | (
                                    1 << (CSharpParser.BOOL - 10)) | (1 << (CSharpParser.BY - 10)) | (
                                    1 << (CSharpParser.BYTE - 10)) | (1 << (CSharpParser.CHAR - 10)) | (
                                    1 << (CSharpParser.DECIMAL - 10)) | (1 << (CSharpParser.DESCENDING - 10)) | (
                                    1 << (CSharpParser.DOUBLE - 10)) | (1 << (CSharpParser.DYNAMIC - 10)) | (
                                    1 << (CSharpParser.EQUALS - 10)) | (1 << (CSharpParser.FLOAT - 10)) | (
                                    1 << (CSharpParser.FROM - 10)) | (1 << (CSharpParser.GET - 10)) | (
                                    1 << (CSharpParser.GROUP - 10)) | (1 << (CSharpParser.IN - 10)) | (
                                    1 << (CSharpParser.INT - 10)) | (1 << (CSharpParser.INTO - 10)) | (
                                    1 << (CSharpParser.JOIN - 10)) | (1 << (CSharpParser.LET - 10)) | (
                                    1 << (CSharpParser.LONG - 10)) | (1 << (CSharpParser.NAMEOF - 10)) | (
                                    1 << (CSharpParser.OBJECT - 10)) | (1 << (CSharpParser.ON - 10)) | (
                                    1 << (CSharpParser.ORDERBY - 10)) | (1 << (CSharpParser.OUT - 10)))) != 0) or (
                            (((_la - 74)) & ~0x3f) == 0 and ((1 << (_la - 74)) & (
                            (1 << (CSharpParser.PARAMS - 74)) | (1 << (CSharpParser.PARTIAL - 74)) | (
                            1 << (CSharpParser.REF - 74)) | (1 << (CSharpParser.REMOVE - 74)) | (
                                    1 << (CSharpParser.SBYTE - 74)) | (1 << (CSharpParser.SELECT - 74)) | (
                                    1 << (CSharpParser.SET - 74)) | (1 << (CSharpParser.SHORT - 74)) | (
                                    1 << (CSharpParser.STRING - 74)) | (1 << (CSharpParser.THIS - 74)) | (
                                    1 << (CSharpParser.UINT - 74)) | (1 << (CSharpParser.ULONG - 74)) | (
                                    1 << (CSharpParser.UNMANAGED - 74)) | (1 << (CSharpParser.USHORT - 74)) | (
                                    1 << (CSharpParser.VAR - 74)) | (1 << (CSharpParser.VOID - 74)) | (
                                    1 << (CSharpParser.WHEN - 74)) | (1 << (CSharpParser.WHERE - 74)) | (
                                    1 << (CSharpParser.YIELD - 74)) | (1 << (CSharpParser.IDENTIFIER - 74)) | (
                                    1 << (CSharpParser.OPEN_BRACKET - 74)) | (
                                    1 << (CSharpParser.OPEN_PARENS - 74)))) != 0):
                        self.state = 2115
                        self.formal_parameter_list()

                    self.state = 2118
                    self.match(CSharpParser.CLOSE_PARENS)
                    self.state = 2120
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la == CSharpParser.WHERE:
                        self.state = 2119
                        self.type_parameter_constraints_clauses()

                    self.state = 2122
                    self.match(CSharpParser.SEMICOLON)
                    pass

                elif la_ == 2:
                    self.state = 2124
                    self.identifier()
                    self.state = 2125
                    self.match(CSharpParser.OPEN_BRACE)
                    self.state = 2126
                    self.interface_accessors()
                    self.state = 2127
                    self.match(CSharpParser.CLOSE_BRACE)
                    pass

                elif la_ == 3:
                    self.state = 2129
                    self.match(CSharpParser.THIS)
                    self.state = 2130
                    self.match(CSharpParser.OPEN_BRACKET)
                    self.state = 2131
                    self.formal_parameter_list()
                    self.state = 2132
                    self.match(CSharpParser.CLOSE_BRACKET)
                    self.state = 2133
                    self.match(CSharpParser.OPEN_BRACE)
                    self.state = 2134
                    self.interface_accessors()
                    self.state = 2135
                    self.match(CSharpParser.CLOSE_BRACE)
                    pass

                pass

            elif la_ == 2:
                self.state = 2140
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == CSharpParser.UNSAFE:
                    self.state = 2139
                    self.match(CSharpParser.UNSAFE)

                self.state = 2142
                self.match(CSharpParser.VOID)
                self.state = 2143
                self.identifier()
                self.state = 2145
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == CSharpParser.LT:
                    self.state = 2144
                    self.type_parameter_list()

                self.state = 2147
                self.match(CSharpParser.OPEN_PARENS)
                self.state = 2149
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 10)) & ~0x3f) == 0 and ((1 << (_la - 10)) & (
                        (1 << (CSharpParser.ADD - 10)) | (1 << (CSharpParser.ALIAS - 10)) | (
                        1 << (CSharpParser.ARGLIST - 10)) | (1 << (CSharpParser.ASCENDING - 10)) | (
                                1 << (CSharpParser.ASYNC - 10)) | (1 << (CSharpParser.AWAIT - 10)) | (
                                1 << (CSharpParser.BOOL - 10)) | (1 << (CSharpParser.BY - 10)) | (
                                1 << (CSharpParser.BYTE - 10)) | (1 << (CSharpParser.CHAR - 10)) | (
                                1 << (CSharpParser.DECIMAL - 10)) | (1 << (CSharpParser.DESCENDING - 10)) | (
                                1 << (CSharpParser.DOUBLE - 10)) | (1 << (CSharpParser.DYNAMIC - 10)) | (
                                1 << (CSharpParser.EQUALS - 10)) | (1 << (CSharpParser.FLOAT - 10)) | (
                                1 << (CSharpParser.FROM - 10)) | (1 << (CSharpParser.GET - 10)) | (
                                1 << (CSharpParser.GROUP - 10)) | (1 << (CSharpParser.IN - 10)) | (
                                1 << (CSharpParser.INT - 10)) | (1 << (CSharpParser.INTO - 10)) | (
                                1 << (CSharpParser.JOIN - 10)) | (1 << (CSharpParser.LET - 10)) | (
                                1 << (CSharpParser.LONG - 10)) | (1 << (CSharpParser.NAMEOF - 10)) | (
                                1 << (CSharpParser.OBJECT - 10)) | (1 << (CSharpParser.ON - 10)) | (
                                1 << (CSharpParser.ORDERBY - 10)) | (1 << (CSharpParser.OUT - 10)))) != 0) or (
                        (((_la - 74)) & ~0x3f) == 0 and ((1 << (_la - 74)) & (
                        (1 << (CSharpParser.PARAMS - 74)) | (1 << (CSharpParser.PARTIAL - 74)) | (
                        1 << (CSharpParser.REF - 74)) | (1 << (CSharpParser.REMOVE - 74)) | (
                                1 << (CSharpParser.SBYTE - 74)) | (1 << (CSharpParser.SELECT - 74)) | (
                                1 << (CSharpParser.SET - 74)) | (1 << (CSharpParser.SHORT - 74)) | (
                                1 << (CSharpParser.STRING - 74)) | (1 << (CSharpParser.THIS - 74)) | (
                                1 << (CSharpParser.UINT - 74)) | (1 << (CSharpParser.ULONG - 74)) | (
                                1 << (CSharpParser.UNMANAGED - 74)) | (1 << (CSharpParser.USHORT - 74)) | (
                                1 << (CSharpParser.VAR - 74)) | (1 << (CSharpParser.VOID - 74)) | (
                                1 << (CSharpParser.WHEN - 74)) | (1 << (CSharpParser.WHERE - 74)) | (
                                1 << (CSharpParser.YIELD - 74)) | (1 << (CSharpParser.IDENTIFIER - 74)) | (
                                1 << (CSharpParser.OPEN_BRACKET - 74)) | (1 << (CSharpParser.OPEN_PARENS - 74)))) != 0):
                    self.state = 2148
                    self.formal_parameter_list()

                self.state = 2151
                self.match(CSharpParser.CLOSE_PARENS)
                self.state = 2153
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == CSharpParser.WHERE:
                    self.state = 2152
                    self.type_parameter_constraints_clauses()

                self.state = 2155
                self.match(CSharpParser.SEMICOLON)
                pass

            elif la_ == 3:
                self.state = 2157
                self.match(CSharpParser.EVENT)
                self.state = 2158
                self.type_()
                self.state = 2159
                self.identifier()
                self.state = 2160
                self.match(CSharpParser.SEMICOLON)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Interface_accessorsContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GET(self):
            return self.getToken(CSharpParser.GET, 0)

        def SEMICOLON(self, i: int = None):
            if i is None:
                return self.getTokens(CSharpParser.SEMICOLON)
            else:
                return self.getToken(CSharpParser.SEMICOLON, i)

        def SET(self):
            return self.getToken(CSharpParser.SET, 0)

        def attributes(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(CSharpParser.AttributesContext)
            else:
                return self.getTypedRuleContext(CSharpParser.AttributesContext, i)

        def getRuleIndex(self):
            return CSharpParser.RULE_interface_accessors

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterInterface_accessors"):
                listener.enterInterface_accessors(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitInterface_accessors"):
                listener.exitInterface_accessors(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitInterface_accessors"):
                return visitor.visitInterface_accessors(self)
            else:
                return visitor.visitChildren(self)

    def interface_accessors(self):

        localctx = CSharpParser.Interface_accessorsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 340, self.RULE_interface_accessors)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2165
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == CSharpParser.OPEN_BRACKET:
                self.state = 2164
                self.attributes()

            self.state = 2185
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [CSharpParser.GET]:
                self.state = 2167
                self.match(CSharpParser.GET)
                self.state = 2168
                self.match(CSharpParser.SEMICOLON)
                self.state = 2174
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == CSharpParser.SET or _la == CSharpParser.OPEN_BRACKET:
                    self.state = 2170
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la == CSharpParser.OPEN_BRACKET:
                        self.state = 2169
                        self.attributes()

                    self.state = 2172
                    self.match(CSharpParser.SET)
                    self.state = 2173
                    self.match(CSharpParser.SEMICOLON)

                pass
            elif token in [CSharpParser.SET]:
                self.state = 2176
                self.match(CSharpParser.SET)
                self.state = 2177
                self.match(CSharpParser.SEMICOLON)
                self.state = 2183
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == CSharpParser.GET or _la == CSharpParser.OPEN_BRACKET:
                    self.state = 2179
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la == CSharpParser.OPEN_BRACKET:
                        self.state = 2178
                        self.attributes()

                    self.state = 2181
                    self.match(CSharpParser.GET)
                    self.state = 2182
                    self.match(CSharpParser.SEMICOLON)

                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Enum_baseContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COLON(self):
            return self.getToken(CSharpParser.COLON, 0)

        def type_(self):
            return self.getTypedRuleContext(CSharpParser.Type_Context, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_enum_base

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterEnum_base"):
                listener.enterEnum_base(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitEnum_base"):
                listener.exitEnum_base(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitEnum_base"):
                return visitor.visitEnum_base(self)
            else:
                return visitor.visitChildren(self)

    def enum_base(self):

        localctx = CSharpParser.Enum_baseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 342, self.RULE_enum_base)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2187
            self.match(CSharpParser.COLON)
            self.state = 2188
            self.type_()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Enum_bodyContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPEN_BRACE(self):
            return self.getToken(CSharpParser.OPEN_BRACE, 0)

        def CLOSE_BRACE(self):
            return self.getToken(CSharpParser.CLOSE_BRACE, 0)

        def enum_member_declaration(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(CSharpParser.Enum_member_declarationContext)
            else:
                return self.getTypedRuleContext(CSharpParser.Enum_member_declarationContext, i)

        def COMMA(self, i: int = None):
            if i is None:
                return self.getTokens(CSharpParser.COMMA)
            else:
                return self.getToken(CSharpParser.COMMA, i)

        def getRuleIndex(self):
            return CSharpParser.RULE_enum_body

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterEnum_body"):
                listener.enterEnum_body(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitEnum_body"):
                listener.exitEnum_body(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitEnum_body"):
                return visitor.visitEnum_body(self)
            else:
                return visitor.visitChildren(self)

    def enum_body(self):

        localctx = CSharpParser.Enum_bodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 344, self.RULE_enum_body)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2190
            self.match(CSharpParser.OPEN_BRACE)
            self.state = 2202
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & (
                    (1 << CSharpParser.ADD) | (1 << CSharpParser.ALIAS) | (1 << CSharpParser.ARGLIST) | (
                    1 << CSharpParser.ASCENDING) | (1 << CSharpParser.ASYNC) | (1 << CSharpParser.AWAIT) | (
                            1 << CSharpParser.BY) | (1 << CSharpParser.DESCENDING) | (1 << CSharpParser.DYNAMIC) | (
                            1 << CSharpParser.EQUALS) | (1 << CSharpParser.FROM) | (1 << CSharpParser.GET) | (
                            1 << CSharpParser.GROUP) | (1 << CSharpParser.INTO) | (1 << CSharpParser.JOIN) | (
                            1 << CSharpParser.LET))) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & (
                    (1 << (CSharpParser.NAMEOF - 64)) | (1 << (CSharpParser.ON - 64)) | (
                    1 << (CSharpParser.ORDERBY - 64)) | (1 << (CSharpParser.PARTIAL - 64)) | (
                            1 << (CSharpParser.REMOVE - 64)) | (1 << (CSharpParser.SELECT - 64)) | (
                            1 << (CSharpParser.SET - 64)) | (1 << (CSharpParser.UNMANAGED - 64)) | (
                            1 << (CSharpParser.VAR - 64)) | (1 << (CSharpParser.WHEN - 64)) | (
                            1 << (CSharpParser.WHERE - 64)) | (1 << (CSharpParser.YIELD - 64)) | (
                            1 << (CSharpParser.IDENTIFIER - 64)) | (1 << (CSharpParser.OPEN_BRACKET - 64)))) != 0):
                self.state = 2191
                self.enum_member_declaration()
                self.state = 2196
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 269, self._ctx)
                while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 2192
                        self.match(CSharpParser.COMMA)
                        self.state = 2193
                        self.enum_member_declaration()
                    self.state = 2198
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input, 269, self._ctx)

                self.state = 2200
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == CSharpParser.COMMA:
                    self.state = 2199
                    self.match(CSharpParser.COMMA)

            self.state = 2204
            self.match(CSharpParser.CLOSE_BRACE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Enum_member_declarationContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(CSharpParser.IdentifierContext, 0)

        def attributes(self):
            return self.getTypedRuleContext(CSharpParser.AttributesContext, 0)

        def ASSIGNMENT(self):
            return self.getToken(CSharpParser.ASSIGNMENT, 0)

        def expression(self):
            return self.getTypedRuleContext(CSharpParser.ExpressionContext, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_enum_member_declaration

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterEnum_member_declaration"):
                listener.enterEnum_member_declaration(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitEnum_member_declaration"):
                listener.exitEnum_member_declaration(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitEnum_member_declaration"):
                return visitor.visitEnum_member_declaration(self)
            else:
                return visitor.visitChildren(self)

    def enum_member_declaration(self):

        localctx = CSharpParser.Enum_member_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 346, self.RULE_enum_member_declaration)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2207
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == CSharpParser.OPEN_BRACKET:
                self.state = 2206
                self.attributes()

            self.state = 2209
            self.identifier()
            self.state = 2212
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == CSharpParser.ASSIGNMENT:
                self.state = 2210
                self.match(CSharpParser.ASSIGNMENT)
                self.state = 2211
                self.expression()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Global_attribute_sectionContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPEN_BRACKET(self):
            return self.getToken(CSharpParser.OPEN_BRACKET, 0)

        def global_attribute_target(self):
            return self.getTypedRuleContext(CSharpParser.Global_attribute_targetContext, 0)

        def COLON(self):
            return self.getToken(CSharpParser.COLON, 0)

        def attribute_list(self):
            return self.getTypedRuleContext(CSharpParser.Attribute_listContext, 0)

        def CLOSE_BRACKET(self):
            return self.getToken(CSharpParser.CLOSE_BRACKET, 0)

        def COMMA(self):
            return self.getToken(CSharpParser.COMMA, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_global_attribute_section

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterGlobal_attribute_section"):
                listener.enterGlobal_attribute_section(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitGlobal_attribute_section"):
                listener.exitGlobal_attribute_section(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitGlobal_attribute_section"):
                return visitor.visitGlobal_attribute_section(self)
            else:
                return visitor.visitChildren(self)

    def global_attribute_section(self):

        localctx = CSharpParser.Global_attribute_sectionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 348, self.RULE_global_attribute_section)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2214
            self.match(CSharpParser.OPEN_BRACKET)
            self.state = 2215
            self.global_attribute_target()
            self.state = 2216
            self.match(CSharpParser.COLON)
            self.state = 2217
            self.attribute_list()
            self.state = 2219
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == CSharpParser.COMMA:
                self.state = 2218
                self.match(CSharpParser.COMMA)

            self.state = 2221
            self.match(CSharpParser.CLOSE_BRACKET)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Global_attribute_targetContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def keyword(self):
            return self.getTypedRuleContext(CSharpParser.KeywordContext, 0)

        def identifier(self):
            return self.getTypedRuleContext(CSharpParser.IdentifierContext, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_global_attribute_target

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterGlobal_attribute_target"):
                listener.enterGlobal_attribute_target(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitGlobal_attribute_target"):
                listener.exitGlobal_attribute_target(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitGlobal_attribute_target"):
                return visitor.visitGlobal_attribute_target(self)
            else:
                return visitor.visitChildren(self)

    def global_attribute_target(self):

        localctx = CSharpParser.Global_attribute_targetContext(self, self._ctx, self.state)
        self.enterRule(localctx, 350, self.RULE_global_attribute_target)
        try:
            self.state = 2225
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 275, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 2223
                self.keyword()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 2224
                self.identifier()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AttributesContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def attribute_section(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(CSharpParser.Attribute_sectionContext)
            else:
                return self.getTypedRuleContext(CSharpParser.Attribute_sectionContext, i)

        def getRuleIndex(self):
            return CSharpParser.RULE_attributes

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterAttributes"):
                listener.enterAttributes(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitAttributes"):
                listener.exitAttributes(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitAttributes"):
                return visitor.visitAttributes(self)
            else:
                return visitor.visitChildren(self)

    def attributes(self):

        localctx = CSharpParser.AttributesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 352, self.RULE_attributes)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2228
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 2227
                self.attribute_section()
                self.state = 2230
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la == CSharpParser.OPEN_BRACKET):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Attribute_sectionContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPEN_BRACKET(self):
            return self.getToken(CSharpParser.OPEN_BRACKET, 0)

        def attribute_list(self):
            return self.getTypedRuleContext(CSharpParser.Attribute_listContext, 0)

        def CLOSE_BRACKET(self):
            return self.getToken(CSharpParser.CLOSE_BRACKET, 0)

        def attribute_target(self):
            return self.getTypedRuleContext(CSharpParser.Attribute_targetContext, 0)

        def COLON(self):
            return self.getToken(CSharpParser.COLON, 0)

        def COMMA(self):
            return self.getToken(CSharpParser.COMMA, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_attribute_section

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterAttribute_section"):
                listener.enterAttribute_section(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitAttribute_section"):
                listener.exitAttribute_section(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitAttribute_section"):
                return visitor.visitAttribute_section(self)
            else:
                return visitor.visitChildren(self)

    def attribute_section(self):

        localctx = CSharpParser.Attribute_sectionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 354, self.RULE_attribute_section)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2232
            self.match(CSharpParser.OPEN_BRACKET)
            self.state = 2236
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 277, self._ctx)
            if la_ == 1:
                self.state = 2233
                self.attribute_target()
                self.state = 2234
                self.match(CSharpParser.COLON)

            self.state = 2238
            self.attribute_list()
            self.state = 2240
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == CSharpParser.COMMA:
                self.state = 2239
                self.match(CSharpParser.COMMA)

            self.state = 2242
            self.match(CSharpParser.CLOSE_BRACKET)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Attribute_targetContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def keyword(self):
            return self.getTypedRuleContext(CSharpParser.KeywordContext, 0)

        def identifier(self):
            return self.getTypedRuleContext(CSharpParser.IdentifierContext, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_attribute_target

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterAttribute_target"):
                listener.enterAttribute_target(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitAttribute_target"):
                listener.exitAttribute_target(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitAttribute_target"):
                return visitor.visitAttribute_target(self)
            else:
                return visitor.visitChildren(self)

    def attribute_target(self):

        localctx = CSharpParser.Attribute_targetContext(self, self._ctx, self.state)
        self.enterRule(localctx, 356, self.RULE_attribute_target)
        try:
            self.state = 2246
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 279, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 2244
                self.keyword()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 2245
                self.identifier()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Attribute_listContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def attribute(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(CSharpParser.AttributeContext)
            else:
                return self.getTypedRuleContext(CSharpParser.AttributeContext, i)

        def COMMA(self, i: int = None):
            if i is None:
                return self.getTokens(CSharpParser.COMMA)
            else:
                return self.getToken(CSharpParser.COMMA, i)

        def getRuleIndex(self):
            return CSharpParser.RULE_attribute_list

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterAttribute_list"):
                listener.enterAttribute_list(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitAttribute_list"):
                listener.exitAttribute_list(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitAttribute_list"):
                return visitor.visitAttribute_list(self)
            else:
                return visitor.visitChildren(self)

    def attribute_list(self):

        localctx = CSharpParser.Attribute_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 358, self.RULE_attribute_list)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2248
            self.attribute()
            self.state = 2253
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input, 280, self._ctx)
            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 2249
                    self.match(CSharpParser.COMMA)
                    self.state = 2250
                    self.attribute()
                self.state = 2255
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 280, self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AttributeContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def namespace_or_type_name(self):
            return self.getTypedRuleContext(CSharpParser.Namespace_or_type_nameContext, 0)

        def OPEN_PARENS(self):
            return self.getToken(CSharpParser.OPEN_PARENS, 0)

        def CLOSE_PARENS(self):
            return self.getToken(CSharpParser.CLOSE_PARENS, 0)

        def attribute_argument(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(CSharpParser.Attribute_argumentContext)
            else:
                return self.getTypedRuleContext(CSharpParser.Attribute_argumentContext, i)

        def COMMA(self, i: int = None):
            if i is None:
                return self.getTokens(CSharpParser.COMMA)
            else:
                return self.getToken(CSharpParser.COMMA, i)

        def getRuleIndex(self):
            return CSharpParser.RULE_attribute

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterAttribute"):
                listener.enterAttribute(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitAttribute"):
                listener.exitAttribute(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitAttribute"):
                return visitor.visitAttribute(self)
            else:
                return visitor.visitChildren(self)

    def attribute(self):

        localctx = CSharpParser.AttributeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 360, self.RULE_attribute)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2256
            self.namespace_or_type_name()
            self.state = 2269
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == CSharpParser.OPEN_PARENS:
                self.state = 2257
                self.match(CSharpParser.OPEN_PARENS)
                self.state = 2266
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & (
                        (1 << CSharpParser.ADD) | (1 << CSharpParser.ALIAS) | (1 << CSharpParser.ARGLIST) | (
                        1 << CSharpParser.ASCENDING) | (1 << CSharpParser.ASYNC) | (1 << CSharpParser.AWAIT) | (
                                1 << CSharpParser.BASE) | (1 << CSharpParser.BOOL) | (1 << CSharpParser.BY) | (
                                1 << CSharpParser.BYTE) | (1 << CSharpParser.CHAR) | (1 << CSharpParser.CHECKED) | (
                                1 << CSharpParser.DECIMAL) | (1 << CSharpParser.DEFAULT) | (
                                1 << CSharpParser.DELEGATE) | (1 << CSharpParser.DESCENDING) | (
                                1 << CSharpParser.DOUBLE) | (1 << CSharpParser.DYNAMIC) | (1 << CSharpParser.EQUALS) | (
                                1 << CSharpParser.FALSE) | (1 << CSharpParser.FLOAT) | (1 << CSharpParser.FROM) | (
                                1 << CSharpParser.GET) | (1 << CSharpParser.GROUP) | (1 << CSharpParser.INT) | (
                                1 << CSharpParser.INTO) | (1 << CSharpParser.JOIN) | (1 << CSharpParser.LET) | (
                                1 << CSharpParser.LONG))) != 0) or ((((_la - 64)) & ~0x3f) == 0 and (
                        (1 << (_la - 64)) & ((1 << (CSharpParser.NAMEOF - 64)) | (1 << (CSharpParser.NEW - 64)) | (
                        1 << (CSharpParser.NULL_ - 64)) | (1 << (CSharpParser.OBJECT - 64)) | (
                                                     1 << (CSharpParser.ON - 64)) | (
                                                     1 << (CSharpParser.ORDERBY - 64)) | (
                                                     1 << (CSharpParser.PARTIAL - 64)) | (
                                                     1 << (CSharpParser.REF - 64)) | (
                                                     1 << (CSharpParser.REMOVE - 64)) | (
                                                     1 << (CSharpParser.SBYTE - 64)) | (
                                                     1 << (CSharpParser.SELECT - 64)) | (
                                                     1 << (CSharpParser.SET - 64)) | (
                                                     1 << (CSharpParser.SHORT - 64)) | (
                                                     1 << (CSharpParser.SIZEOF - 64)) | (
                                                     1 << (CSharpParser.STRING - 64)) | (
                                                     1 << (CSharpParser.THIS - 64)) | (
                                                     1 << (CSharpParser.TRUE - 64)) | (
                                                     1 << (CSharpParser.TYPEOF - 64)) | (
                                                     1 << (CSharpParser.UINT - 64)) | (
                                                     1 << (CSharpParser.ULONG - 64)) | (
                                                     1 << (CSharpParser.UNCHECKED - 64)) | (
                                                     1 << (CSharpParser.UNMANAGED - 64)) | (
                                                     1 << (CSharpParser.USHORT - 64)) | (
                                                     1 << (CSharpParser.VAR - 64)) | (1 << (CSharpParser.WHEN - 64)) | (
                                                     1 << (CSharpParser.WHERE - 64)) | (
                                                     1 << (CSharpParser.YIELD - 64)) | (
                                                     1 << (CSharpParser.IDENTIFIER - 64)) | (
                                                     1 << (CSharpParser.LITERAL_ACCESS - 64)) | (
                                                     1 << (CSharpParser.INTEGER_LITERAL - 64)) | (
                                                     1 << (CSharpParser.HEX_INTEGER_LITERAL - 64)) | (
                                                     1 << (CSharpParser.BIN_INTEGER_LITERAL - 64)) | (
                                                     1 << (CSharpParser.REAL_LITERAL - 64)) | (
                                                     1 << (CSharpParser.CHARACTER_LITERAL - 64)) | (
                                                     1 << (CSharpParser.REGULAR_STRING - 64)) | (
                                                     1 << (CSharpParser.VERBATIUM_STRING - 64)) | (
                                                     1 << (CSharpParser.INTERPOLATED_REGULAR_STRING_START - 64)) | (
                                                     1 << (
                                                     CSharpParser.INTERPOLATED_VERBATIUM_STRING_START - 64)))) != 0) or (
                        (((_la - 129)) & ~0x3f) == 0 and ((1 << (_la - 129)) & (
                        (1 << (CSharpParser.OPEN_PARENS - 129)) | (1 << (CSharpParser.PLUS - 129)) | (
                        1 << (CSharpParser.MINUS - 129)) | (1 << (CSharpParser.STAR - 129)) | (
                                1 << (CSharpParser.AMP - 129)) | (1 << (CSharpParser.CARET - 129)) | (
                                1 << (CSharpParser.BANG - 129)) | (1 << (CSharpParser.TILDE - 129)) | (
                                1 << (CSharpParser.OP_INC - 129)) | (1 << (CSharpParser.OP_DEC - 129)) | (
                                1 << (CSharpParser.OP_RANGE - 129)))) != 0):
                    self.state = 2258
                    self.attribute_argument()
                    self.state = 2263
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la == CSharpParser.COMMA:
                        self.state = 2259
                        self.match(CSharpParser.COMMA)
                        self.state = 2260
                        self.attribute_argument()
                        self.state = 2265
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)

                self.state = 2268
                self.match(CSharpParser.CLOSE_PARENS)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Attribute_argumentContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(CSharpParser.ExpressionContext, 0)

        def identifier(self):
            return self.getTypedRuleContext(CSharpParser.IdentifierContext, 0)

        def COLON(self):
            return self.getToken(CSharpParser.COLON, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_attribute_argument

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterAttribute_argument"):
                listener.enterAttribute_argument(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitAttribute_argument"):
                listener.exitAttribute_argument(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitAttribute_argument"):
                return visitor.visitAttribute_argument(self)
            else:
                return visitor.visitChildren(self)

    def attribute_argument(self):

        localctx = CSharpParser.Attribute_argumentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 362, self.RULE_attribute_argument)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2274
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 284, self._ctx)
            if la_ == 1:
                self.state = 2271
                self.identifier()
                self.state = 2272
                self.match(CSharpParser.COLON)

            self.state = 2276
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Pointer_typeContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STAR(self):
            return self.getToken(CSharpParser.STAR, 0)

        def simple_type(self):
            return self.getTypedRuleContext(CSharpParser.Simple_typeContext, 0)

        def class_type(self):
            return self.getTypedRuleContext(CSharpParser.Class_typeContext, 0)

        def rank_specifier(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(CSharpParser.Rank_specifierContext)
            else:
                return self.getTypedRuleContext(CSharpParser.Rank_specifierContext, i)

        def INTERR(self, i: int = None):
            if i is None:
                return self.getTokens(CSharpParser.INTERR)
            else:
                return self.getToken(CSharpParser.INTERR, i)

        def VOID(self):
            return self.getToken(CSharpParser.VOID, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_pointer_type

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterPointer_type"):
                listener.enterPointer_type(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitPointer_type"):
                listener.exitPointer_type(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitPointer_type"):
                return visitor.visitPointer_type(self)
            else:
                return visitor.visitChildren(self)

    def pointer_type(self):

        localctx = CSharpParser.Pointer_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 364, self.RULE_pointer_type)
        self._la = 0  # Token type
        try:
            self.state = 2293
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [CSharpParser.ADD, CSharpParser.ALIAS, CSharpParser.ARGLIST, CSharpParser.ASCENDING,
                         CSharpParser.ASYNC, CSharpParser.AWAIT, CSharpParser.BOOL, CSharpParser.BY, CSharpParser.BYTE,
                         CSharpParser.CHAR, CSharpParser.DECIMAL, CSharpParser.DESCENDING, CSharpParser.DOUBLE,
                         CSharpParser.DYNAMIC, CSharpParser.EQUALS, CSharpParser.FLOAT, CSharpParser.FROM,
                         CSharpParser.GET, CSharpParser.GROUP, CSharpParser.INT, CSharpParser.INTO, CSharpParser.JOIN,
                         CSharpParser.LET, CSharpParser.LONG, CSharpParser.NAMEOF, CSharpParser.OBJECT, CSharpParser.ON,
                         CSharpParser.ORDERBY, CSharpParser.PARTIAL, CSharpParser.REMOVE, CSharpParser.SBYTE,
                         CSharpParser.SELECT, CSharpParser.SET, CSharpParser.SHORT, CSharpParser.STRING,
                         CSharpParser.UINT, CSharpParser.ULONG, CSharpParser.UNMANAGED, CSharpParser.USHORT,
                         CSharpParser.VAR, CSharpParser.WHEN, CSharpParser.WHERE, CSharpParser.YIELD,
                         CSharpParser.IDENTIFIER]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2280
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [CSharpParser.BOOL, CSharpParser.BYTE, CSharpParser.CHAR, CSharpParser.DECIMAL,
                             CSharpParser.DOUBLE, CSharpParser.FLOAT, CSharpParser.INT, CSharpParser.LONG,
                             CSharpParser.SBYTE, CSharpParser.SHORT, CSharpParser.UINT, CSharpParser.ULONG,
                             CSharpParser.USHORT]:
                    self.state = 2278
                    self.simple_type()
                    pass
                elif token in [CSharpParser.ADD, CSharpParser.ALIAS, CSharpParser.ARGLIST, CSharpParser.ASCENDING,
                               CSharpParser.ASYNC, CSharpParser.AWAIT, CSharpParser.BY, CSharpParser.DESCENDING,
                               CSharpParser.DYNAMIC, CSharpParser.EQUALS, CSharpParser.FROM, CSharpParser.GET,
                               CSharpParser.GROUP, CSharpParser.INTO, CSharpParser.JOIN, CSharpParser.LET,
                               CSharpParser.NAMEOF, CSharpParser.OBJECT, CSharpParser.ON, CSharpParser.ORDERBY,
                               CSharpParser.PARTIAL, CSharpParser.REMOVE, CSharpParser.SELECT, CSharpParser.SET,
                               CSharpParser.STRING, CSharpParser.UNMANAGED, CSharpParser.VAR, CSharpParser.WHEN,
                               CSharpParser.WHERE, CSharpParser.YIELD, CSharpParser.IDENTIFIER]:
                    self.state = 2279
                    self.class_type()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 2286
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la == CSharpParser.OPEN_BRACKET or _la == CSharpParser.INTERR:
                    self.state = 2284
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [CSharpParser.OPEN_BRACKET]:
                        self.state = 2282
                        self.rank_specifier()
                        pass
                    elif token in [CSharpParser.INTERR]:
                        self.state = 2283
                        self.match(CSharpParser.INTERR)
                        pass
                    else:
                        raise NoViableAltException(self)

                    self.state = 2288
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 2289
                self.match(CSharpParser.STAR)
                pass
            elif token in [CSharpParser.VOID]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2291
                self.match(CSharpParser.VOID)
                self.state = 2292
                self.match(CSharpParser.STAR)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Fixed_pointer_declaratorsContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fixed_pointer_declarator(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(CSharpParser.Fixed_pointer_declaratorContext)
            else:
                return self.getTypedRuleContext(CSharpParser.Fixed_pointer_declaratorContext, i)

        def COMMA(self, i: int = None):
            if i is None:
                return self.getTokens(CSharpParser.COMMA)
            else:
                return self.getToken(CSharpParser.COMMA, i)

        def getRuleIndex(self):
            return CSharpParser.RULE_fixed_pointer_declarators

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterFixed_pointer_declarators"):
                listener.enterFixed_pointer_declarators(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitFixed_pointer_declarators"):
                listener.exitFixed_pointer_declarators(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitFixed_pointer_declarators"):
                return visitor.visitFixed_pointer_declarators(self)
            else:
                return visitor.visitChildren(self)

    def fixed_pointer_declarators(self):

        localctx = CSharpParser.Fixed_pointer_declaratorsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 366, self.RULE_fixed_pointer_declarators)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2295
            self.fixed_pointer_declarator()
            self.state = 2300
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == CSharpParser.COMMA:
                self.state = 2296
                self.match(CSharpParser.COMMA)
                self.state = 2297
                self.fixed_pointer_declarator()
                self.state = 2302
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Fixed_pointer_declaratorContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(CSharpParser.IdentifierContext, 0)

        def ASSIGNMENT(self):
            return self.getToken(CSharpParser.ASSIGNMENT, 0)

        def fixed_pointer_initializer(self):
            return self.getTypedRuleContext(CSharpParser.Fixed_pointer_initializerContext, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_fixed_pointer_declarator

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterFixed_pointer_declarator"):
                listener.enterFixed_pointer_declarator(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitFixed_pointer_declarator"):
                listener.exitFixed_pointer_declarator(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitFixed_pointer_declarator"):
                return visitor.visitFixed_pointer_declarator(self)
            else:
                return visitor.visitChildren(self)

    def fixed_pointer_declarator(self):

        localctx = CSharpParser.Fixed_pointer_declaratorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 368, self.RULE_fixed_pointer_declarator)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2303
            self.identifier()
            self.state = 2304
            self.match(CSharpParser.ASSIGNMENT)
            self.state = 2305
            self.fixed_pointer_initializer()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Fixed_pointer_initializerContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(CSharpParser.ExpressionContext, 0)

        def AMP(self):
            return self.getToken(CSharpParser.AMP, 0)

        def stackalloc_initializer(self):
            return self.getTypedRuleContext(CSharpParser.Stackalloc_initializerContext, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_fixed_pointer_initializer

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterFixed_pointer_initializer"):
                listener.enterFixed_pointer_initializer(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitFixed_pointer_initializer"):
                listener.exitFixed_pointer_initializer(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitFixed_pointer_initializer"):
                return visitor.visitFixed_pointer_initializer(self)
            else:
                return visitor.visitChildren(self)

    def fixed_pointer_initializer(self):

        localctx = CSharpParser.Fixed_pointer_initializerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 370, self.RULE_fixed_pointer_initializer)
        try:
            self.state = 2312
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [CSharpParser.ADD, CSharpParser.ALIAS, CSharpParser.ARGLIST, CSharpParser.ASCENDING,
                         CSharpParser.ASYNC, CSharpParser.AWAIT, CSharpParser.BASE, CSharpParser.BOOL, CSharpParser.BY,
                         CSharpParser.BYTE, CSharpParser.CHAR, CSharpParser.CHECKED, CSharpParser.DECIMAL,
                         CSharpParser.DEFAULT, CSharpParser.DELEGATE, CSharpParser.DESCENDING, CSharpParser.DOUBLE,
                         CSharpParser.DYNAMIC, CSharpParser.EQUALS, CSharpParser.FALSE, CSharpParser.FLOAT,
                         CSharpParser.FROM, CSharpParser.GET, CSharpParser.GROUP, CSharpParser.INT, CSharpParser.INTO,
                         CSharpParser.JOIN, CSharpParser.LET, CSharpParser.LONG, CSharpParser.NAMEOF, CSharpParser.NEW,
                         CSharpParser.NULL_, CSharpParser.OBJECT, CSharpParser.ON, CSharpParser.ORDERBY,
                         CSharpParser.PARTIAL, CSharpParser.REF, CSharpParser.REMOVE, CSharpParser.SBYTE,
                         CSharpParser.SELECT, CSharpParser.SET, CSharpParser.SHORT, CSharpParser.SIZEOF,
                         CSharpParser.STRING, CSharpParser.THIS, CSharpParser.TRUE, CSharpParser.TYPEOF,
                         CSharpParser.UINT, CSharpParser.ULONG, CSharpParser.UNCHECKED, CSharpParser.UNMANAGED,
                         CSharpParser.USHORT, CSharpParser.VAR, CSharpParser.WHEN, CSharpParser.WHERE,
                         CSharpParser.YIELD, CSharpParser.IDENTIFIER, CSharpParser.LITERAL_ACCESS,
                         CSharpParser.INTEGER_LITERAL, CSharpParser.HEX_INTEGER_LITERAL,
                         CSharpParser.BIN_INTEGER_LITERAL, CSharpParser.REAL_LITERAL, CSharpParser.CHARACTER_LITERAL,
                         CSharpParser.REGULAR_STRING, CSharpParser.VERBATIUM_STRING,
                         CSharpParser.INTERPOLATED_REGULAR_STRING_START,
                         CSharpParser.INTERPOLATED_VERBATIUM_STRING_START, CSharpParser.OPEN_PARENS, CSharpParser.PLUS,
                         CSharpParser.MINUS, CSharpParser.STAR, CSharpParser.AMP, CSharpParser.CARET, CSharpParser.BANG,
                         CSharpParser.TILDE, CSharpParser.OP_INC, CSharpParser.OP_DEC, CSharpParser.OP_RANGE]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2308
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input, 290, self._ctx)
                if la_ == 1:
                    self.state = 2307
                    self.match(CSharpParser.AMP)

                self.state = 2310
                self.expression()
                pass
            elif token in [CSharpParser.STACKALLOC]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2311
                self.stackalloc_initializer()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Fixed_size_buffer_declaratorContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(CSharpParser.IdentifierContext, 0)

        def OPEN_BRACKET(self):
            return self.getToken(CSharpParser.OPEN_BRACKET, 0)

        def expression(self):
            return self.getTypedRuleContext(CSharpParser.ExpressionContext, 0)

        def CLOSE_BRACKET(self):
            return self.getToken(CSharpParser.CLOSE_BRACKET, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_fixed_size_buffer_declarator

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterFixed_size_buffer_declarator"):
                listener.enterFixed_size_buffer_declarator(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitFixed_size_buffer_declarator"):
                listener.exitFixed_size_buffer_declarator(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitFixed_size_buffer_declarator"):
                return visitor.visitFixed_size_buffer_declarator(self)
            else:
                return visitor.visitChildren(self)

    def fixed_size_buffer_declarator(self):

        localctx = CSharpParser.Fixed_size_buffer_declaratorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 372, self.RULE_fixed_size_buffer_declarator)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2314
            self.identifier()
            self.state = 2315
            self.match(CSharpParser.OPEN_BRACKET)
            self.state = 2316
            self.expression()
            self.state = 2317
            self.match(CSharpParser.CLOSE_BRACKET)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Stackalloc_initializerContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STACKALLOC(self):
            return self.getToken(CSharpParser.STACKALLOC, 0)

        def type_(self):
            return self.getTypedRuleContext(CSharpParser.Type_Context, 0)

        def OPEN_BRACKET(self):
            return self.getToken(CSharpParser.OPEN_BRACKET, 0)

        def expression(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(CSharpParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(CSharpParser.ExpressionContext, i)

        def CLOSE_BRACKET(self):
            return self.getToken(CSharpParser.CLOSE_BRACKET, 0)

        def OPEN_BRACE(self):
            return self.getToken(CSharpParser.OPEN_BRACE, 0)

        def CLOSE_BRACE(self):
            return self.getToken(CSharpParser.CLOSE_BRACE, 0)

        def COMMA(self, i: int = None):
            if i is None:
                return self.getTokens(CSharpParser.COMMA)
            else:
                return self.getToken(CSharpParser.COMMA, i)

        def getRuleIndex(self):
            return CSharpParser.RULE_stackalloc_initializer

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterStackalloc_initializer"):
                listener.enterStackalloc_initializer(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitStackalloc_initializer"):
                listener.exitStackalloc_initializer(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitStackalloc_initializer"):
                return visitor.visitStackalloc_initializer(self)
            else:
                return visitor.visitChildren(self)

    def stackalloc_initializer(self):

        localctx = CSharpParser.Stackalloc_initializerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 374, self.RULE_stackalloc_initializer)
        self._la = 0  # Token type
        try:
            self.state = 2348
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 296, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 2319
                self.match(CSharpParser.STACKALLOC)
                self.state = 2320
                self.type_()
                self.state = 2321
                self.match(CSharpParser.OPEN_BRACKET)
                self.state = 2322
                self.expression()
                self.state = 2323
                self.match(CSharpParser.CLOSE_BRACKET)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 2325
                self.match(CSharpParser.STACKALLOC)
                self.state = 2327
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 10)) & ~0x3f) == 0 and ((1 << (_la - 10)) & (
                        (1 << (CSharpParser.ADD - 10)) | (1 << (CSharpParser.ALIAS - 10)) | (
                        1 << (CSharpParser.ARGLIST - 10)) | (1 << (CSharpParser.ASCENDING - 10)) | (
                                1 << (CSharpParser.ASYNC - 10)) | (1 << (CSharpParser.AWAIT - 10)) | (
                                1 << (CSharpParser.BOOL - 10)) | (1 << (CSharpParser.BY - 10)) | (
                                1 << (CSharpParser.BYTE - 10)) | (1 << (CSharpParser.CHAR - 10)) | (
                                1 << (CSharpParser.DECIMAL - 10)) | (1 << (CSharpParser.DESCENDING - 10)) | (
                                1 << (CSharpParser.DOUBLE - 10)) | (1 << (CSharpParser.DYNAMIC - 10)) | (
                                1 << (CSharpParser.EQUALS - 10)) | (1 << (CSharpParser.FLOAT - 10)) | (
                                1 << (CSharpParser.FROM - 10)) | (1 << (CSharpParser.GET - 10)) | (
                                1 << (CSharpParser.GROUP - 10)) | (1 << (CSharpParser.INT - 10)) | (
                                1 << (CSharpParser.INTO - 10)) | (1 << (CSharpParser.JOIN - 10)) | (
                                1 << (CSharpParser.LET - 10)) | (1 << (CSharpParser.LONG - 10)) | (
                                1 << (CSharpParser.NAMEOF - 10)) | (1 << (CSharpParser.OBJECT - 10)) | (
                                1 << (CSharpParser.ON - 10)) | (1 << (CSharpParser.ORDERBY - 10)))) != 0) or (
                        (((_la - 75)) & ~0x3f) == 0 and ((1 << (_la - 75)) & (
                        (1 << (CSharpParser.PARTIAL - 75)) | (1 << (CSharpParser.REMOVE - 75)) | (
                        1 << (CSharpParser.SBYTE - 75)) | (1 << (CSharpParser.SELECT - 75)) | (
                                1 << (CSharpParser.SET - 75)) | (1 << (CSharpParser.SHORT - 75)) | (
                                1 << (CSharpParser.STRING - 75)) | (1 << (CSharpParser.UINT - 75)) | (
                                1 << (CSharpParser.ULONG - 75)) | (1 << (CSharpParser.UNMANAGED - 75)) | (
                                1 << (CSharpParser.USHORT - 75)) | (1 << (CSharpParser.VAR - 75)) | (
                                1 << (CSharpParser.VOID - 75)) | (1 << (CSharpParser.WHEN - 75)) | (
                                1 << (CSharpParser.WHERE - 75)) | (1 << (CSharpParser.YIELD - 75)) | (
                                1 << (CSharpParser.IDENTIFIER - 75)) | (1 << (CSharpParser.OPEN_PARENS - 75)))) != 0):
                    self.state = 2326
                    self.type_()

                self.state = 2329
                self.match(CSharpParser.OPEN_BRACKET)
                self.state = 2331
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & (
                        (1 << CSharpParser.ADD) | (1 << CSharpParser.ALIAS) | (1 << CSharpParser.ARGLIST) | (
                        1 << CSharpParser.ASCENDING) | (1 << CSharpParser.ASYNC) | (1 << CSharpParser.AWAIT) | (
                                1 << CSharpParser.BASE) | (1 << CSharpParser.BOOL) | (1 << CSharpParser.BY) | (
                                1 << CSharpParser.BYTE) | (1 << CSharpParser.CHAR) | (1 << CSharpParser.CHECKED) | (
                                1 << CSharpParser.DECIMAL) | (1 << CSharpParser.DEFAULT) | (
                                1 << CSharpParser.DELEGATE) | (1 << CSharpParser.DESCENDING) | (
                                1 << CSharpParser.DOUBLE) | (1 << CSharpParser.DYNAMIC) | (1 << CSharpParser.EQUALS) | (
                                1 << CSharpParser.FALSE) | (1 << CSharpParser.FLOAT) | (1 << CSharpParser.FROM) | (
                                1 << CSharpParser.GET) | (1 << CSharpParser.GROUP) | (1 << CSharpParser.INT) | (
                                1 << CSharpParser.INTO) | (1 << CSharpParser.JOIN) | (1 << CSharpParser.LET) | (
                                1 << CSharpParser.LONG))) != 0) or ((((_la - 64)) & ~0x3f) == 0 and (
                        (1 << (_la - 64)) & ((1 << (CSharpParser.NAMEOF - 64)) | (1 << (CSharpParser.NEW - 64)) | (
                        1 << (CSharpParser.NULL_ - 64)) | (1 << (CSharpParser.OBJECT - 64)) | (
                                                     1 << (CSharpParser.ON - 64)) | (
                                                     1 << (CSharpParser.ORDERBY - 64)) | (
                                                     1 << (CSharpParser.PARTIAL - 64)) | (
                                                     1 << (CSharpParser.REF - 64)) | (
                                                     1 << (CSharpParser.REMOVE - 64)) | (
                                                     1 << (CSharpParser.SBYTE - 64)) | (
                                                     1 << (CSharpParser.SELECT - 64)) | (
                                                     1 << (CSharpParser.SET - 64)) | (
                                                     1 << (CSharpParser.SHORT - 64)) | (
                                                     1 << (CSharpParser.SIZEOF - 64)) | (
                                                     1 << (CSharpParser.STRING - 64)) | (
                                                     1 << (CSharpParser.THIS - 64)) | (
                                                     1 << (CSharpParser.TRUE - 64)) | (
                                                     1 << (CSharpParser.TYPEOF - 64)) | (
                                                     1 << (CSharpParser.UINT - 64)) | (
                                                     1 << (CSharpParser.ULONG - 64)) | (
                                                     1 << (CSharpParser.UNCHECKED - 64)) | (
                                                     1 << (CSharpParser.UNMANAGED - 64)) | (
                                                     1 << (CSharpParser.USHORT - 64)) | (
                                                     1 << (CSharpParser.VAR - 64)) | (1 << (CSharpParser.WHEN - 64)) | (
                                                     1 << (CSharpParser.WHERE - 64)) | (
                                                     1 << (CSharpParser.YIELD - 64)) | (
                                                     1 << (CSharpParser.IDENTIFIER - 64)) | (
                                                     1 << (CSharpParser.LITERAL_ACCESS - 64)) | (
                                                     1 << (CSharpParser.INTEGER_LITERAL - 64)) | (
                                                     1 << (CSharpParser.HEX_INTEGER_LITERAL - 64)) | (
                                                     1 << (CSharpParser.BIN_INTEGER_LITERAL - 64)) | (
                                                     1 << (CSharpParser.REAL_LITERAL - 64)) | (
                                                     1 << (CSharpParser.CHARACTER_LITERAL - 64)) | (
                                                     1 << (CSharpParser.REGULAR_STRING - 64)) | (
                                                     1 << (CSharpParser.VERBATIUM_STRING - 64)) | (
                                                     1 << (CSharpParser.INTERPOLATED_REGULAR_STRING_START - 64)) | (
                                                     1 << (
                                                     CSharpParser.INTERPOLATED_VERBATIUM_STRING_START - 64)))) != 0) or (
                        (((_la - 129)) & ~0x3f) == 0 and ((1 << (_la - 129)) & (
                        (1 << (CSharpParser.OPEN_PARENS - 129)) | (1 << (CSharpParser.PLUS - 129)) | (
                        1 << (CSharpParser.MINUS - 129)) | (1 << (CSharpParser.STAR - 129)) | (
                                1 << (CSharpParser.AMP - 129)) | (1 << (CSharpParser.CARET - 129)) | (
                                1 << (CSharpParser.BANG - 129)) | (1 << (CSharpParser.TILDE - 129)) | (
                                1 << (CSharpParser.OP_INC - 129)) | (1 << (CSharpParser.OP_DEC - 129)) | (
                                1 << (CSharpParser.OP_RANGE - 129)))) != 0):
                    self.state = 2330
                    self.expression()

                self.state = 2333
                self.match(CSharpParser.CLOSE_BRACKET)
                self.state = 2334
                self.match(CSharpParser.OPEN_BRACE)
                self.state = 2335
                self.expression()
                self.state = 2340
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 294, self._ctx)
                while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 2336
                        self.match(CSharpParser.COMMA)
                        self.state = 2337
                        self.expression()
                    self.state = 2342
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input, 294, self._ctx)

                self.state = 2344
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == CSharpParser.COMMA:
                    self.state = 2343
                    self.match(CSharpParser.COMMA)

                self.state = 2346
                self.match(CSharpParser.CLOSE_BRACE)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Right_arrowContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.first = None  # Token
            self.second = None  # Token

        def ASSIGNMENT(self):
            return self.getToken(CSharpParser.ASSIGNMENT, 0)

        def GT(self):
            return self.getToken(CSharpParser.GT, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_right_arrow

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterRight_arrow"):
                listener.enterRight_arrow(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitRight_arrow"):
                listener.exitRight_arrow(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitRight_arrow"):
                return visitor.visitRight_arrow(self)
            else:
                return visitor.visitChildren(self)

    def right_arrow(self):

        localctx = CSharpParser.Right_arrowContext(self, self._ctx, self.state)
        self.enterRule(localctx, 376, self.RULE_right_arrow)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2350
            localctx.first = self.match(CSharpParser.ASSIGNMENT)
            self.state = 2351
            localctx.second = self.match(CSharpParser.GT)
            self.state = 2352
            if not (0 if localctx.first is None else localctx.first.tokenIndex) + 1 == (
            0 if localctx.second is None else localctx.second.tokenIndex):
                from antlr4.error.Errors import FailedPredicateException
                raise FailedPredicateException(self, "$first.index + 1 == $second.index")
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Right_shiftContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.first = None  # Token
            self.second = None  # Token

        def GT(self, i: int = None):
            if i is None:
                return self.getTokens(CSharpParser.GT)
            else:
                return self.getToken(CSharpParser.GT, i)

        def getRuleIndex(self):
            return CSharpParser.RULE_right_shift

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterRight_shift"):
                listener.enterRight_shift(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitRight_shift"):
                listener.exitRight_shift(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitRight_shift"):
                return visitor.visitRight_shift(self)
            else:
                return visitor.visitChildren(self)

    def right_shift(self):

        localctx = CSharpParser.Right_shiftContext(self, self._ctx, self.state)
        self.enterRule(localctx, 378, self.RULE_right_shift)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2354
            localctx.first = self.match(CSharpParser.GT)
            self.state = 2355
            localctx.second = self.match(CSharpParser.GT)
            self.state = 2356
            if not (0 if localctx.first is None else localctx.first.tokenIndex) + 1 == (
            0 if localctx.second is None else localctx.second.tokenIndex):
                from antlr4.error.Errors import FailedPredicateException
                raise FailedPredicateException(self, "$first.index + 1 == $second.index")
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Right_shift_assignmentContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.first = None  # Token
            self.second = None  # Token

        def GT(self):
            return self.getToken(CSharpParser.GT, 0)

        def OP_GE(self):
            return self.getToken(CSharpParser.OP_GE, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_right_shift_assignment

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterRight_shift_assignment"):
                listener.enterRight_shift_assignment(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitRight_shift_assignment"):
                listener.exitRight_shift_assignment(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitRight_shift_assignment"):
                return visitor.visitRight_shift_assignment(self)
            else:
                return visitor.visitChildren(self)

    def right_shift_assignment(self):

        localctx = CSharpParser.Right_shift_assignmentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 380, self.RULE_right_shift_assignment)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2358
            localctx.first = self.match(CSharpParser.GT)
            self.state = 2359
            localctx.second = self.match(CSharpParser.OP_GE)
            self.state = 2360
            if not (0 if localctx.first is None else localctx.first.tokenIndex) + 1 == (
            0 if localctx.second is None else localctx.second.tokenIndex):
                from antlr4.error.Errors import FailedPredicateException
                raise FailedPredicateException(self, "$first.index + 1 == $second.index")
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class LiteralContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def boolean_literal(self):
            return self.getTypedRuleContext(CSharpParser.Boolean_literalContext, 0)

        def string_literal(self):
            return self.getTypedRuleContext(CSharpParser.String_literalContext, 0)

        def INTEGER_LITERAL(self):
            return self.getToken(CSharpParser.INTEGER_LITERAL, 0)

        def HEX_INTEGER_LITERAL(self):
            return self.getToken(CSharpParser.HEX_INTEGER_LITERAL, 0)

        def BIN_INTEGER_LITERAL(self):
            return self.getToken(CSharpParser.BIN_INTEGER_LITERAL, 0)

        def REAL_LITERAL(self):
            return self.getToken(CSharpParser.REAL_LITERAL, 0)

        def CHARACTER_LITERAL(self):
            return self.getToken(CSharpParser.CHARACTER_LITERAL, 0)

        def NULL_(self):
            return self.getToken(CSharpParser.NULL_, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_literal

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterLiteral"):
                listener.enterLiteral(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitLiteral"):
                listener.exitLiteral(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitLiteral"):
                return visitor.visitLiteral(self)
            else:
                return visitor.visitChildren(self)

    def literal(self):

        localctx = CSharpParser.LiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 382, self.RULE_literal)
        try:
            self.state = 2370
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [CSharpParser.FALSE, CSharpParser.TRUE]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2362
                self.boolean_literal()
                pass
            elif token in [CSharpParser.REGULAR_STRING, CSharpParser.VERBATIUM_STRING,
                           CSharpParser.INTERPOLATED_REGULAR_STRING_START,
                           CSharpParser.INTERPOLATED_VERBATIUM_STRING_START]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2363
                self.string_literal()
                pass
            elif token in [CSharpParser.INTEGER_LITERAL]:
                self.enterOuterAlt(localctx, 3)
                self.state = 2364
                self.match(CSharpParser.INTEGER_LITERAL)
                pass
            elif token in [CSharpParser.HEX_INTEGER_LITERAL]:
                self.enterOuterAlt(localctx, 4)
                self.state = 2365
                self.match(CSharpParser.HEX_INTEGER_LITERAL)
                pass
            elif token in [CSharpParser.BIN_INTEGER_LITERAL]:
                self.enterOuterAlt(localctx, 5)
                self.state = 2366
                self.match(CSharpParser.BIN_INTEGER_LITERAL)
                pass
            elif token in [CSharpParser.REAL_LITERAL]:
                self.enterOuterAlt(localctx, 6)
                self.state = 2367
                self.match(CSharpParser.REAL_LITERAL)
                pass
            elif token in [CSharpParser.CHARACTER_LITERAL]:
                self.enterOuterAlt(localctx, 7)
                self.state = 2368
                self.match(CSharpParser.CHARACTER_LITERAL)
                pass
            elif token in [CSharpParser.NULL_]:
                self.enterOuterAlt(localctx, 8)
                self.state = 2369
                self.match(CSharpParser.NULL_)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Boolean_literalContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TRUE(self):
            return self.getToken(CSharpParser.TRUE, 0)

        def FALSE(self):
            return self.getToken(CSharpParser.FALSE, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_boolean_literal

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterBoolean_literal"):
                listener.enterBoolean_literal(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitBoolean_literal"):
                listener.exitBoolean_literal(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitBoolean_literal"):
                return visitor.visitBoolean_literal(self)
            else:
                return visitor.visitChildren(self)

    def boolean_literal(self):

        localctx = CSharpParser.Boolean_literalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 384, self.RULE_boolean_literal)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2372
            _la = self._input.LA(1)
            if not (_la == CSharpParser.FALSE or _la == CSharpParser.TRUE):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class String_literalContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def interpolated_regular_string(self):
            return self.getTypedRuleContext(CSharpParser.Interpolated_regular_stringContext, 0)

        def interpolated_verbatium_string(self):
            return self.getTypedRuleContext(CSharpParser.Interpolated_verbatium_stringContext, 0)

        def REGULAR_STRING(self):
            return self.getToken(CSharpParser.REGULAR_STRING, 0)

        def VERBATIUM_STRING(self):
            return self.getToken(CSharpParser.VERBATIUM_STRING, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_string_literal

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterString_literal"):
                listener.enterString_literal(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitString_literal"):
                listener.exitString_literal(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitString_literal"):
                return visitor.visitString_literal(self)
            else:
                return visitor.visitChildren(self)

    def string_literal(self):

        localctx = CSharpParser.String_literalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 386, self.RULE_string_literal)
        try:
            self.state = 2378
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [CSharpParser.INTERPOLATED_REGULAR_STRING_START]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2374
                self.interpolated_regular_string()
                pass
            elif token in [CSharpParser.INTERPOLATED_VERBATIUM_STRING_START]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2375
                self.interpolated_verbatium_string()
                pass
            elif token in [CSharpParser.REGULAR_STRING]:
                self.enterOuterAlt(localctx, 3)
                self.state = 2376
                self.match(CSharpParser.REGULAR_STRING)
                pass
            elif token in [CSharpParser.VERBATIUM_STRING]:
                self.enterOuterAlt(localctx, 4)
                self.state = 2377
                self.match(CSharpParser.VERBATIUM_STRING)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Interpolated_regular_stringContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INTERPOLATED_REGULAR_STRING_START(self):
            return self.getToken(CSharpParser.INTERPOLATED_REGULAR_STRING_START, 0)

        def DOUBLE_QUOTE_INSIDE(self):
            return self.getToken(CSharpParser.DOUBLE_QUOTE_INSIDE, 0)

        def interpolated_regular_string_part(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(CSharpParser.Interpolated_regular_string_partContext)
            else:
                return self.getTypedRuleContext(CSharpParser.Interpolated_regular_string_partContext, i)

        def getRuleIndex(self):
            return CSharpParser.RULE_interpolated_regular_string

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterInterpolated_regular_string"):
                listener.enterInterpolated_regular_string(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitInterpolated_regular_string"):
                listener.exitInterpolated_regular_string(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitInterpolated_regular_string"):
                return visitor.visitInterpolated_regular_string(self)
            else:
                return visitor.visitChildren(self)

    def interpolated_regular_string(self):

        localctx = CSharpParser.Interpolated_regular_stringContext(self, self._ctx, self.state)
        self.enterRule(localctx, 388, self.RULE_interpolated_regular_string)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2380
            self.match(CSharpParser.INTERPOLATED_REGULAR_STRING_START)
            self.state = 2384
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & (
                    (1 << CSharpParser.ADD) | (1 << CSharpParser.ALIAS) | (1 << CSharpParser.ARGLIST) | (
                    1 << CSharpParser.ASCENDING) | (1 << CSharpParser.ASYNC) | (1 << CSharpParser.AWAIT) | (
                            1 << CSharpParser.BASE) | (1 << CSharpParser.BOOL) | (1 << CSharpParser.BY) | (
                            1 << CSharpParser.BYTE) | (1 << CSharpParser.CHAR) | (1 << CSharpParser.CHECKED) | (
                            1 << CSharpParser.DECIMAL) | (1 << CSharpParser.DEFAULT) | (1 << CSharpParser.DELEGATE) | (
                            1 << CSharpParser.DESCENDING) | (1 << CSharpParser.DOUBLE) | (1 << CSharpParser.DYNAMIC) | (
                            1 << CSharpParser.EQUALS) | (1 << CSharpParser.FALSE) | (1 << CSharpParser.FLOAT) | (
                            1 << CSharpParser.FROM) | (1 << CSharpParser.GET) | (1 << CSharpParser.GROUP) | (
                            1 << CSharpParser.INT) | (1 << CSharpParser.INTO) | (1 << CSharpParser.JOIN) | (
                            1 << CSharpParser.LET) | (1 << CSharpParser.LONG))) != 0) or (
                    (((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & (
                    (1 << (CSharpParser.NAMEOF - 64)) | (1 << (CSharpParser.NEW - 64)) | (
                    1 << (CSharpParser.NULL_ - 64)) | (1 << (CSharpParser.OBJECT - 64)) | (
                            1 << (CSharpParser.ON - 64)) | (1 << (CSharpParser.ORDERBY - 64)) | (
                            1 << (CSharpParser.PARTIAL - 64)) | (1 << (CSharpParser.REF - 64)) | (
                            1 << (CSharpParser.REMOVE - 64)) | (1 << (CSharpParser.SBYTE - 64)) | (
                            1 << (CSharpParser.SELECT - 64)) | (1 << (CSharpParser.SET - 64)) | (
                            1 << (CSharpParser.SHORT - 64)) | (1 << (CSharpParser.SIZEOF - 64)) | (
                            1 << (CSharpParser.STRING - 64)) | (1 << (CSharpParser.THIS - 64)) | (
                            1 << (CSharpParser.TRUE - 64)) | (1 << (CSharpParser.TYPEOF - 64)) | (
                            1 << (CSharpParser.UINT - 64)) | (1 << (CSharpParser.ULONG - 64)) | (
                            1 << (CSharpParser.UNCHECKED - 64)) | (1 << (CSharpParser.UNMANAGED - 64)) | (
                            1 << (CSharpParser.USHORT - 64)) | (1 << (CSharpParser.VAR - 64)) | (
                            1 << (CSharpParser.WHEN - 64)) | (1 << (CSharpParser.WHERE - 64)) | (
                            1 << (CSharpParser.YIELD - 64)) | (1 << (CSharpParser.IDENTIFIER - 64)) | (
                            1 << (CSharpParser.LITERAL_ACCESS - 64)) | (1 << (CSharpParser.INTEGER_LITERAL - 64)) | (
                            1 << (CSharpParser.HEX_INTEGER_LITERAL - 64)) | (
                            1 << (CSharpParser.BIN_INTEGER_LITERAL - 64)) | (1 << (CSharpParser.REAL_LITERAL - 64)) | (
                            1 << (CSharpParser.CHARACTER_LITERAL - 64)) | (1 << (CSharpParser.REGULAR_STRING - 64)) | (
                            1 << (CSharpParser.VERBATIUM_STRING - 64)) | (
                            1 << (CSharpParser.INTERPOLATED_REGULAR_STRING_START - 64)) | (
                            1 << (CSharpParser.INTERPOLATED_VERBATIUM_STRING_START - 64)))) != 0) or (
                    (((_la - 129)) & ~0x3f) == 0 and ((1 << (_la - 129)) & (
                    (1 << (CSharpParser.OPEN_PARENS - 129)) | (1 << (CSharpParser.PLUS - 129)) | (
                    1 << (CSharpParser.MINUS - 129)) | (1 << (CSharpParser.STAR - 129)) | (
                            1 << (CSharpParser.AMP - 129)) | (1 << (CSharpParser.CARET - 129)) | (
                            1 << (CSharpParser.BANG - 129)) | (1 << (CSharpParser.TILDE - 129)) | (
                            1 << (CSharpParser.OP_INC - 129)) | (1 << (CSharpParser.OP_DEC - 129)) | (
                            1 << (CSharpParser.OP_RANGE - 129)) | (1 << (CSharpParser.DOUBLE_CURLY_INSIDE - 129)) | (
                            1 << (CSharpParser.REGULAR_CHAR_INSIDE - 129)) | (
                            1 << (CSharpParser.REGULAR_STRING_INSIDE - 129)))) != 0):
                self.state = 2381
                self.interpolated_regular_string_part()
                self.state = 2386
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 2387
            self.match(CSharpParser.DOUBLE_QUOTE_INSIDE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Interpolated_verbatium_stringContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INTERPOLATED_VERBATIUM_STRING_START(self):
            return self.getToken(CSharpParser.INTERPOLATED_VERBATIUM_STRING_START, 0)

        def DOUBLE_QUOTE_INSIDE(self):
            return self.getToken(CSharpParser.DOUBLE_QUOTE_INSIDE, 0)

        def interpolated_verbatium_string_part(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(CSharpParser.Interpolated_verbatium_string_partContext)
            else:
                return self.getTypedRuleContext(CSharpParser.Interpolated_verbatium_string_partContext, i)

        def getRuleIndex(self):
            return CSharpParser.RULE_interpolated_verbatium_string

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterInterpolated_verbatium_string"):
                listener.enterInterpolated_verbatium_string(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitInterpolated_verbatium_string"):
                listener.exitInterpolated_verbatium_string(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitInterpolated_verbatium_string"):
                return visitor.visitInterpolated_verbatium_string(self)
            else:
                return visitor.visitChildren(self)

    def interpolated_verbatium_string(self):

        localctx = CSharpParser.Interpolated_verbatium_stringContext(self, self._ctx, self.state)
        self.enterRule(localctx, 390, self.RULE_interpolated_verbatium_string)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2389
            self.match(CSharpParser.INTERPOLATED_VERBATIUM_STRING_START)
            self.state = 2393
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & (
                    (1 << CSharpParser.ADD) | (1 << CSharpParser.ALIAS) | (1 << CSharpParser.ARGLIST) | (
                    1 << CSharpParser.ASCENDING) | (1 << CSharpParser.ASYNC) | (1 << CSharpParser.AWAIT) | (
                            1 << CSharpParser.BASE) | (1 << CSharpParser.BOOL) | (1 << CSharpParser.BY) | (
                            1 << CSharpParser.BYTE) | (1 << CSharpParser.CHAR) | (1 << CSharpParser.CHECKED) | (
                            1 << CSharpParser.DECIMAL) | (1 << CSharpParser.DEFAULT) | (1 << CSharpParser.DELEGATE) | (
                            1 << CSharpParser.DESCENDING) | (1 << CSharpParser.DOUBLE) | (1 << CSharpParser.DYNAMIC) | (
                            1 << CSharpParser.EQUALS) | (1 << CSharpParser.FALSE) | (1 << CSharpParser.FLOAT) | (
                            1 << CSharpParser.FROM) | (1 << CSharpParser.GET) | (1 << CSharpParser.GROUP) | (
                            1 << CSharpParser.INT) | (1 << CSharpParser.INTO) | (1 << CSharpParser.JOIN) | (
                            1 << CSharpParser.LET) | (1 << CSharpParser.LONG))) != 0) or (
                    (((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & (
                    (1 << (CSharpParser.NAMEOF - 64)) | (1 << (CSharpParser.NEW - 64)) | (
                    1 << (CSharpParser.NULL_ - 64)) | (1 << (CSharpParser.OBJECT - 64)) | (
                            1 << (CSharpParser.ON - 64)) | (1 << (CSharpParser.ORDERBY - 64)) | (
                            1 << (CSharpParser.PARTIAL - 64)) | (1 << (CSharpParser.REF - 64)) | (
                            1 << (CSharpParser.REMOVE - 64)) | (1 << (CSharpParser.SBYTE - 64)) | (
                            1 << (CSharpParser.SELECT - 64)) | (1 << (CSharpParser.SET - 64)) | (
                            1 << (CSharpParser.SHORT - 64)) | (1 << (CSharpParser.SIZEOF - 64)) | (
                            1 << (CSharpParser.STRING - 64)) | (1 << (CSharpParser.THIS - 64)) | (
                            1 << (CSharpParser.TRUE - 64)) | (1 << (CSharpParser.TYPEOF - 64)) | (
                            1 << (CSharpParser.UINT - 64)) | (1 << (CSharpParser.ULONG - 64)) | (
                            1 << (CSharpParser.UNCHECKED - 64)) | (1 << (CSharpParser.UNMANAGED - 64)) | (
                            1 << (CSharpParser.USHORT - 64)) | (1 << (CSharpParser.VAR - 64)) | (
                            1 << (CSharpParser.WHEN - 64)) | (1 << (CSharpParser.WHERE - 64)) | (
                            1 << (CSharpParser.YIELD - 64)) | (1 << (CSharpParser.IDENTIFIER - 64)) | (
                            1 << (CSharpParser.LITERAL_ACCESS - 64)) | (1 << (CSharpParser.INTEGER_LITERAL - 64)) | (
                            1 << (CSharpParser.HEX_INTEGER_LITERAL - 64)) | (
                            1 << (CSharpParser.BIN_INTEGER_LITERAL - 64)) | (1 << (CSharpParser.REAL_LITERAL - 64)) | (
                            1 << (CSharpParser.CHARACTER_LITERAL - 64)) | (1 << (CSharpParser.REGULAR_STRING - 64)) | (
                            1 << (CSharpParser.VERBATIUM_STRING - 64)) | (
                            1 << (CSharpParser.INTERPOLATED_REGULAR_STRING_START - 64)) | (
                            1 << (CSharpParser.INTERPOLATED_VERBATIUM_STRING_START - 64)))) != 0) or (
                    (((_la - 129)) & ~0x3f) == 0 and ((1 << (_la - 129)) & (
                    (1 << (CSharpParser.OPEN_PARENS - 129)) | (1 << (CSharpParser.PLUS - 129)) | (
                    1 << (CSharpParser.MINUS - 129)) | (1 << (CSharpParser.STAR - 129)) | (
                            1 << (CSharpParser.AMP - 129)) | (1 << (CSharpParser.CARET - 129)) | (
                            1 << (CSharpParser.BANG - 129)) | (1 << (CSharpParser.TILDE - 129)) | (
                            1 << (CSharpParser.OP_INC - 129)) | (1 << (CSharpParser.OP_DEC - 129)) | (
                            1 << (CSharpParser.OP_RANGE - 129)) | (1 << (CSharpParser.DOUBLE_CURLY_INSIDE - 129)) | (
                            1 << (CSharpParser.VERBATIUM_DOUBLE_QUOTE_INSIDE - 129)) | (
                            1 << (CSharpParser.VERBATIUM_INSIDE_STRING - 129)))) != 0):
                self.state = 2390
                self.interpolated_verbatium_string_part()
                self.state = 2395
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 2396
            self.match(CSharpParser.DOUBLE_QUOTE_INSIDE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Interpolated_regular_string_partContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def interpolated_string_expression(self):
            return self.getTypedRuleContext(CSharpParser.Interpolated_string_expressionContext, 0)

        def DOUBLE_CURLY_INSIDE(self):
            return self.getToken(CSharpParser.DOUBLE_CURLY_INSIDE, 0)

        def REGULAR_CHAR_INSIDE(self):
            return self.getToken(CSharpParser.REGULAR_CHAR_INSIDE, 0)

        def REGULAR_STRING_INSIDE(self):
            return self.getToken(CSharpParser.REGULAR_STRING_INSIDE, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_interpolated_regular_string_part

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterInterpolated_regular_string_part"):
                listener.enterInterpolated_regular_string_part(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitInterpolated_regular_string_part"):
                listener.exitInterpolated_regular_string_part(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitInterpolated_regular_string_part"):
                return visitor.visitInterpolated_regular_string_part(self)
            else:
                return visitor.visitChildren(self)

    def interpolated_regular_string_part(self):

        localctx = CSharpParser.Interpolated_regular_string_partContext(self, self._ctx, self.state)
        self.enterRule(localctx, 392, self.RULE_interpolated_regular_string_part)
        try:
            self.state = 2402
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [CSharpParser.ADD, CSharpParser.ALIAS, CSharpParser.ARGLIST, CSharpParser.ASCENDING,
                         CSharpParser.ASYNC, CSharpParser.AWAIT, CSharpParser.BASE, CSharpParser.BOOL, CSharpParser.BY,
                         CSharpParser.BYTE, CSharpParser.CHAR, CSharpParser.CHECKED, CSharpParser.DECIMAL,
                         CSharpParser.DEFAULT, CSharpParser.DELEGATE, CSharpParser.DESCENDING, CSharpParser.DOUBLE,
                         CSharpParser.DYNAMIC, CSharpParser.EQUALS, CSharpParser.FALSE, CSharpParser.FLOAT,
                         CSharpParser.FROM, CSharpParser.GET, CSharpParser.GROUP, CSharpParser.INT, CSharpParser.INTO,
                         CSharpParser.JOIN, CSharpParser.LET, CSharpParser.LONG, CSharpParser.NAMEOF, CSharpParser.NEW,
                         CSharpParser.NULL_, CSharpParser.OBJECT, CSharpParser.ON, CSharpParser.ORDERBY,
                         CSharpParser.PARTIAL, CSharpParser.REF, CSharpParser.REMOVE, CSharpParser.SBYTE,
                         CSharpParser.SELECT, CSharpParser.SET, CSharpParser.SHORT, CSharpParser.SIZEOF,
                         CSharpParser.STRING, CSharpParser.THIS, CSharpParser.TRUE, CSharpParser.TYPEOF,
                         CSharpParser.UINT, CSharpParser.ULONG, CSharpParser.UNCHECKED, CSharpParser.UNMANAGED,
                         CSharpParser.USHORT, CSharpParser.VAR, CSharpParser.WHEN, CSharpParser.WHERE,
                         CSharpParser.YIELD, CSharpParser.IDENTIFIER, CSharpParser.LITERAL_ACCESS,
                         CSharpParser.INTEGER_LITERAL, CSharpParser.HEX_INTEGER_LITERAL,
                         CSharpParser.BIN_INTEGER_LITERAL, CSharpParser.REAL_LITERAL, CSharpParser.CHARACTER_LITERAL,
                         CSharpParser.REGULAR_STRING, CSharpParser.VERBATIUM_STRING,
                         CSharpParser.INTERPOLATED_REGULAR_STRING_START,
                         CSharpParser.INTERPOLATED_VERBATIUM_STRING_START, CSharpParser.OPEN_PARENS, CSharpParser.PLUS,
                         CSharpParser.MINUS, CSharpParser.STAR, CSharpParser.AMP, CSharpParser.CARET, CSharpParser.BANG,
                         CSharpParser.TILDE, CSharpParser.OP_INC, CSharpParser.OP_DEC, CSharpParser.OP_RANGE]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2398
                self.interpolated_string_expression()
                pass
            elif token in [CSharpParser.DOUBLE_CURLY_INSIDE]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2399
                self.match(CSharpParser.DOUBLE_CURLY_INSIDE)
                pass
            elif token in [CSharpParser.REGULAR_CHAR_INSIDE]:
                self.enterOuterAlt(localctx, 3)
                self.state = 2400
                self.match(CSharpParser.REGULAR_CHAR_INSIDE)
                pass
            elif token in [CSharpParser.REGULAR_STRING_INSIDE]:
                self.enterOuterAlt(localctx, 4)
                self.state = 2401
                self.match(CSharpParser.REGULAR_STRING_INSIDE)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Interpolated_verbatium_string_partContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def interpolated_string_expression(self):
            return self.getTypedRuleContext(CSharpParser.Interpolated_string_expressionContext, 0)

        def DOUBLE_CURLY_INSIDE(self):
            return self.getToken(CSharpParser.DOUBLE_CURLY_INSIDE, 0)

        def VERBATIUM_DOUBLE_QUOTE_INSIDE(self):
            return self.getToken(CSharpParser.VERBATIUM_DOUBLE_QUOTE_INSIDE, 0)

        def VERBATIUM_INSIDE_STRING(self):
            return self.getToken(CSharpParser.VERBATIUM_INSIDE_STRING, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_interpolated_verbatium_string_part

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterInterpolated_verbatium_string_part"):
                listener.enterInterpolated_verbatium_string_part(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitInterpolated_verbatium_string_part"):
                listener.exitInterpolated_verbatium_string_part(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitInterpolated_verbatium_string_part"):
                return visitor.visitInterpolated_verbatium_string_part(self)
            else:
                return visitor.visitChildren(self)

    def interpolated_verbatium_string_part(self):

        localctx = CSharpParser.Interpolated_verbatium_string_partContext(self, self._ctx, self.state)
        self.enterRule(localctx, 394, self.RULE_interpolated_verbatium_string_part)
        try:
            self.state = 2408
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [CSharpParser.ADD, CSharpParser.ALIAS, CSharpParser.ARGLIST, CSharpParser.ASCENDING,
                         CSharpParser.ASYNC, CSharpParser.AWAIT, CSharpParser.BASE, CSharpParser.BOOL, CSharpParser.BY,
                         CSharpParser.BYTE, CSharpParser.CHAR, CSharpParser.CHECKED, CSharpParser.DECIMAL,
                         CSharpParser.DEFAULT, CSharpParser.DELEGATE, CSharpParser.DESCENDING, CSharpParser.DOUBLE,
                         CSharpParser.DYNAMIC, CSharpParser.EQUALS, CSharpParser.FALSE, CSharpParser.FLOAT,
                         CSharpParser.FROM, CSharpParser.GET, CSharpParser.GROUP, CSharpParser.INT, CSharpParser.INTO,
                         CSharpParser.JOIN, CSharpParser.LET, CSharpParser.LONG, CSharpParser.NAMEOF, CSharpParser.NEW,
                         CSharpParser.NULL_, CSharpParser.OBJECT, CSharpParser.ON, CSharpParser.ORDERBY,
                         CSharpParser.PARTIAL, CSharpParser.REF, CSharpParser.REMOVE, CSharpParser.SBYTE,
                         CSharpParser.SELECT, CSharpParser.SET, CSharpParser.SHORT, CSharpParser.SIZEOF,
                         CSharpParser.STRING, CSharpParser.THIS, CSharpParser.TRUE, CSharpParser.TYPEOF,
                         CSharpParser.UINT, CSharpParser.ULONG, CSharpParser.UNCHECKED, CSharpParser.UNMANAGED,
                         CSharpParser.USHORT, CSharpParser.VAR, CSharpParser.WHEN, CSharpParser.WHERE,
                         CSharpParser.YIELD, CSharpParser.IDENTIFIER, CSharpParser.LITERAL_ACCESS,
                         CSharpParser.INTEGER_LITERAL, CSharpParser.HEX_INTEGER_LITERAL,
                         CSharpParser.BIN_INTEGER_LITERAL, CSharpParser.REAL_LITERAL, CSharpParser.CHARACTER_LITERAL,
                         CSharpParser.REGULAR_STRING, CSharpParser.VERBATIUM_STRING,
                         CSharpParser.INTERPOLATED_REGULAR_STRING_START,
                         CSharpParser.INTERPOLATED_VERBATIUM_STRING_START, CSharpParser.OPEN_PARENS, CSharpParser.PLUS,
                         CSharpParser.MINUS, CSharpParser.STAR, CSharpParser.AMP, CSharpParser.CARET, CSharpParser.BANG,
                         CSharpParser.TILDE, CSharpParser.OP_INC, CSharpParser.OP_DEC, CSharpParser.OP_RANGE]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2404
                self.interpolated_string_expression()
                pass
            elif token in [CSharpParser.DOUBLE_CURLY_INSIDE]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2405
                self.match(CSharpParser.DOUBLE_CURLY_INSIDE)
                pass
            elif token in [CSharpParser.VERBATIUM_DOUBLE_QUOTE_INSIDE]:
                self.enterOuterAlt(localctx, 3)
                self.state = 2406
                self.match(CSharpParser.VERBATIUM_DOUBLE_QUOTE_INSIDE)
                pass
            elif token in [CSharpParser.VERBATIUM_INSIDE_STRING]:
                self.enterOuterAlt(localctx, 4)
                self.state = 2407
                self.match(CSharpParser.VERBATIUM_INSIDE_STRING)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Interpolated_string_expressionContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(CSharpParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(CSharpParser.ExpressionContext, i)

        def COMMA(self, i: int = None):
            if i is None:
                return self.getTokens(CSharpParser.COMMA)
            else:
                return self.getToken(CSharpParser.COMMA, i)

        def COLON(self):
            return self.getToken(CSharpParser.COLON, 0)

        def FORMAT_STRING(self, i: int = None):
            if i is None:
                return self.getTokens(CSharpParser.FORMAT_STRING)
            else:
                return self.getToken(CSharpParser.FORMAT_STRING, i)

        def getRuleIndex(self):
            return CSharpParser.RULE_interpolated_string_expression

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterInterpolated_string_expression"):
                listener.enterInterpolated_string_expression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitInterpolated_string_expression"):
                listener.exitInterpolated_string_expression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitInterpolated_string_expression"):
                return visitor.visitInterpolated_string_expression(self)
            else:
                return visitor.visitChildren(self)

    def interpolated_string_expression(self):

        localctx = CSharpParser.Interpolated_string_expressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 396, self.RULE_interpolated_string_expression)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2410
            self.expression()
            self.state = 2415
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == CSharpParser.COMMA:
                self.state = 2411
                self.match(CSharpParser.COMMA)
                self.state = 2412
                self.expression()
                self.state = 2417
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 2424
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == CSharpParser.COLON:
                self.state = 2418
                self.match(CSharpParser.COLON)
                self.state = 2420
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 2419
                    self.match(CSharpParser.FORMAT_STRING)
                    self.state = 2422
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la == CSharpParser.FORMAT_STRING):
                        break



        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class KeywordContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ABSTRACT(self):
            return self.getToken(CSharpParser.ABSTRACT, 0)

        def AS(self):
            return self.getToken(CSharpParser.AS, 0)

        def BASE(self):
            return self.getToken(CSharpParser.BASE, 0)

        def BOOL(self):
            return self.getToken(CSharpParser.BOOL, 0)

        def BREAK(self):
            return self.getToken(CSharpParser.BREAK, 0)

        def BYTE(self):
            return self.getToken(CSharpParser.BYTE, 0)

        def CASE(self):
            return self.getToken(CSharpParser.CASE, 0)

        def CATCH(self):
            return self.getToken(CSharpParser.CATCH, 0)

        def CHAR(self):
            return self.getToken(CSharpParser.CHAR, 0)

        def CHECKED(self):
            return self.getToken(CSharpParser.CHECKED, 0)

        def CLASS(self):
            return self.getToken(CSharpParser.CLASS, 0)

        def CONST(self):
            return self.getToken(CSharpParser.CONST, 0)

        def CONTINUE(self):
            return self.getToken(CSharpParser.CONTINUE, 0)

        def DECIMAL(self):
            return self.getToken(CSharpParser.DECIMAL, 0)

        def DEFAULT(self):
            return self.getToken(CSharpParser.DEFAULT, 0)

        def DELEGATE(self):
            return self.getToken(CSharpParser.DELEGATE, 0)

        def DO(self):
            return self.getToken(CSharpParser.DO, 0)

        def DOUBLE(self):
            return self.getToken(CSharpParser.DOUBLE, 0)

        def ELSE(self):
            return self.getToken(CSharpParser.ELSE, 0)

        def ENUM(self):
            return self.getToken(CSharpParser.ENUM, 0)

        def EVENT(self):
            return self.getToken(CSharpParser.EVENT, 0)

        def EXPLICIT(self):
            return self.getToken(CSharpParser.EXPLICIT, 0)

        def EXTERN(self):
            return self.getToken(CSharpParser.EXTERN, 0)

        def FALSE(self):
            return self.getToken(CSharpParser.FALSE, 0)

        def FINALLY(self):
            return self.getToken(CSharpParser.FINALLY, 0)

        def FIXED(self):
            return self.getToken(CSharpParser.FIXED, 0)

        def FLOAT(self):
            return self.getToken(CSharpParser.FLOAT, 0)

        def FOR(self):
            return self.getToken(CSharpParser.FOR, 0)

        def FOREACH(self):
            return self.getToken(CSharpParser.FOREACH, 0)

        def GOTO(self):
            return self.getToken(CSharpParser.GOTO, 0)

        def IF(self):
            return self.getToken(CSharpParser.IF, 0)

        def IMPLICIT(self):
            return self.getToken(CSharpParser.IMPLICIT, 0)

        def IN(self):
            return self.getToken(CSharpParser.IN, 0)

        def INT(self):
            return self.getToken(CSharpParser.INT, 0)

        def INTERFACE(self):
            return self.getToken(CSharpParser.INTERFACE, 0)

        def INTERNAL(self):
            return self.getToken(CSharpParser.INTERNAL, 0)

        def IS(self):
            return self.getToken(CSharpParser.IS, 0)

        def LOCK(self):
            return self.getToken(CSharpParser.LOCK, 0)

        def LONG(self):
            return self.getToken(CSharpParser.LONG, 0)

        def NAMESPACE(self):
            return self.getToken(CSharpParser.NAMESPACE, 0)

        def NEW(self):
            return self.getToken(CSharpParser.NEW, 0)

        def NULL_(self):
            return self.getToken(CSharpParser.NULL_, 0)

        def OBJECT(self):
            return self.getToken(CSharpParser.OBJECT, 0)

        def OPERATOR(self):
            return self.getToken(CSharpParser.OPERATOR, 0)

        def OUT(self):
            return self.getToken(CSharpParser.OUT, 0)

        def OVERRIDE(self):
            return self.getToken(CSharpParser.OVERRIDE, 0)

        def PARAMS(self):
            return self.getToken(CSharpParser.PARAMS, 0)

        def PRIVATE(self):
            return self.getToken(CSharpParser.PRIVATE, 0)

        def PROTECTED(self):
            return self.getToken(CSharpParser.PROTECTED, 0)

        def PUBLIC(self):
            return self.getToken(CSharpParser.PUBLIC, 0)

        def READONLY(self):
            return self.getToken(CSharpParser.READONLY, 0)

        def REF(self):
            return self.getToken(CSharpParser.REF, 0)

        def RETURN(self):
            return self.getToken(CSharpParser.RETURN, 0)

        def SBYTE(self):
            return self.getToken(CSharpParser.SBYTE, 0)

        def SEALED(self):
            return self.getToken(CSharpParser.SEALED, 0)

        def SHORT(self):
            return self.getToken(CSharpParser.SHORT, 0)

        def SIZEOF(self):
            return self.getToken(CSharpParser.SIZEOF, 0)

        def STACKALLOC(self):
            return self.getToken(CSharpParser.STACKALLOC, 0)

        def STATIC(self):
            return self.getToken(CSharpParser.STATIC, 0)

        def STRING(self):
            return self.getToken(CSharpParser.STRING, 0)

        def STRUCT(self):
            return self.getToken(CSharpParser.STRUCT, 0)

        def SWITCH(self):
            return self.getToken(CSharpParser.SWITCH, 0)

        def THIS(self):
            return self.getToken(CSharpParser.THIS, 0)

        def THROW(self):
            return self.getToken(CSharpParser.THROW, 0)

        def TRUE(self):
            return self.getToken(CSharpParser.TRUE, 0)

        def TRY(self):
            return self.getToken(CSharpParser.TRY, 0)

        def TYPEOF(self):
            return self.getToken(CSharpParser.TYPEOF, 0)

        def UINT(self):
            return self.getToken(CSharpParser.UINT, 0)

        def ULONG(self):
            return self.getToken(CSharpParser.ULONG, 0)

        def UNCHECKED(self):
            return self.getToken(CSharpParser.UNCHECKED, 0)

        def UNMANAGED(self):
            return self.getToken(CSharpParser.UNMANAGED, 0)

        def UNSAFE(self):
            return self.getToken(CSharpParser.UNSAFE, 0)

        def USHORT(self):
            return self.getToken(CSharpParser.USHORT, 0)

        def USING(self):
            return self.getToken(CSharpParser.USING, 0)

        def VIRTUAL(self):
            return self.getToken(CSharpParser.VIRTUAL, 0)

        def VOID(self):
            return self.getToken(CSharpParser.VOID, 0)

        def VOLATILE(self):
            return self.getToken(CSharpParser.VOLATILE, 0)

        def WHILE(self):
            return self.getToken(CSharpParser.WHILE, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_keyword

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterKeyword"):
                listener.enterKeyword(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitKeyword"):
                listener.exitKeyword(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitKeyword"):
                return visitor.visitKeyword(self)
            else:
                return visitor.visitChildren(self)

    def keyword(self):

        localctx = CSharpParser.KeywordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 398, self.RULE_keyword)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2426
            _la = self._input.LA(1)
            if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & (
                    (1 << CSharpParser.ABSTRACT) | (1 << CSharpParser.AS) | (1 << CSharpParser.BASE) | (
                    1 << CSharpParser.BOOL) | (1 << CSharpParser.BREAK) | (1 << CSharpParser.BYTE) | (
                            1 << CSharpParser.CASE) | (1 << CSharpParser.CATCH) | (1 << CSharpParser.CHAR) | (
                            1 << CSharpParser.CHECKED) | (1 << CSharpParser.CLASS) | (1 << CSharpParser.CONST) | (
                            1 << CSharpParser.CONTINUE) | (1 << CSharpParser.DECIMAL) | (1 << CSharpParser.DEFAULT) | (
                            1 << CSharpParser.DELEGATE) | (1 << CSharpParser.DO) | (1 << CSharpParser.DOUBLE) | (
                            1 << CSharpParser.ELSE) | (1 << CSharpParser.ENUM) | (1 << CSharpParser.EVENT) | (
                            1 << CSharpParser.EXPLICIT) | (1 << CSharpParser.EXTERN) | (1 << CSharpParser.FALSE) | (
                            1 << CSharpParser.FINALLY) | (1 << CSharpParser.FIXED) | (1 << CSharpParser.FLOAT) | (
                            1 << CSharpParser.FOR) | (1 << CSharpParser.FOREACH) | (1 << CSharpParser.GOTO) | (
                            1 << CSharpParser.IF) | (1 << CSharpParser.IMPLICIT) | (1 << CSharpParser.IN) | (
                            1 << CSharpParser.INT) | (1 << CSharpParser.INTERFACE) | (1 << CSharpParser.INTERNAL) | (
                            1 << CSharpParser.IS) | (1 << CSharpParser.LOCK) | (1 << CSharpParser.LONG))) != 0) or (
                            (((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & (
                            (1 << (CSharpParser.NAMESPACE - 65)) | (1 << (CSharpParser.NEW - 65)) | (
                            1 << (CSharpParser.NULL_ - 65)) | (1 << (CSharpParser.OBJECT - 65)) | (
                                    1 << (CSharpParser.OPERATOR - 65)) | (1 << (CSharpParser.OUT - 65)) | (
                                    1 << (CSharpParser.OVERRIDE - 65)) | (1 << (CSharpParser.PARAMS - 65)) | (
                                    1 << (CSharpParser.PRIVATE - 65)) | (1 << (CSharpParser.PROTECTED - 65)) | (
                                    1 << (CSharpParser.PUBLIC - 65)) | (1 << (CSharpParser.READONLY - 65)) | (
                                    1 << (CSharpParser.REF - 65)) | (1 << (CSharpParser.RETURN - 65)) | (
                                    1 << (CSharpParser.SBYTE - 65)) | (1 << (CSharpParser.SEALED - 65)) | (
                                    1 << (CSharpParser.SHORT - 65)) | (1 << (CSharpParser.SIZEOF - 65)) | (
                                    1 << (CSharpParser.STACKALLOC - 65)) | (1 << (CSharpParser.STATIC - 65)) | (
                                    1 << (CSharpParser.STRING - 65)) | (1 << (CSharpParser.STRUCT - 65)) | (
                                    1 << (CSharpParser.SWITCH - 65)) | (1 << (CSharpParser.THIS - 65)) | (
                                    1 << (CSharpParser.THROW - 65)) | (1 << (CSharpParser.TRUE - 65)) | (
                                    1 << (CSharpParser.TRY - 65)) | (1 << (CSharpParser.TYPEOF - 65)) | (
                                    1 << (CSharpParser.UINT - 65)) | (1 << (CSharpParser.ULONG - 65)) | (
                                    1 << (CSharpParser.UNCHECKED - 65)) | (1 << (CSharpParser.UNMANAGED - 65)) | (
                                    1 << (CSharpParser.UNSAFE - 65)) | (1 << (CSharpParser.USHORT - 65)) | (
                                    1 << (CSharpParser.USING - 65)) | (1 << (CSharpParser.VIRTUAL - 65)) | (
                                    1 << (CSharpParser.VOID - 65)) | (1 << (CSharpParser.VOLATILE - 65)) | (
                                    1 << (CSharpParser.WHILE - 65)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Class_definitionContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CLASS(self):
            return self.getToken(CSharpParser.CLASS, 0)

        def identifier(self):
            return self.getTypedRuleContext(CSharpParser.IdentifierContext, 0)

        def class_body(self):
            return self.getTypedRuleContext(CSharpParser.Class_bodyContext, 0)

        def type_parameter_list(self):
            return self.getTypedRuleContext(CSharpParser.Type_parameter_listContext, 0)

        def class_base(self):
            return self.getTypedRuleContext(CSharpParser.Class_baseContext, 0)

        def type_parameter_constraints_clauses(self):
            return self.getTypedRuleContext(CSharpParser.Type_parameter_constraints_clausesContext, 0)

        def SEMICOLON(self):
            return self.getToken(CSharpParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_class_definition

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterClass_definition"):
                listener.enterClass_definition(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitClass_definition"):
                listener.exitClass_definition(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitClass_definition"):
                return visitor.visitClass_definition(self)
            else:
                return visitor.visitChildren(self)

    def class_definition(self):

        localctx = CSharpParser.Class_definitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 400, self.RULE_class_definition)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2428
            self.match(CSharpParser.CLASS)
            self.state = 2429
            self.identifier()
            self.state = 2431
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == CSharpParser.LT:
                self.state = 2430
                self.type_parameter_list()

            self.state = 2434
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == CSharpParser.COLON:
                self.state = 2433
                self.class_base()

            self.state = 2437
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == CSharpParser.WHERE:
                self.state = 2436
                self.type_parameter_constraints_clauses()

            self.state = 2439
            self.class_body()
            self.state = 2441
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == CSharpParser.SEMICOLON:
                self.state = 2440
                self.match(CSharpParser.SEMICOLON)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Struct_definitionContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRUCT(self):
            return self.getToken(CSharpParser.STRUCT, 0)

        def identifier(self):
            return self.getTypedRuleContext(CSharpParser.IdentifierContext, 0)

        def struct_body(self):
            return self.getTypedRuleContext(CSharpParser.Struct_bodyContext, 0)

        def type_parameter_list(self):
            return self.getTypedRuleContext(CSharpParser.Type_parameter_listContext, 0)

        def struct_interfaces(self):
            return self.getTypedRuleContext(CSharpParser.Struct_interfacesContext, 0)

        def type_parameter_constraints_clauses(self):
            return self.getTypedRuleContext(CSharpParser.Type_parameter_constraints_clausesContext, 0)

        def SEMICOLON(self):
            return self.getToken(CSharpParser.SEMICOLON, 0)

        def READONLY(self):
            return self.getToken(CSharpParser.READONLY, 0)

        def REF(self):
            return self.getToken(CSharpParser.REF, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_struct_definition

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterStruct_definition"):
                listener.enterStruct_definition(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitStruct_definition"):
                listener.exitStruct_definition(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitStruct_definition"):
                return visitor.visitStruct_definition(self)
            else:
                return visitor.visitChildren(self)

    def struct_definition(self):

        localctx = CSharpParser.Struct_definitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 402, self.RULE_struct_definition)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2444
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == CSharpParser.READONLY or _la == CSharpParser.REF:
                self.state = 2443
                _la = self._input.LA(1)
                if not (_la == CSharpParser.READONLY or _la == CSharpParser.REF):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()

            self.state = 2446
            self.match(CSharpParser.STRUCT)
            self.state = 2447
            self.identifier()
            self.state = 2449
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == CSharpParser.LT:
                self.state = 2448
                self.type_parameter_list()

            self.state = 2452
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == CSharpParser.COLON:
                self.state = 2451
                self.struct_interfaces()

            self.state = 2455
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == CSharpParser.WHERE:
                self.state = 2454
                self.type_parameter_constraints_clauses()

            self.state = 2457
            self.struct_body()
            self.state = 2459
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == CSharpParser.SEMICOLON:
                self.state = 2458
                self.match(CSharpParser.SEMICOLON)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Interface_definitionContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INTERFACE(self):
            return self.getToken(CSharpParser.INTERFACE, 0)

        def identifier(self):
            return self.getTypedRuleContext(CSharpParser.IdentifierContext, 0)

        def class_body(self):
            return self.getTypedRuleContext(CSharpParser.Class_bodyContext, 0)

        def variant_type_parameter_list(self):
            return self.getTypedRuleContext(CSharpParser.Variant_type_parameter_listContext, 0)

        def interface_base(self):
            return self.getTypedRuleContext(CSharpParser.Interface_baseContext, 0)

        def type_parameter_constraints_clauses(self):
            return self.getTypedRuleContext(CSharpParser.Type_parameter_constraints_clausesContext, 0)

        def SEMICOLON(self):
            return self.getToken(CSharpParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_interface_definition

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterInterface_definition"):
                listener.enterInterface_definition(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitInterface_definition"):
                listener.exitInterface_definition(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitInterface_definition"):
                return visitor.visitInterface_definition(self)
            else:
                return visitor.visitChildren(self)

    def interface_definition(self):

        localctx = CSharpParser.Interface_definitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 404, self.RULE_interface_definition)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2461
            self.match(CSharpParser.INTERFACE)
            self.state = 2462
            self.identifier()
            self.state = 2464
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == CSharpParser.LT:
                self.state = 2463
                self.variant_type_parameter_list()

            self.state = 2467
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == CSharpParser.COLON:
                self.state = 2466
                self.interface_base()

            self.state = 2470
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == CSharpParser.WHERE:
                self.state = 2469
                self.type_parameter_constraints_clauses()

            self.state = 2472
            self.class_body()
            self.state = 2474
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == CSharpParser.SEMICOLON:
                self.state = 2473
                self.match(CSharpParser.SEMICOLON)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Enum_definitionContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ENUM(self):
            return self.getToken(CSharpParser.ENUM, 0)

        def identifier(self):
            return self.getTypedRuleContext(CSharpParser.IdentifierContext, 0)

        def enum_body(self):
            return self.getTypedRuleContext(CSharpParser.Enum_bodyContext, 0)

        def enum_base(self):
            return self.getTypedRuleContext(CSharpParser.Enum_baseContext, 0)

        def SEMICOLON(self):
            return self.getToken(CSharpParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_enum_definition

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterEnum_definition"):
                listener.enterEnum_definition(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitEnum_definition"):
                listener.exitEnum_definition(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitEnum_definition"):
                return visitor.visitEnum_definition(self)
            else:
                return visitor.visitChildren(self)

    def enum_definition(self):

        localctx = CSharpParser.Enum_definitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 406, self.RULE_enum_definition)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2476
            self.match(CSharpParser.ENUM)
            self.state = 2477
            self.identifier()
            self.state = 2479
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == CSharpParser.COLON:
                self.state = 2478
                self.enum_base()

            self.state = 2481
            self.enum_body()
            self.state = 2483
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == CSharpParser.SEMICOLON:
                self.state = 2482
                self.match(CSharpParser.SEMICOLON)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Delegate_definitionContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DELEGATE(self):
            return self.getToken(CSharpParser.DELEGATE, 0)

        def return_type(self):
            return self.getTypedRuleContext(CSharpParser.Return_typeContext, 0)

        def identifier(self):
            return self.getTypedRuleContext(CSharpParser.IdentifierContext, 0)

        def OPEN_PARENS(self):
            return self.getToken(CSharpParser.OPEN_PARENS, 0)

        def CLOSE_PARENS(self):
            return self.getToken(CSharpParser.CLOSE_PARENS, 0)

        def SEMICOLON(self):
            return self.getToken(CSharpParser.SEMICOLON, 0)

        def variant_type_parameter_list(self):
            return self.getTypedRuleContext(CSharpParser.Variant_type_parameter_listContext, 0)

        def formal_parameter_list(self):
            return self.getTypedRuleContext(CSharpParser.Formal_parameter_listContext, 0)

        def type_parameter_constraints_clauses(self):
            return self.getTypedRuleContext(CSharpParser.Type_parameter_constraints_clausesContext, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_delegate_definition

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterDelegate_definition"):
                listener.enterDelegate_definition(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitDelegate_definition"):
                listener.exitDelegate_definition(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitDelegate_definition"):
                return visitor.visitDelegate_definition(self)
            else:
                return visitor.visitChildren(self)

    def delegate_definition(self):

        localctx = CSharpParser.Delegate_definitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 408, self.RULE_delegate_definition)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2485
            self.match(CSharpParser.DELEGATE)
            self.state = 2486
            self.return_type()
            self.state = 2487
            self.identifier()
            self.state = 2489
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == CSharpParser.LT:
                self.state = 2488
                self.variant_type_parameter_list()

            self.state = 2491
            self.match(CSharpParser.OPEN_PARENS)
            self.state = 2493
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 10)) & ~0x3f) == 0 and ((1 << (_la - 10)) & (
                    (1 << (CSharpParser.ADD - 10)) | (1 << (CSharpParser.ALIAS - 10)) | (
                    1 << (CSharpParser.ARGLIST - 10)) | (1 << (CSharpParser.ASCENDING - 10)) | (
                            1 << (CSharpParser.ASYNC - 10)) | (1 << (CSharpParser.AWAIT - 10)) | (
                            1 << (CSharpParser.BOOL - 10)) | (1 << (CSharpParser.BY - 10)) | (
                            1 << (CSharpParser.BYTE - 10)) | (1 << (CSharpParser.CHAR - 10)) | (
                            1 << (CSharpParser.DECIMAL - 10)) | (1 << (CSharpParser.DESCENDING - 10)) | (
                            1 << (CSharpParser.DOUBLE - 10)) | (1 << (CSharpParser.DYNAMIC - 10)) | (
                            1 << (CSharpParser.EQUALS - 10)) | (1 << (CSharpParser.FLOAT - 10)) | (
                            1 << (CSharpParser.FROM - 10)) | (1 << (CSharpParser.GET - 10)) | (
                            1 << (CSharpParser.GROUP - 10)) | (1 << (CSharpParser.IN - 10)) | (
                            1 << (CSharpParser.INT - 10)) | (1 << (CSharpParser.INTO - 10)) | (
                            1 << (CSharpParser.JOIN - 10)) | (1 << (CSharpParser.LET - 10)) | (
                            1 << (CSharpParser.LONG - 10)) | (1 << (CSharpParser.NAMEOF - 10)) | (
                            1 << (CSharpParser.OBJECT - 10)) | (1 << (CSharpParser.ON - 10)) | (
                            1 << (CSharpParser.ORDERBY - 10)) | (1 << (CSharpParser.OUT - 10)))) != 0) or (
                    (((_la - 74)) & ~0x3f) == 0 and ((1 << (_la - 74)) & (
                    (1 << (CSharpParser.PARAMS - 74)) | (1 << (CSharpParser.PARTIAL - 74)) | (
                    1 << (CSharpParser.REF - 74)) | (1 << (CSharpParser.REMOVE - 74)) | (
                            1 << (CSharpParser.SBYTE - 74)) | (1 << (CSharpParser.SELECT - 74)) | (
                            1 << (CSharpParser.SET - 74)) | (1 << (CSharpParser.SHORT - 74)) | (
                            1 << (CSharpParser.STRING - 74)) | (1 << (CSharpParser.THIS - 74)) | (
                            1 << (CSharpParser.UINT - 74)) | (1 << (CSharpParser.ULONG - 74)) | (
                            1 << (CSharpParser.UNMANAGED - 74)) | (1 << (CSharpParser.USHORT - 74)) | (
                            1 << (CSharpParser.VAR - 74)) | (1 << (CSharpParser.VOID - 74)) | (
                            1 << (CSharpParser.WHEN - 74)) | (1 << (CSharpParser.WHERE - 74)) | (
                            1 << (CSharpParser.YIELD - 74)) | (1 << (CSharpParser.IDENTIFIER - 74)) | (
                            1 << (CSharpParser.OPEN_BRACKET - 74)) | (1 << (CSharpParser.OPEN_PARENS - 74)))) != 0):
                self.state = 2492
                self.formal_parameter_list()

            self.state = 2495
            self.match(CSharpParser.CLOSE_PARENS)
            self.state = 2497
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == CSharpParser.WHERE:
                self.state = 2496
                self.type_parameter_constraints_clauses()

            self.state = 2499
            self.match(CSharpParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Event_declarationContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EVENT(self):
            return self.getToken(CSharpParser.EVENT, 0)

        def type_(self):
            return self.getTypedRuleContext(CSharpParser.Type_Context, 0)

        def variable_declarators(self):
            return self.getTypedRuleContext(CSharpParser.Variable_declaratorsContext, 0)

        def SEMICOLON(self):
            return self.getToken(CSharpParser.SEMICOLON, 0)

        def member_name(self):
            return self.getTypedRuleContext(CSharpParser.Member_nameContext, 0)

        def OPEN_BRACE(self):
            return self.getToken(CSharpParser.OPEN_BRACE, 0)

        def event_accessor_declarations(self):
            return self.getTypedRuleContext(CSharpParser.Event_accessor_declarationsContext, 0)

        def CLOSE_BRACE(self):
            return self.getToken(CSharpParser.CLOSE_BRACE, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_event_declaration

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterEvent_declaration"):
                listener.enterEvent_declaration(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitEvent_declaration"):
                listener.exitEvent_declaration(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitEvent_declaration"):
                return visitor.visitEvent_declaration(self)
            else:
                return visitor.visitChildren(self)

    def event_declaration(self):

        localctx = CSharpParser.Event_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 410, self.RULE_event_declaration)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2501
            self.match(CSharpParser.EVENT)
            self.state = 2502
            self.type_()
            self.state = 2511
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 324, self._ctx)
            if la_ == 1:
                self.state = 2503
                self.variable_declarators()
                self.state = 2504
                self.match(CSharpParser.SEMICOLON)
                pass

            elif la_ == 2:
                self.state = 2506
                self.member_name()
                self.state = 2507
                self.match(CSharpParser.OPEN_BRACE)
                self.state = 2508
                self.event_accessor_declarations()
                self.state = 2509
                self.match(CSharpParser.CLOSE_BRACE)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Field_declarationContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variable_declarators(self):
            return self.getTypedRuleContext(CSharpParser.Variable_declaratorsContext, 0)

        def SEMICOLON(self):
            return self.getToken(CSharpParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_field_declaration

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterField_declaration"):
                listener.enterField_declaration(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitField_declaration"):
                listener.exitField_declaration(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitField_declaration"):
                return visitor.visitField_declaration(self)
            else:
                return visitor.visitChildren(self)

    def field_declaration(self):

        localctx = CSharpParser.Field_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 412, self.RULE_field_declaration)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2513
            self.variable_declarators()
            self.state = 2514
            self.match(CSharpParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Property_declarationContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def member_name(self):
            return self.getTypedRuleContext(CSharpParser.Member_nameContext, 0)

        def OPEN_BRACE(self):
            return self.getToken(CSharpParser.OPEN_BRACE, 0)

        def accessor_declarations(self):
            return self.getTypedRuleContext(CSharpParser.Accessor_declarationsContext, 0)

        def CLOSE_BRACE(self):
            return self.getToken(CSharpParser.CLOSE_BRACE, 0)

        def right_arrow(self):
            return self.getTypedRuleContext(CSharpParser.Right_arrowContext, 0)

        def throwable_expression(self):
            return self.getTypedRuleContext(CSharpParser.Throwable_expressionContext, 0)

        def SEMICOLON(self):
            return self.getToken(CSharpParser.SEMICOLON, 0)

        def ASSIGNMENT(self):
            return self.getToken(CSharpParser.ASSIGNMENT, 0)

        def variable_initializer(self):
            return self.getTypedRuleContext(CSharpParser.Variable_initializerContext, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_property_declaration

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterProperty_declaration"):
                listener.enterProperty_declaration(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitProperty_declaration"):
                listener.exitProperty_declaration(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitProperty_declaration"):
                return visitor.visitProperty_declaration(self)
            else:
                return visitor.visitChildren(self)

    def property_declaration(self):

        localctx = CSharpParser.Property_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 414, self.RULE_property_declaration)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2516
            self.member_name()
            self.state = 2530
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [CSharpParser.OPEN_BRACE]:
                self.state = 2517
                self.match(CSharpParser.OPEN_BRACE)
                self.state = 2518
                self.accessor_declarations()
                self.state = 2519
                self.match(CSharpParser.CLOSE_BRACE)
                self.state = 2524
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == CSharpParser.ASSIGNMENT:
                    self.state = 2520
                    self.match(CSharpParser.ASSIGNMENT)
                    self.state = 2521
                    self.variable_initializer()
                    self.state = 2522
                    self.match(CSharpParser.SEMICOLON)

                pass
            elif token in [CSharpParser.ASSIGNMENT]:
                self.state = 2526
                self.right_arrow()
                self.state = 2527
                self.throwable_expression()
                self.state = 2528
                self.match(CSharpParser.SEMICOLON)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Constant_declarationContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CONST(self):
            return self.getToken(CSharpParser.CONST, 0)

        def type_(self):
            return self.getTypedRuleContext(CSharpParser.Type_Context, 0)

        def constant_declarators(self):
            return self.getTypedRuleContext(CSharpParser.Constant_declaratorsContext, 0)

        def SEMICOLON(self):
            return self.getToken(CSharpParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_constant_declaration

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterConstant_declaration"):
                listener.enterConstant_declaration(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitConstant_declaration"):
                listener.exitConstant_declaration(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitConstant_declaration"):
                return visitor.visitConstant_declaration(self)
            else:
                return visitor.visitChildren(self)

    def constant_declaration(self):

        localctx = CSharpParser.Constant_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 416, self.RULE_constant_declaration)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2532
            self.match(CSharpParser.CONST)
            self.state = 2533
            self.type_()
            self.state = 2534
            self.constant_declarators()
            self.state = 2535
            self.match(CSharpParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Indexer_declarationContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def THIS(self):
            return self.getToken(CSharpParser.THIS, 0)

        def OPEN_BRACKET(self):
            return self.getToken(CSharpParser.OPEN_BRACKET, 0)

        def formal_parameter_list(self):
            return self.getTypedRuleContext(CSharpParser.Formal_parameter_listContext, 0)

        def CLOSE_BRACKET(self):
            return self.getToken(CSharpParser.CLOSE_BRACKET, 0)

        def OPEN_BRACE(self):
            return self.getToken(CSharpParser.OPEN_BRACE, 0)

        def accessor_declarations(self):
            return self.getTypedRuleContext(CSharpParser.Accessor_declarationsContext, 0)

        def CLOSE_BRACE(self):
            return self.getToken(CSharpParser.CLOSE_BRACE, 0)

        def right_arrow(self):
            return self.getTypedRuleContext(CSharpParser.Right_arrowContext, 0)

        def throwable_expression(self):
            return self.getTypedRuleContext(CSharpParser.Throwable_expressionContext, 0)

        def SEMICOLON(self):
            return self.getToken(CSharpParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_indexer_declaration

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterIndexer_declaration"):
                listener.enterIndexer_declaration(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitIndexer_declaration"):
                listener.exitIndexer_declaration(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitIndexer_declaration"):
                return visitor.visitIndexer_declaration(self)
            else:
                return visitor.visitChildren(self)

    def indexer_declaration(self):

        localctx = CSharpParser.Indexer_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 418, self.RULE_indexer_declaration)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2537
            self.match(CSharpParser.THIS)
            self.state = 2538
            self.match(CSharpParser.OPEN_BRACKET)
            self.state = 2539
            self.formal_parameter_list()
            self.state = 2540
            self.match(CSharpParser.CLOSE_BRACKET)
            self.state = 2549
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [CSharpParser.OPEN_BRACE]:
                self.state = 2541
                self.match(CSharpParser.OPEN_BRACE)
                self.state = 2542
                self.accessor_declarations()
                self.state = 2543
                self.match(CSharpParser.CLOSE_BRACE)
                pass
            elif token in [CSharpParser.ASSIGNMENT]:
                self.state = 2545
                self.right_arrow()
                self.state = 2546
                self.throwable_expression()
                self.state = 2547
                self.match(CSharpParser.SEMICOLON)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Destructor_definitionContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TILDE(self):
            return self.getToken(CSharpParser.TILDE, 0)

        def identifier(self):
            return self.getTypedRuleContext(CSharpParser.IdentifierContext, 0)

        def OPEN_PARENS(self):
            return self.getToken(CSharpParser.OPEN_PARENS, 0)

        def CLOSE_PARENS(self):
            return self.getToken(CSharpParser.CLOSE_PARENS, 0)

        def body(self):
            return self.getTypedRuleContext(CSharpParser.BodyContext, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_destructor_definition

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterDestructor_definition"):
                listener.enterDestructor_definition(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitDestructor_definition"):
                listener.exitDestructor_definition(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitDestructor_definition"):
                return visitor.visitDestructor_definition(self)
            else:
                return visitor.visitChildren(self)

    def destructor_definition(self):

        localctx = CSharpParser.Destructor_definitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 420, self.RULE_destructor_definition)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2551
            self.match(CSharpParser.TILDE)
            self.state = 2552
            self.identifier()
            self.state = 2553
            self.match(CSharpParser.OPEN_PARENS)
            self.state = 2554
            self.match(CSharpParser.CLOSE_PARENS)
            self.state = 2555
            self.body()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Constructor_declarationContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(CSharpParser.IdentifierContext, 0)

        def OPEN_PARENS(self):
            return self.getToken(CSharpParser.OPEN_PARENS, 0)

        def CLOSE_PARENS(self):
            return self.getToken(CSharpParser.CLOSE_PARENS, 0)

        def body(self):
            return self.getTypedRuleContext(CSharpParser.BodyContext, 0)

        def formal_parameter_list(self):
            return self.getTypedRuleContext(CSharpParser.Formal_parameter_listContext, 0)

        def constructor_initializer(self):
            return self.getTypedRuleContext(CSharpParser.Constructor_initializerContext, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_constructor_declaration

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterConstructor_declaration"):
                listener.enterConstructor_declaration(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitConstructor_declaration"):
                listener.exitConstructor_declaration(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitConstructor_declaration"):
                return visitor.visitConstructor_declaration(self)
            else:
                return visitor.visitChildren(self)

    def constructor_declaration(self):

        localctx = CSharpParser.Constructor_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 422, self.RULE_constructor_declaration)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2557
            self.identifier()
            self.state = 2558
            self.match(CSharpParser.OPEN_PARENS)
            self.state = 2560
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 10)) & ~0x3f) == 0 and ((1 << (_la - 10)) & (
                    (1 << (CSharpParser.ADD - 10)) | (1 << (CSharpParser.ALIAS - 10)) | (
                    1 << (CSharpParser.ARGLIST - 10)) | (1 << (CSharpParser.ASCENDING - 10)) | (
                            1 << (CSharpParser.ASYNC - 10)) | (1 << (CSharpParser.AWAIT - 10)) | (
                            1 << (CSharpParser.BOOL - 10)) | (1 << (CSharpParser.BY - 10)) | (
                            1 << (CSharpParser.BYTE - 10)) | (1 << (CSharpParser.CHAR - 10)) | (
                            1 << (CSharpParser.DECIMAL - 10)) | (1 << (CSharpParser.DESCENDING - 10)) | (
                            1 << (CSharpParser.DOUBLE - 10)) | (1 << (CSharpParser.DYNAMIC - 10)) | (
                            1 << (CSharpParser.EQUALS - 10)) | (1 << (CSharpParser.FLOAT - 10)) | (
                            1 << (CSharpParser.FROM - 10)) | (1 << (CSharpParser.GET - 10)) | (
                            1 << (CSharpParser.GROUP - 10)) | (1 << (CSharpParser.IN - 10)) | (
                            1 << (CSharpParser.INT - 10)) | (1 << (CSharpParser.INTO - 10)) | (
                            1 << (CSharpParser.JOIN - 10)) | (1 << (CSharpParser.LET - 10)) | (
                            1 << (CSharpParser.LONG - 10)) | (1 << (CSharpParser.NAMEOF - 10)) | (
                            1 << (CSharpParser.OBJECT - 10)) | (1 << (CSharpParser.ON - 10)) | (
                            1 << (CSharpParser.ORDERBY - 10)) | (1 << (CSharpParser.OUT - 10)))) != 0) or (
                    (((_la - 74)) & ~0x3f) == 0 and ((1 << (_la - 74)) & (
                    (1 << (CSharpParser.PARAMS - 74)) | (1 << (CSharpParser.PARTIAL - 74)) | (
                    1 << (CSharpParser.REF - 74)) | (1 << (CSharpParser.REMOVE - 74)) | (
                            1 << (CSharpParser.SBYTE - 74)) | (1 << (CSharpParser.SELECT - 74)) | (
                            1 << (CSharpParser.SET - 74)) | (1 << (CSharpParser.SHORT - 74)) | (
                            1 << (CSharpParser.STRING - 74)) | (1 << (CSharpParser.THIS - 74)) | (
                            1 << (CSharpParser.UINT - 74)) | (1 << (CSharpParser.ULONG - 74)) | (
                            1 << (CSharpParser.UNMANAGED - 74)) | (1 << (CSharpParser.USHORT - 74)) | (
                            1 << (CSharpParser.VAR - 74)) | (1 << (CSharpParser.VOID - 74)) | (
                            1 << (CSharpParser.WHEN - 74)) | (1 << (CSharpParser.WHERE - 74)) | (
                            1 << (CSharpParser.YIELD - 74)) | (1 << (CSharpParser.IDENTIFIER - 74)) | (
                            1 << (CSharpParser.OPEN_BRACKET - 74)) | (1 << (CSharpParser.OPEN_PARENS - 74)))) != 0):
                self.state = 2559
                self.formal_parameter_list()

            self.state = 2562
            self.match(CSharpParser.CLOSE_PARENS)
            self.state = 2564
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == CSharpParser.COLON:
                self.state = 2563
                self.constructor_initializer()

            self.state = 2566
            self.body()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Method_declarationContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def method_member_name(self):
            return self.getTypedRuleContext(CSharpParser.Method_member_nameContext, 0)

        def OPEN_PARENS(self):
            return self.getToken(CSharpParser.OPEN_PARENS, 0)

        def CLOSE_PARENS(self):
            return self.getToken(CSharpParser.CLOSE_PARENS, 0)

        def method_body(self):
            return self.getTypedRuleContext(CSharpParser.Method_bodyContext, 0)

        def right_arrow(self):
            return self.getTypedRuleContext(CSharpParser.Right_arrowContext, 0)

        def throwable_expression(self):
            return self.getTypedRuleContext(CSharpParser.Throwable_expressionContext, 0)

        def SEMICOLON(self):
            return self.getToken(CSharpParser.SEMICOLON, 0)

        def type_parameter_list(self):
            return self.getTypedRuleContext(CSharpParser.Type_parameter_listContext, 0)

        def formal_parameter_list(self):
            return self.getTypedRuleContext(CSharpParser.Formal_parameter_listContext, 0)

        def type_parameter_constraints_clauses(self):
            return self.getTypedRuleContext(CSharpParser.Type_parameter_constraints_clausesContext, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_method_declaration

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterMethod_declaration"):
                listener.enterMethod_declaration(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitMethod_declaration"):
                listener.exitMethod_declaration(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitMethod_declaration"):
                return visitor.visitMethod_declaration(self)
            else:
                return visitor.visitChildren(self)

    def method_declaration(self):

        localctx = CSharpParser.Method_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 424, self.RULE_method_declaration)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2568
            self.method_member_name()
            self.state = 2570
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == CSharpParser.LT:
                self.state = 2569
                self.type_parameter_list()

            self.state = 2572
            self.match(CSharpParser.OPEN_PARENS)
            self.state = 2574
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 10)) & ~0x3f) == 0 and ((1 << (_la - 10)) & (
                    (1 << (CSharpParser.ADD - 10)) | (1 << (CSharpParser.ALIAS - 10)) | (
                    1 << (CSharpParser.ARGLIST - 10)) | (1 << (CSharpParser.ASCENDING - 10)) | (
                            1 << (CSharpParser.ASYNC - 10)) | (1 << (CSharpParser.AWAIT - 10)) | (
                            1 << (CSharpParser.BOOL - 10)) | (1 << (CSharpParser.BY - 10)) | (
                            1 << (CSharpParser.BYTE - 10)) | (1 << (CSharpParser.CHAR - 10)) | (
                            1 << (CSharpParser.DECIMAL - 10)) | (1 << (CSharpParser.DESCENDING - 10)) | (
                            1 << (CSharpParser.DOUBLE - 10)) | (1 << (CSharpParser.DYNAMIC - 10)) | (
                            1 << (CSharpParser.EQUALS - 10)) | (1 << (CSharpParser.FLOAT - 10)) | (
                            1 << (CSharpParser.FROM - 10)) | (1 << (CSharpParser.GET - 10)) | (
                            1 << (CSharpParser.GROUP - 10)) | (1 << (CSharpParser.IN - 10)) | (
                            1 << (CSharpParser.INT - 10)) | (1 << (CSharpParser.INTO - 10)) | (
                            1 << (CSharpParser.JOIN - 10)) | (1 << (CSharpParser.LET - 10)) | (
                            1 << (CSharpParser.LONG - 10)) | (1 << (CSharpParser.NAMEOF - 10)) | (
                            1 << (CSharpParser.OBJECT - 10)) | (1 << (CSharpParser.ON - 10)) | (
                            1 << (CSharpParser.ORDERBY - 10)) | (1 << (CSharpParser.OUT - 10)))) != 0) or (
                    (((_la - 74)) & ~0x3f) == 0 and ((1 << (_la - 74)) & (
                    (1 << (CSharpParser.PARAMS - 74)) | (1 << (CSharpParser.PARTIAL - 74)) | (
                    1 << (CSharpParser.REF - 74)) | (1 << (CSharpParser.REMOVE - 74)) | (
                            1 << (CSharpParser.SBYTE - 74)) | (1 << (CSharpParser.SELECT - 74)) | (
                            1 << (CSharpParser.SET - 74)) | (1 << (CSharpParser.SHORT - 74)) | (
                            1 << (CSharpParser.STRING - 74)) | (1 << (CSharpParser.THIS - 74)) | (
                            1 << (CSharpParser.UINT - 74)) | (1 << (CSharpParser.ULONG - 74)) | (
                            1 << (CSharpParser.UNMANAGED - 74)) | (1 << (CSharpParser.USHORT - 74)) | (
                            1 << (CSharpParser.VAR - 74)) | (1 << (CSharpParser.VOID - 74)) | (
                            1 << (CSharpParser.WHEN - 74)) | (1 << (CSharpParser.WHERE - 74)) | (
                            1 << (CSharpParser.YIELD - 74)) | (1 << (CSharpParser.IDENTIFIER - 74)) | (
                            1 << (CSharpParser.OPEN_BRACKET - 74)) | (1 << (CSharpParser.OPEN_PARENS - 74)))) != 0):
                self.state = 2573
                self.formal_parameter_list()

            self.state = 2576
            self.match(CSharpParser.CLOSE_PARENS)
            self.state = 2578
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == CSharpParser.WHERE:
                self.state = 2577
                self.type_parameter_constraints_clauses()

            self.state = 2585
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [CSharpParser.OPEN_BRACE, CSharpParser.SEMICOLON]:
                self.state = 2580
                self.method_body()
                pass
            elif token in [CSharpParser.ASSIGNMENT]:
                self.state = 2581
                self.right_arrow()
                self.state = 2582
                self.throwable_expression()
                self.state = 2583
                self.match(CSharpParser.SEMICOLON)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Method_member_nameContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(CSharpParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(CSharpParser.IdentifierContext, i)

        def DOUBLE_COLON(self):
            return self.getToken(CSharpParser.DOUBLE_COLON, 0)

        def DOT(self, i: int = None):
            if i is None:
                return self.getTokens(CSharpParser.DOT)
            else:
                return self.getToken(CSharpParser.DOT, i)

        def type_argument_list(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(CSharpParser.Type_argument_listContext)
            else:
                return self.getTypedRuleContext(CSharpParser.Type_argument_listContext, i)

        def getRuleIndex(self):
            return CSharpParser.RULE_method_member_name

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterMethod_member_name"):
                listener.enterMethod_member_name(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitMethod_member_name"):
                listener.exitMethod_member_name(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitMethod_member_name"):
                return visitor.visitMethod_member_name(self)
            else:
                return visitor.visitChildren(self)

    def method_member_name(self):

        localctx = CSharpParser.Method_member_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 426, self.RULE_method_member_name)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2592
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 334, self._ctx)
            if la_ == 1:
                self.state = 2587
                self.identifier()
                pass

            elif la_ == 2:
                self.state = 2588
                self.identifier()
                self.state = 2589
                self.match(CSharpParser.DOUBLE_COLON)
                self.state = 2590
                self.identifier()
                pass

            self.state = 2601
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input, 336, self._ctx)
            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 2595
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la == CSharpParser.LT:
                        self.state = 2594
                        self.type_argument_list()

                    self.state = 2597
                    self.match(CSharpParser.DOT)
                    self.state = 2598
                    self.identifier()
                self.state = 2603
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 336, self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Operator_declarationContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPERATOR(self):
            return self.getToken(CSharpParser.OPERATOR, 0)

        def overloadable_operator(self):
            return self.getTypedRuleContext(CSharpParser.Overloadable_operatorContext, 0)

        def OPEN_PARENS(self):
            return self.getToken(CSharpParser.OPEN_PARENS, 0)

        def arg_declaration(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(CSharpParser.Arg_declarationContext)
            else:
                return self.getTypedRuleContext(CSharpParser.Arg_declarationContext, i)

        def CLOSE_PARENS(self):
            return self.getToken(CSharpParser.CLOSE_PARENS, 0)

        def body(self):
            return self.getTypedRuleContext(CSharpParser.BodyContext, 0)

        def right_arrow(self):
            return self.getTypedRuleContext(CSharpParser.Right_arrowContext, 0)

        def throwable_expression(self):
            return self.getTypedRuleContext(CSharpParser.Throwable_expressionContext, 0)

        def SEMICOLON(self):
            return self.getToken(CSharpParser.SEMICOLON, 0)

        def IN(self, i: int = None):
            if i is None:
                return self.getTokens(CSharpParser.IN)
            else:
                return self.getToken(CSharpParser.IN, i)

        def COMMA(self):
            return self.getToken(CSharpParser.COMMA, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_operator_declaration

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterOperator_declaration"):
                listener.enterOperator_declaration(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitOperator_declaration"):
                listener.exitOperator_declaration(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitOperator_declaration"):
                return visitor.visitOperator_declaration(self)
            else:
                return visitor.visitChildren(self)

    def operator_declaration(self):

        localctx = CSharpParser.Operator_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 428, self.RULE_operator_declaration)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2604
            self.match(CSharpParser.OPERATOR)
            self.state = 2605
            self.overloadable_operator()
            self.state = 2606
            self.match(CSharpParser.OPEN_PARENS)
            self.state = 2608
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == CSharpParser.IN:
                self.state = 2607
                self.match(CSharpParser.IN)

            self.state = 2610
            self.arg_declaration()
            self.state = 2616
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == CSharpParser.COMMA:
                self.state = 2611
                self.match(CSharpParser.COMMA)
                self.state = 2613
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == CSharpParser.IN:
                    self.state = 2612
                    self.match(CSharpParser.IN)

                self.state = 2615
                self.arg_declaration()

            self.state = 2618
            self.match(CSharpParser.CLOSE_PARENS)
            self.state = 2624
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [CSharpParser.OPEN_BRACE, CSharpParser.SEMICOLON]:
                self.state = 2619
                self.body()
                pass
            elif token in [CSharpParser.ASSIGNMENT]:
                self.state = 2620
                self.right_arrow()
                self.state = 2621
                self.throwable_expression()
                self.state = 2622
                self.match(CSharpParser.SEMICOLON)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Arg_declarationContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def type_(self):
            return self.getTypedRuleContext(CSharpParser.Type_Context, 0)

        def identifier(self):
            return self.getTypedRuleContext(CSharpParser.IdentifierContext, 0)

        def ASSIGNMENT(self):
            return self.getToken(CSharpParser.ASSIGNMENT, 0)

        def expression(self):
            return self.getTypedRuleContext(CSharpParser.ExpressionContext, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_arg_declaration

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterArg_declaration"):
                listener.enterArg_declaration(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitArg_declaration"):
                listener.exitArg_declaration(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitArg_declaration"):
                return visitor.visitArg_declaration(self)
            else:
                return visitor.visitChildren(self)

    def arg_declaration(self):

        localctx = CSharpParser.Arg_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 430, self.RULE_arg_declaration)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2626
            self.type_()
            self.state = 2627
            self.identifier()
            self.state = 2630
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == CSharpParser.ASSIGNMENT:
                self.state = 2628
                self.match(CSharpParser.ASSIGNMENT)
                self.state = 2629
                self.expression()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Method_invocationContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPEN_PARENS(self):
            return self.getToken(CSharpParser.OPEN_PARENS, 0)

        def CLOSE_PARENS(self):
            return self.getToken(CSharpParser.CLOSE_PARENS, 0)

        def argument_list(self):
            return self.getTypedRuleContext(CSharpParser.Argument_listContext, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_method_invocation

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterMethod_invocation"):
                listener.enterMethod_invocation(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitMethod_invocation"):
                listener.exitMethod_invocation(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitMethod_invocation"):
                return visitor.visitMethod_invocation(self)
            else:
                return visitor.visitChildren(self)

    def method_invocation(self):

        localctx = CSharpParser.Method_invocationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 432, self.RULE_method_invocation)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2632
            self.match(CSharpParser.OPEN_PARENS)
            self.state = 2634
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & (
                    (1 << CSharpParser.ADD) | (1 << CSharpParser.ALIAS) | (1 << CSharpParser.ARGLIST) | (
                    1 << CSharpParser.ASCENDING) | (1 << CSharpParser.ASYNC) | (1 << CSharpParser.AWAIT) | (
                            1 << CSharpParser.BASE) | (1 << CSharpParser.BOOL) | (1 << CSharpParser.BY) | (
                            1 << CSharpParser.BYTE) | (1 << CSharpParser.CHAR) | (1 << CSharpParser.CHECKED) | (
                            1 << CSharpParser.DECIMAL) | (1 << CSharpParser.DEFAULT) | (1 << CSharpParser.DELEGATE) | (
                            1 << CSharpParser.DESCENDING) | (1 << CSharpParser.DOUBLE) | (1 << CSharpParser.DYNAMIC) | (
                            1 << CSharpParser.EQUALS) | (1 << CSharpParser.FALSE) | (1 << CSharpParser.FLOAT) | (
                            1 << CSharpParser.FROM) | (1 << CSharpParser.GET) | (1 << CSharpParser.GROUP) | (
                            1 << CSharpParser.IN) | (1 << CSharpParser.INT) | (1 << CSharpParser.INTO) | (
                            1 << CSharpParser.JOIN) | (1 << CSharpParser.LET) | (1 << CSharpParser.LONG))) != 0) or (
                    (((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & (
                    (1 << (CSharpParser.NAMEOF - 64)) | (1 << (CSharpParser.NEW - 64)) | (
                    1 << (CSharpParser.NULL_ - 64)) | (1 << (CSharpParser.OBJECT - 64)) | (
                            1 << (CSharpParser.ON - 64)) | (1 << (CSharpParser.ORDERBY - 64)) | (
                            1 << (CSharpParser.OUT - 64)) | (1 << (CSharpParser.PARTIAL - 64)) | (
                            1 << (CSharpParser.REF - 64)) | (1 << (CSharpParser.REMOVE - 64)) | (
                            1 << (CSharpParser.SBYTE - 64)) | (1 << (CSharpParser.SELECT - 64)) | (
                            1 << (CSharpParser.SET - 64)) | (1 << (CSharpParser.SHORT - 64)) | (
                            1 << (CSharpParser.SIZEOF - 64)) | (1 << (CSharpParser.STRING - 64)) | (
                            1 << (CSharpParser.THIS - 64)) | (1 << (CSharpParser.TRUE - 64)) | (
                            1 << (CSharpParser.TYPEOF - 64)) | (1 << (CSharpParser.UINT - 64)) | (
                            1 << (CSharpParser.ULONG - 64)) | (1 << (CSharpParser.UNCHECKED - 64)) | (
                            1 << (CSharpParser.UNMANAGED - 64)) | (1 << (CSharpParser.USHORT - 64)) | (
                            1 << (CSharpParser.VAR - 64)) | (1 << (CSharpParser.VOID - 64)) | (
                            1 << (CSharpParser.WHEN - 64)) | (1 << (CSharpParser.WHERE - 64)) | (
                            1 << (CSharpParser.YIELD - 64)) | (1 << (CSharpParser.IDENTIFIER - 64)) | (
                            1 << (CSharpParser.LITERAL_ACCESS - 64)) | (1 << (CSharpParser.INTEGER_LITERAL - 64)) | (
                            1 << (CSharpParser.HEX_INTEGER_LITERAL - 64)) | (
                            1 << (CSharpParser.BIN_INTEGER_LITERAL - 64)) | (1 << (CSharpParser.REAL_LITERAL - 64)) | (
                            1 << (CSharpParser.CHARACTER_LITERAL - 64)) | (1 << (CSharpParser.REGULAR_STRING - 64)) | (
                            1 << (CSharpParser.VERBATIUM_STRING - 64)) | (
                            1 << (CSharpParser.INTERPOLATED_REGULAR_STRING_START - 64)) | (
                            1 << (CSharpParser.INTERPOLATED_VERBATIUM_STRING_START - 64)))) != 0) or (
                    (((_la - 129)) & ~0x3f) == 0 and ((1 << (_la - 129)) & (
                    (1 << (CSharpParser.OPEN_PARENS - 129)) | (1 << (CSharpParser.PLUS - 129)) | (
                    1 << (CSharpParser.MINUS - 129)) | (1 << (CSharpParser.STAR - 129)) | (
                            1 << (CSharpParser.AMP - 129)) | (1 << (CSharpParser.CARET - 129)) | (
                            1 << (CSharpParser.BANG - 129)) | (1 << (CSharpParser.TILDE - 129)) | (
                            1 << (CSharpParser.OP_INC - 129)) | (1 << (CSharpParser.OP_DEC - 129)) | (
                            1 << (CSharpParser.OP_RANGE - 129)))) != 0):
                self.state = 2633
                self.argument_list()

            self.state = 2636
            self.match(CSharpParser.CLOSE_PARENS)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Object_creation_expressionContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPEN_PARENS(self):
            return self.getToken(CSharpParser.OPEN_PARENS, 0)

        def CLOSE_PARENS(self):
            return self.getToken(CSharpParser.CLOSE_PARENS, 0)

        def argument_list(self):
            return self.getTypedRuleContext(CSharpParser.Argument_listContext, 0)

        def object_or_collection_initializer(self):
            return self.getTypedRuleContext(CSharpParser.Object_or_collection_initializerContext, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_object_creation_expression

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterObject_creation_expression"):
                listener.enterObject_creation_expression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitObject_creation_expression"):
                listener.exitObject_creation_expression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitObject_creation_expression"):
                return visitor.visitObject_creation_expression(self)
            else:
                return visitor.visitChildren(self)

    def object_creation_expression(self):

        localctx = CSharpParser.Object_creation_expressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 434, self.RULE_object_creation_expression)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2638
            self.match(CSharpParser.OPEN_PARENS)
            self.state = 2640
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & (
                    (1 << CSharpParser.ADD) | (1 << CSharpParser.ALIAS) | (1 << CSharpParser.ARGLIST) | (
                    1 << CSharpParser.ASCENDING) | (1 << CSharpParser.ASYNC) | (1 << CSharpParser.AWAIT) | (
                            1 << CSharpParser.BASE) | (1 << CSharpParser.BOOL) | (1 << CSharpParser.BY) | (
                            1 << CSharpParser.BYTE) | (1 << CSharpParser.CHAR) | (1 << CSharpParser.CHECKED) | (
                            1 << CSharpParser.DECIMAL) | (1 << CSharpParser.DEFAULT) | (1 << CSharpParser.DELEGATE) | (
                            1 << CSharpParser.DESCENDING) | (1 << CSharpParser.DOUBLE) | (1 << CSharpParser.DYNAMIC) | (
                            1 << CSharpParser.EQUALS) | (1 << CSharpParser.FALSE) | (1 << CSharpParser.FLOAT) | (
                            1 << CSharpParser.FROM) | (1 << CSharpParser.GET) | (1 << CSharpParser.GROUP) | (
                            1 << CSharpParser.IN) | (1 << CSharpParser.INT) | (1 << CSharpParser.INTO) | (
                            1 << CSharpParser.JOIN) | (1 << CSharpParser.LET) | (1 << CSharpParser.LONG))) != 0) or (
                    (((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & (
                    (1 << (CSharpParser.NAMEOF - 64)) | (1 << (CSharpParser.NEW - 64)) | (
                    1 << (CSharpParser.NULL_ - 64)) | (1 << (CSharpParser.OBJECT - 64)) | (
                            1 << (CSharpParser.ON - 64)) | (1 << (CSharpParser.ORDERBY - 64)) | (
                            1 << (CSharpParser.OUT - 64)) | (1 << (CSharpParser.PARTIAL - 64)) | (
                            1 << (CSharpParser.REF - 64)) | (1 << (CSharpParser.REMOVE - 64)) | (
                            1 << (CSharpParser.SBYTE - 64)) | (1 << (CSharpParser.SELECT - 64)) | (
                            1 << (CSharpParser.SET - 64)) | (1 << (CSharpParser.SHORT - 64)) | (
                            1 << (CSharpParser.SIZEOF - 64)) | (1 << (CSharpParser.STRING - 64)) | (
                            1 << (CSharpParser.THIS - 64)) | (1 << (CSharpParser.TRUE - 64)) | (
                            1 << (CSharpParser.TYPEOF - 64)) | (1 << (CSharpParser.UINT - 64)) | (
                            1 << (CSharpParser.ULONG - 64)) | (1 << (CSharpParser.UNCHECKED - 64)) | (
                            1 << (CSharpParser.UNMANAGED - 64)) | (1 << (CSharpParser.USHORT - 64)) | (
                            1 << (CSharpParser.VAR - 64)) | (1 << (CSharpParser.VOID - 64)) | (
                            1 << (CSharpParser.WHEN - 64)) | (1 << (CSharpParser.WHERE - 64)) | (
                            1 << (CSharpParser.YIELD - 64)) | (1 << (CSharpParser.IDENTIFIER - 64)) | (
                            1 << (CSharpParser.LITERAL_ACCESS - 64)) | (1 << (CSharpParser.INTEGER_LITERAL - 64)) | (
                            1 << (CSharpParser.HEX_INTEGER_LITERAL - 64)) | (
                            1 << (CSharpParser.BIN_INTEGER_LITERAL - 64)) | (1 << (CSharpParser.REAL_LITERAL - 64)) | (
                            1 << (CSharpParser.CHARACTER_LITERAL - 64)) | (1 << (CSharpParser.REGULAR_STRING - 64)) | (
                            1 << (CSharpParser.VERBATIUM_STRING - 64)) | (
                            1 << (CSharpParser.INTERPOLATED_REGULAR_STRING_START - 64)) | (
                            1 << (CSharpParser.INTERPOLATED_VERBATIUM_STRING_START - 64)))) != 0) or (
                    (((_la - 129)) & ~0x3f) == 0 and ((1 << (_la - 129)) & (
                    (1 << (CSharpParser.OPEN_PARENS - 129)) | (1 << (CSharpParser.PLUS - 129)) | (
                    1 << (CSharpParser.MINUS - 129)) | (1 << (CSharpParser.STAR - 129)) | (
                            1 << (CSharpParser.AMP - 129)) | (1 << (CSharpParser.CARET - 129)) | (
                            1 << (CSharpParser.BANG - 129)) | (1 << (CSharpParser.TILDE - 129)) | (
                            1 << (CSharpParser.OP_INC - 129)) | (1 << (CSharpParser.OP_DEC - 129)) | (
                            1 << (CSharpParser.OP_RANGE - 129)))) != 0):
                self.state = 2639
                self.argument_list()

            self.state = 2642
            self.match(CSharpParser.CLOSE_PARENS)
            self.state = 2644
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 344, self._ctx)
            if la_ == 1:
                self.state = 2643
                self.object_or_collection_initializer()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class IdentifierContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(CSharpParser.IDENTIFIER, 0)

        def ADD(self):
            return self.getToken(CSharpParser.ADD, 0)

        def ALIAS(self):
            return self.getToken(CSharpParser.ALIAS, 0)

        def ARGLIST(self):
            return self.getToken(CSharpParser.ARGLIST, 0)

        def ASCENDING(self):
            return self.getToken(CSharpParser.ASCENDING, 0)

        def ASYNC(self):
            return self.getToken(CSharpParser.ASYNC, 0)

        def AWAIT(self):
            return self.getToken(CSharpParser.AWAIT, 0)

        def BY(self):
            return self.getToken(CSharpParser.BY, 0)

        def DESCENDING(self):
            return self.getToken(CSharpParser.DESCENDING, 0)

        def DYNAMIC(self):
            return self.getToken(CSharpParser.DYNAMIC, 0)

        def EQUALS(self):
            return self.getToken(CSharpParser.EQUALS, 0)

        def FROM(self):
            return self.getToken(CSharpParser.FROM, 0)

        def GET(self):
            return self.getToken(CSharpParser.GET, 0)

        def GROUP(self):
            return self.getToken(CSharpParser.GROUP, 0)

        def INTO(self):
            return self.getToken(CSharpParser.INTO, 0)

        def JOIN(self):
            return self.getToken(CSharpParser.JOIN, 0)

        def LET(self):
            return self.getToken(CSharpParser.LET, 0)

        def NAMEOF(self):
            return self.getToken(CSharpParser.NAMEOF, 0)

        def ON(self):
            return self.getToken(CSharpParser.ON, 0)

        def ORDERBY(self):
            return self.getToken(CSharpParser.ORDERBY, 0)

        def PARTIAL(self):
            return self.getToken(CSharpParser.PARTIAL, 0)

        def REMOVE(self):
            return self.getToken(CSharpParser.REMOVE, 0)

        def SELECT(self):
            return self.getToken(CSharpParser.SELECT, 0)

        def SET(self):
            return self.getToken(CSharpParser.SET, 0)

        def UNMANAGED(self):
            return self.getToken(CSharpParser.UNMANAGED, 0)

        def VAR(self):
            return self.getToken(CSharpParser.VAR, 0)

        def WHEN(self):
            return self.getToken(CSharpParser.WHEN, 0)

        def WHERE(self):
            return self.getToken(CSharpParser.WHERE, 0)

        def YIELD(self):
            return self.getToken(CSharpParser.YIELD, 0)

        def getRuleIndex(self):
            return CSharpParser.RULE_identifier

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterIdentifier"):
                listener.enterIdentifier(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitIdentifier"):
                listener.exitIdentifier(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitIdentifier"):
                return visitor.visitIdentifier(self)
            else:
                return visitor.visitChildren(self)

    def identifier(self):

        localctx = CSharpParser.IdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 436, self.RULE_identifier)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2646
            _la = self._input.LA(1)
            if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & (
                    (1 << CSharpParser.ADD) | (1 << CSharpParser.ALIAS) | (1 << CSharpParser.ARGLIST) | (
                    1 << CSharpParser.ASCENDING) | (1 << CSharpParser.ASYNC) | (1 << CSharpParser.AWAIT) | (
                            1 << CSharpParser.BY) | (1 << CSharpParser.DESCENDING) | (1 << CSharpParser.DYNAMIC) | (
                            1 << CSharpParser.EQUALS) | (1 << CSharpParser.FROM) | (1 << CSharpParser.GET) | (
                            1 << CSharpParser.GROUP) | (1 << CSharpParser.INTO) | (1 << CSharpParser.JOIN) | (
                            1 << CSharpParser.LET))) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & (
                    (1 << (CSharpParser.NAMEOF - 64)) | (1 << (CSharpParser.ON - 64)) | (
                    1 << (CSharpParser.ORDERBY - 64)) | (1 << (CSharpParser.PARTIAL - 64)) | (
                            1 << (CSharpParser.REMOVE - 64)) | (1 << (CSharpParser.SELECT - 64)) | (
                            1 << (CSharpParser.SET - 64)) | (1 << (CSharpParser.UNMANAGED - 64)) | (
                            1 << (CSharpParser.VAR - 64)) | (1 << (CSharpParser.WHEN - 64)) | (
                            1 << (CSharpParser.WHERE - 64)) | (1 << (CSharpParser.YIELD - 64)) | (
                            1 << (CSharpParser.IDENTIFIER - 64)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    def sempred(self, localctx: RuleContext, ruleIndex: int, predIndex: int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[87] = self.local_variable_declaration_sempred
        self._predicates[188] = self.right_arrow_sempred
        self._predicates[189] = self.right_shift_sempred
        self._predicates[190] = self.right_shift_assignment_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def local_variable_declaration_sempred(self, localctx: Local_variable_declarationContext, predIndex: int):
        if predIndex == 0:
            return self.IsLocalVariableDeclaration()

    def right_arrow_sempred(self, localctx: Right_arrowContext, predIndex: int):
        if predIndex == 1:
            return (0 if localctx.first is None else localctx.first.tokenIndex) + 1 == (
                0 if localctx.second is None else localctx.second.tokenIndex)

    def right_shift_sempred(self, localctx: Right_shiftContext, predIndex: int):
        if predIndex == 2:
            return (0 if localctx.first is None else localctx.first.tokenIndex) + 1 == (
                0 if localctx.second is None else localctx.second.tokenIndex)

    def right_shift_assignment_sempred(self, localctx: Right_shift_assignmentContext, predIndex: int):
        if predIndex == 3:
            return (0 if localctx.first is None else localctx.first.tokenIndex) + 1 == (
                0 if localctx.second is None else localctx.second.tokenIndex)
         




